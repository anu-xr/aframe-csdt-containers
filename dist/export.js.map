{"mappings":"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OsF,WAAW3F,GAAGU;MAEzCV,GAAGE,aAAaU,KAAKgF,IACnBhF,KAAKiF,IAAIjF,KAAKkF,MAAMJ,YAAY1F,GAAGiF,kBAAkB,KAAK1N,KAAKsI,gBAC/DtI,KAAKuI;;;IAKTE,GAAGK,OAAO0F,IAAI/F,GAAGU;;IAGjBgD,KAAK2B,SAAS;MACZ1B,KAAK2B,IAAI,kBAAkBtF,GAAGK,OAAO2F;MACrCrC,KAAK2B,IAAI,oBAAoBtF,GAAGQ,QAAQwF;;;IAI1ChG,GAAGwD,KAAKkB,YAAYpK,OAAOwG,KAAKgD,SAASmC;;;;;;;;;;MC7LhCC,mBACV,SAAS,wBAAwB,OAAO,cAAc,QACtD,WAAW,qBAAqB,MAAM,MAAM,gBAC5C,UAAU,oBAAoB,OAAO,MAAM;;;ACH9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;C,U,S,O,W,mB;;M,sB,e,c,oB,S,c,c,W,c,gB,W,c;;;M,yB,a,uB,c,a;M,Q,gB;;M,qB,W,sB,O,Y,c,O,Q,K;E,oB,M;S,M;W,Q;;;;Y,wB,a,uB,c,a;a,U;iB,e,M;;;;;;Y;iB,gB,M;;;Y,sB,S;iB,Y;;Y,U,M,yB,O;Q,I,O;c;;M,a,U;M,a;U,S,M,Y,W,O;M,Q,M,G,K,O,S,c,Q,O,S;;W,M,M;I,sB;a,W,a,Q;;I,iB;a,Q,M,G,M;;;E,gB;I,K,K;I,K,S;I,K;;E,W,kB;E,W,S;E,W,U;E,W,Q;E,W,S;E,W,W,U,I;I,Q,O,U,S;M,O,U;;;E,O,e,Y;I,K;a,a;;;E,a,qB;W,I,G,I,M,Q;I,W,M;;M;;;Q,c,W;;e,Y,mB,W;M,O,U;sB,W,c,O;M,O;e;;e;M,K,c;;;;E,U,U,S,Q;QJvCIxP,WAAW;QAASC,WAAW;QAAUC,aAAa;QAAUC,eAAe;IAAmCC,OAAOC,OAAOC,gBAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;QAqChJ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xoD,KAAK,KAAKA;UACVgB,UAAUhB,GAAGgB;UACb0mD,WAAW1mD,QAAQ0mD;UAEnB55B,QAAQ9sB,QAAQkM,MAAMy7C,aAAa;UACnCt9C,OAAOrK,QAAQkM,MAAM07C,cAAc;QAErC5nD,QAAQ6nD,WAAW7nD,QAAQ8nD,KAAKz9C,MAAMyiB;QAEtCi7B,kBAAkB;QAClB/nD,QAAQgoD,GAAG;;;MAGbD,kBAAkB/nD,QAAQoB,SAAS6mD;MACnCjoD,QAAQoB,SAAS6mD,aAAa;;IAGhCvB,SAASzhD,OAAOjF,QAAQoB,UAAUpB,QAAQwE;QAEtCujD,iBAAiB/nD,QAAQoB,SAAS6mD,aAAaF;;;;;ACxHvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["./node_modules/@parcel/runtime-browser-hmr/lib/HMRRuntime.js","./src/export.js","./src/csdt-container.js","./src/constants.js","./node_modules/@parcel/transformer-js/lib/esmodule-helpers.js","./CSDT/dist/ConnectionManager.js","./CSDT/src/ConnectionManager.js","./CSDT/src/Connection.js","../node_modules/yjs/dist/yjs.cjs","../node_modules/lib0/dist/observable.cjs","../node_modules/lib0/dist/map-28a001c9.cjs","../node_modules/lib0/dist/set-7ae96d21.cjs","../node_modules/lib0/dist/array-b2d24238.cjs","../node_modules/lib0/dist/array.cjs","../node_modules/lib0/dist/math.cjs","../node_modules/lib0/dist/math-08e068f9.cjs","../node_modules/lib0/dist/map.cjs","../node_modules/lib0/dist/encoding.cjs","../node_modules/lib0/dist/buffer-ac2cdedf.cjs","./node_modules/buffer/index.js","./node_modules/base64-js/index.js","./node_modules/ieee754/index.js","../node_modules/lib0/dist/string-f3c3d805.cjs","../node_modules/lib0/dist/environment-7e2ffaea.cjs","./node_modules/process/browser.js","../node_modules/lib0/dist/conditions-fb475c70.cjs","../node_modules/lib0/dist/storage.cjs","../node_modules/lib0/dist/binary-ac8e39e2.cjs","../node_modules/lib0/dist/number-24f1eabe.cjs","../node_modules/lib0/dist/decoding.cjs","../node_modules/lib0/dist/random.cjs","../node_modules/isomorphic.js/browser.mjs","../node_modules/lib0/dist/buffer.cjs","../node_modules/lib0/dist/error.cjs","../node_modules/lib0/dist/error-55a9a8c8.cjs","../node_modules/lib0/dist/binary.cjs","../node_modules/lib0/dist/function.cjs","../node_modules/lib0/dist/object-dcdd6eed.cjs","../node_modules/lib0/dist/function-f8acb5f5.cjs","../node_modules/lib0/dist/set.cjs","../node_modules/lib0/dist/logging.cjs","../node_modules/lib0/dist/symbol-c5caa724.cjs","../node_modules/lib0/dist/pair-ab022bc3.cjs","../node_modules/lib0/dist/dom-58958c04.cjs","../node_modules/lib0/dist/json-092190a1.cjs","../node_modules/lib0/dist/eventloop-c60b5658.cjs","../node_modules/lib0/dist/time-e00067da.cjs","../node_modules/lib0/dist/metric.cjs","../node_modules/lib0/dist/logging-7cc36806.cjs","../node_modules/lib0/dist/time.cjs","../node_modules/lib0/dist/iterator.cjs","../node_modules/lib0/dist/iterator-fe01d209.cjs","../node_modules/lib0/dist/object.cjs","./CSDT/src/helpers.js","./CSDT/src/constants.js","./CSDT/src/Message.js","./CSDT/src/ParentConnection.js","./src/csdt-container-receiver.js","./src/csdt-container-renderer.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _plugin() {\n  const data = require(\"@parcel/plugin\");\n\n  _plugin = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _fs() {\n  const data = _interopRequireDefault(require(\"fs\"));\n\n  _fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _utils() {\n  const data = require(\"@parcel/utils\");\n\n  _utils = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = _interopRequireDefault(require(\"path\"));\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst HMR_RUNTIME = _fs().default.readFileSync(_path().default.join(__dirname, './loaders/hmr-runtime.js'), 'utf8');\n\nvar _default = new (_plugin().Runtime)({\n  apply({\n    bundle,\n    options\n  }) {\n    if (bundle.type !== 'js' || !options.hmrOptions) {\n      return;\n    }\n\n    const {\n      host,\n      port\n    } = options.hmrOptions;\n    return {\n      filePath: __filename,\n      code: `var HMR_HOST = ${JSON.stringify(host != null ? host : null)};` + `var HMR_PORT = ${JSON.stringify(port != null ? port : null)};` + `var HMR_SECURE = ${JSON.stringify(!!(options.serveOptions && options.serveOptions.https))};` + `var HMR_ENV_HASH = \"${(0, _utils().md5FromObject)(bundle.env)}\";` + `module.bundle.HMR_BUNDLE_ID = ${JSON.stringify(bundle.id)};` + HMR_RUNTIME,\n      isEntry: true\n    };\n  }\n\n});\n\nexports.default = _default;",null,null,null,"\"use strict\";\n\nexports.interopDefault = function (a) {\n  return a && a.__esModule ? a : {\n    default: a\n  };\n};\n\nexports.defineInteropFlag = function (a) {\n  Object.defineProperty(a, '__esModule', {\n    value: true\n  });\n};\n\nexports.exportAll = function (source, dest) {\n  Object.keys(source).forEach(function (key) {\n    if (key === 'default' || key === '__esModule') {\n      return;\n    } // Skip duplicate re-exports when they have the same value.\n\n\n    if (key in dest && dest[key] === source[key]) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function () {\n        return source[key];\n      }\n    });\n  });\n  return dest;\n};\n\nexports.export = function (dest, destName, get) {\n  Object.defineProperty(dest, destName, {\n    enumerable: true,\n    get: get\n  });\n};",null,null,null,"'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar observable = require('lib0/dist/observable.cjs');\nvar array = require('lib0/dist/array.cjs');\nvar math = require('lib0/dist/math.cjs');\nvar map = require('lib0/dist/map.cjs');\nvar encoding = require('lib0/dist/encoding.cjs');\nvar decoding = require('lib0/dist/decoding.cjs');\nvar random = require('lib0/dist/random.cjs');\nvar buffer = require('lib0/dist/buffer.cjs');\nvar error = require('lib0/dist/error.cjs');\nvar binary = require('lib0/dist/binary.cjs');\nvar f = require('lib0/dist/function.cjs');\nvar set = require('lib0/dist/set.cjs');\nvar logging = require('lib0/dist/logging.cjs');\nvar time = require('lib0/dist/time.cjs');\nvar iterator = require('lib0/dist/iterator.cjs');\nvar object = require('lib0/dist/object.cjs');\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n  n['default'] = e;\n  return Object.freeze(n);\n}\n\nvar array__namespace = /*#__PURE__*/_interopNamespace(array);\nvar math__namespace = /*#__PURE__*/_interopNamespace(math);\nvar map__namespace = /*#__PURE__*/_interopNamespace(map);\nvar encoding__namespace = /*#__PURE__*/_interopNamespace(encoding);\nvar decoding__namespace = /*#__PURE__*/_interopNamespace(decoding);\nvar random__namespace = /*#__PURE__*/_interopNamespace(random);\nvar buffer__namespace = /*#__PURE__*/_interopNamespace(buffer);\nvar error__namespace = /*#__PURE__*/_interopNamespace(error);\nvar binary__namespace = /*#__PURE__*/_interopNamespace(binary);\nvar f__namespace = /*#__PURE__*/_interopNamespace(f);\nvar set__namespace = /*#__PURE__*/_interopNamespace(set);\nvar logging__namespace = /*#__PURE__*/_interopNamespace(logging);\nvar time__namespace = /*#__PURE__*/_interopNamespace(time);\nvar iterator__namespace = /*#__PURE__*/_interopNamespace(iterator);\nvar object__namespace = /*#__PURE__*/_interopNamespace(object);\n\n/**\n * This is an abstract interface that all Connectors should implement to keep them interchangeable.\n *\n * @note This interface is experimental and it is not advised to actually inherit this class.\n *       It just serves as typing information.\n *\n * @extends {Observable<any>}\n */\nclass AbstractConnector extends observable.Observable {\n  /**\n   * @param {Doc} ydoc\n   * @param {any} awareness\n   */\n  constructor (ydoc, awareness) {\n    super();\n    this.doc = ydoc;\n    this.awareness = awareness;\n  }\n}\n\nclass DeleteItem {\n  /**\n   * @param {number} clock\n   * @param {number} len\n   */\n  constructor (clock, len) {\n    /**\n     * @type {number}\n     */\n    this.clock = clock;\n    /**\n     * @type {number}\n     */\n    this.len = len;\n  }\n}\n\n/**\n * We no longer maintain a DeleteStore. DeleteSet is a temporary object that is created when needed.\n * - When created in a transaction, it must only be accessed after sorting, and merging\n *   - This DeleteSet is send to other clients\n * - We do not create a DeleteSet when we send a sync message. The DeleteSet message is created directly from StructStore\n * - We read a DeleteSet as part of a sync/update message. In this case the DeleteSet is already sorted and merged.\n */\nclass DeleteSet {\n  constructor () {\n    /**\n     * @type {Map<number,Array<DeleteItem>>}\n     */\n    this.clients = new Map();\n  }\n}\n\n/**\n * Iterate over all structs that the DeleteSet gc's.\n *\n * @param {Transaction} transaction\n * @param {DeleteSet} ds\n * @param {function(GC|Item):void} f\n *\n * @function\n */\nconst iterateDeletedStructs = (transaction, ds, f) =>\n  ds.clients.forEach((deletes, clientid) => {\n    const structs = /** @type {Array<GC|Item>} */ (transaction.doc.store.clients.get(clientid));\n    for (let i = 0; i < deletes.length; i++) {\n      const del = deletes[i];\n      iterateStructs(transaction, structs, del.clock, del.len, f);\n    }\n  });\n\n/**\n * @param {Array<DeleteItem>} dis\n * @param {number} clock\n * @return {number|null}\n *\n * @private\n * @function\n */\nconst findIndexDS = (dis, clock) => {\n  let left = 0;\n  let right = dis.length - 1;\n  while (left <= right) {\n    const midindex = math__namespace.floor((left + right) / 2);\n    const mid = dis[midindex];\n    const midclock = mid.clock;\n    if (midclock <= clock) {\n      if (clock < midclock + mid.len) {\n        return midindex\n      }\n      left = midindex + 1;\n    } else {\n      right = midindex - 1;\n    }\n  }\n  return null\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {ID} id\n * @return {boolean}\n *\n * @private\n * @function\n */\nconst isDeleted = (ds, id) => {\n  const dis = ds.clients.get(id.client);\n  return dis !== undefined && findIndexDS(dis, id.clock) !== null\n};\n\n/**\n * @param {DeleteSet} ds\n *\n * @private\n * @function\n */\nconst sortAndMergeDeleteSet = ds => {\n  ds.clients.forEach(dels => {\n    dels.sort((a, b) => a.clock - b.clock);\n    // merge items without filtering or splicing the array\n    // i is the current pointer\n    // j refers to the current insert position for the pointed item\n    // try to merge dels[i] into dels[j-1] or set dels[j]=dels[i]\n    let i, j;\n    for (i = 1, j = 1; i < dels.length; i++) {\n      const left = dels[j - 1];\n      const right = dels[i];\n      if (left.clock + left.len >= right.clock) {\n        left.len = math__namespace.max(left.len, right.clock + right.len - left.clock);\n      } else {\n        if (j < i) {\n          dels[j] = right;\n        }\n        j++;\n      }\n    }\n    dels.length = j;\n  });\n};\n\n/**\n * @param {Array<DeleteSet>} dss\n * @return {DeleteSet} A fresh DeleteSet\n */\nconst mergeDeleteSets = dss => {\n  const merged = new DeleteSet();\n  for (let dssI = 0; dssI < dss.length; dssI++) {\n    dss[dssI].clients.forEach((delsLeft, client) => {\n      if (!merged.clients.has(client)) {\n        // Write all missing keys from current ds and all following.\n        // If merged already contains `client` current ds has already been added.\n        /**\n         * @type {Array<DeleteItem>}\n         */\n        const dels = delsLeft.slice();\n        for (let i = dssI + 1; i < dss.length; i++) {\n          array__namespace.appendTo(dels, dss[i].clients.get(client) || []);\n        }\n        merged.clients.set(client, dels);\n      }\n    });\n  }\n  sortAndMergeDeleteSet(merged);\n  return merged\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {number} client\n * @param {number} clock\n * @param {number} length\n *\n * @private\n * @function\n */\nconst addToDeleteSet = (ds, client, clock, length) => {\n  map__namespace.setIfUndefined(ds.clients, client, () => []).push(new DeleteItem(clock, length));\n};\n\nconst createDeleteSet = () => new DeleteSet();\n\n/**\n * @param {StructStore} ss\n * @return {DeleteSet} Merged and sorted DeleteSet\n *\n * @private\n * @function\n */\nconst createDeleteSetFromStructStore = ss => {\n  const ds = createDeleteSet();\n  ss.clients.forEach((structs, client) => {\n    /**\n     * @type {Array<DeleteItem>}\n     */\n    const dsitems = [];\n    for (let i = 0; i < structs.length; i++) {\n      const struct = structs[i];\n      if (struct.deleted) {\n        const clock = struct.id.clock;\n        let len = struct.length;\n        if (i + 1 < structs.length) {\n          for (let next = structs[i + 1]; i + 1 < structs.length && next.deleted; next = structs[++i + 1]) {\n            len += next.length;\n          }\n        }\n        dsitems.push(new DeleteItem(clock, len));\n      }\n    }\n    if (dsitems.length > 0) {\n      ds.clients.set(client, dsitems);\n    }\n  });\n  return ds\n};\n\n/**\n * @param {DSEncoderV1 | DSEncoderV2} encoder\n * @param {DeleteSet} ds\n *\n * @private\n * @function\n */\nconst writeDeleteSet = (encoder, ds) => {\n  encoding__namespace.writeVarUint(encoder.restEncoder, ds.clients.size);\n  ds.clients.forEach((dsitems, client) => {\n    encoder.resetDsCurVal();\n    encoding__namespace.writeVarUint(encoder.restEncoder, client);\n    const len = dsitems.length;\n    encoding__namespace.writeVarUint(encoder.restEncoder, len);\n    for (let i = 0; i < len; i++) {\n      const item = dsitems[i];\n      encoder.writeDsClock(item.clock);\n      encoder.writeDsLen(item.len);\n    }\n  });\n};\n\n/**\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @return {DeleteSet}\n *\n * @private\n * @function\n */\nconst readDeleteSet = decoder => {\n  const ds = new DeleteSet();\n  const numClients = decoding__namespace.readVarUint(decoder.restDecoder);\n  for (let i = 0; i < numClients; i++) {\n    decoder.resetDsCurVal();\n    const client = decoding__namespace.readVarUint(decoder.restDecoder);\n    const numberOfDeletes = decoding__namespace.readVarUint(decoder.restDecoder);\n    if (numberOfDeletes > 0) {\n      const dsField = map__namespace.setIfUndefined(ds.clients, client, () => []);\n      for (let i = 0; i < numberOfDeletes; i++) {\n        dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()));\n      }\n    }\n  }\n  return ds\n};\n\n/**\n * @todo YDecoder also contains references to String and other Decoders. Would make sense to exchange YDecoder.toUint8Array for YDecoder.DsToUint8Array()..\n */\n\n/**\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @return {Uint8Array|null} Returns a v2 update containing all deletes that couldn't be applied yet; or null if all deletes were applied successfully.\n *\n * @private\n * @function\n */\nconst readAndApplyDeleteSet = (decoder, transaction, store) => {\n  const unappliedDS = new DeleteSet();\n  const numClients = decoding__namespace.readVarUint(decoder.restDecoder);\n  for (let i = 0; i < numClients; i++) {\n    decoder.resetDsCurVal();\n    const client = decoding__namespace.readVarUint(decoder.restDecoder);\n    const numberOfDeletes = decoding__namespace.readVarUint(decoder.restDecoder);\n    const structs = store.clients.get(client) || [];\n    const state = getState(store, client);\n    for (let i = 0; i < numberOfDeletes; i++) {\n      const clock = decoder.readDsClock();\n      const clockEnd = clock + decoder.readDsLen();\n      if (clock < state) {\n        if (state < clockEnd) {\n          addToDeleteSet(unappliedDS, client, state, clockEnd - state);\n        }\n        let index = findIndexSS(structs, clock);\n        /**\n         * We can ignore the case of GC and Delete structs, because we are going to skip them\n         * @type {Item}\n         */\n        // @ts-ignore\n        let struct = structs[index];\n        // split the first item if necessary\n        if (!struct.deleted && struct.id.clock < clock) {\n          structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));\n          index++; // increase we now want to use the next struct\n        }\n        while (index < structs.length) {\n          // @ts-ignore\n          struct = structs[index++];\n          if (struct.id.clock < clockEnd) {\n            if (!struct.deleted) {\n              if (clockEnd < struct.id.clock + struct.length) {\n                structs.splice(index, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));\n              }\n              struct.delete(transaction);\n            }\n          } else {\n            break\n          }\n        }\n      } else {\n        addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);\n      }\n    }\n  }\n  if (unappliedDS.clients.size > 0) {\n    const ds = new UpdateEncoderV2();\n    encoding__namespace.writeVarUint(ds.restEncoder, 0); // encode 0 structs\n    writeDeleteSet(ds, unappliedDS);\n    return ds.toUint8Array()\n  }\n  return null\n};\n\n/**\n * @module Y\n */\n\nconst generateNewClientId = random__namespace.uint32;\n\n/**\n * @typedef {Object} DocOpts\n * @property {boolean} [DocOpts.gc=true] Disable garbage collection (default: gc=true)\n * @property {function(Item):boolean} [DocOpts.gcFilter] Will be called before an Item is garbage collected. Return false to keep the Item.\n * @property {string} [DocOpts.guid] Define a globally unique identifier for this document\n * @property {any} [DocOpts.meta] Any kind of meta information you want to associate with this document. If this is a subdocument, remote peers will store the meta information as well.\n * @property {boolean} [DocOpts.autoLoad] If a subdocument, automatically load document. If this is a subdocument, remote peers will load the document as well automatically.\n */\n\n/**\n * A Yjs instance handles the state of shared data.\n * @extends Observable<string>\n */\nclass Doc extends observable.Observable {\n  /**\n   * @param {DocOpts} [opts] configuration\n   */\n  constructor ({ guid = random__namespace.uuidv4(), gc = true, gcFilter = () => true, meta = null, autoLoad = false } = {}) {\n    super();\n    this.gc = gc;\n    this.gcFilter = gcFilter;\n    this.clientID = generateNewClientId();\n    this.guid = guid;\n    /**\n     * @type {Map<string, AbstractType<YEvent>>}\n     */\n    this.share = new Map();\n    this.store = new StructStore();\n    /**\n     * @type {Transaction | null}\n     */\n    this._transaction = null;\n    /**\n     * @type {Array<Transaction>}\n     */\n    this._transactionCleanups = [];\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocs = new Set();\n    /**\n     * If this document is a subdocument - a document integrated into another document - then _item is defined.\n     * @type {Item?}\n     */\n    this._item = null;\n    this.shouldLoad = autoLoad;\n    this.autoLoad = autoLoad;\n    this.meta = meta;\n  }\n\n  /**\n   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).\n   *\n   * `load()` might be used in the future to request any provider to load the most current data.\n   *\n   * It is safe to call `load()` multiple times.\n   */\n  load () {\n    const item = this._item;\n    if (item !== null && !this.shouldLoad) {\n      transact(/** @type {any} */ (item.parent).doc, transaction => {\n        transaction.subdocsLoaded.add(this);\n      }, null, true);\n    }\n    this.shouldLoad = true;\n  }\n\n  getSubdocs () {\n    return this.subdocs\n  }\n\n  getSubdocGuids () {\n    return new Set(Array.from(this.subdocs).map(doc => doc.guid))\n  }\n\n  /**\n   * Changes that happen inside of a transaction are bundled. This means that\n   * the observer fires _after_ the transaction is finished and that all changes\n   * that happened inside of the transaction are sent as one message to the\n   * other peers.\n   *\n   * @param {function(Transaction):void} f The function that should be executed as a transaction\n   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin\n   *\n   * @public\n   */\n  transact (f, origin = null) {\n    transact(this, f, origin);\n  }\n\n  /**\n   * Define a shared data type.\n   *\n   * Multiple calls of `y.get(name, TypeConstructor)` yield the same result\n   * and do not overwrite each other. I.e.\n   * `y.define(name, Y.Array) === y.define(name, Y.Array)`\n   *\n   * After this method is called, the type is also available on `y.share.get(name)`.\n   *\n   * *Best Practices:*\n   * Define all types right after the Yjs instance is created and store them in a separate object.\n   * Also use the typed methods `getText(name)`, `getArray(name)`, ..\n   *\n   * @example\n   *   const y = new Y(..)\n   *   const appState = {\n   *     document: y.getText('document')\n   *     comments: y.getArray('comments')\n   *   }\n   *\n   * @param {string} name\n   * @param {Function} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...\n   * @return {AbstractType<any>} The created type. Constructed with TypeConstructor\n   *\n   * @public\n   */\n  get (name, TypeConstructor = AbstractType) {\n    const type = map__namespace.setIfUndefined(this.share, name, () => {\n      // @ts-ignore\n      const t = new TypeConstructor();\n      t._integrate(this, null);\n      return t\n    });\n    const Constr = type.constructor;\n    if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {\n      if (Constr === AbstractType) {\n        // @ts-ignore\n        const t = new TypeConstructor();\n        t._map = type._map;\n        type._map.forEach(/** @param {Item?} n */ n => {\n          for (; n !== null; n = n.left) {\n            // @ts-ignore\n            n.parent = t;\n          }\n        });\n        t._start = type._start;\n        for (let n = t._start; n !== null; n = n.right) {\n          n.parent = t;\n        }\n        t._length = type._length;\n        this.share.set(name, t);\n        t._integrate(this, null);\n        return t\n      } else {\n        throw new Error(`Type with the name ${name} has already been defined with a different constructor`)\n      }\n    }\n    return type\n  }\n\n  /**\n   * @template T\n   * @param {string} [name]\n   * @return {YArray<T>}\n   *\n   * @public\n   */\n  getArray (name = '') {\n    // @ts-ignore\n    return this.get(name, YArray)\n  }\n\n  /**\n   * @param {string} [name]\n   * @return {YText}\n   *\n   * @public\n   */\n  getText (name = '') {\n    // @ts-ignore\n    return this.get(name, YText)\n  }\n\n  /**\n   * @param {string} [name]\n   * @return {YMap<any>}\n   *\n   * @public\n   */\n  getMap (name = '') {\n    // @ts-ignore\n    return this.get(name, YMap)\n  }\n\n  /**\n   * @param {string} [name]\n   * @return {YXmlFragment}\n   *\n   * @public\n   */\n  getXmlFragment (name = '') {\n    // @ts-ignore\n    return this.get(name, YXmlFragment)\n  }\n\n  /**\n   * Converts the entire document into a js object, recursively traversing each yjs type\n   * Doesn't log types that have not been defined (using ydoc.getType(..)).\n   *\n   * @deprecated Do not use this method and rather call toJSON directly on the shared types.\n   *\n   * @return {Object<string, any>}\n   */\n  toJSON () {\n    /**\n     * @type {Object<string, any>}\n     */\n    const doc = {};\n\n    this.share.forEach((value, key) => {\n      doc[key] = value.toJSON();\n    });\n\n    return doc\n  }\n\n  /**\n   * Emit `destroy` event and unregister all event handlers.\n   */\n  destroy () {\n    array__namespace.from(this.subdocs).forEach(subdoc => subdoc.destroy());\n    const item = this._item;\n    if (item !== null) {\n      this._item = null;\n      const content = /** @type {ContentDoc} */ (item.content);\n      if (item.deleted) {\n        // @ts-ignore\n        content.doc = null;\n      } else {\n        content.doc = new Doc({ guid: this.guid, ...content.opts });\n        content.doc._item = item;\n      }\n      transact(/** @type {any} */ (item).parent.doc, transaction => {\n        if (!item.deleted) {\n          transaction.subdocsAdded.add(content.doc);\n        }\n        transaction.subdocsRemoved.add(this);\n      }, null, true);\n    }\n    this.emit('destroyed', [true]);\n    this.emit('destroy', [this]);\n    super.destroy();\n  }\n\n  /**\n   * @param {string} eventName\n   * @param {function(...any):any} f\n   */\n  on (eventName, f) {\n    super.on(eventName, f);\n  }\n\n  /**\n   * @param {string} eventName\n   * @param {function} f\n   */\n  off (eventName, f) {\n    super.off(eventName, f);\n  }\n}\n\nclass DSDecoderV1 {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor (decoder) {\n    this.restDecoder = decoder;\n  }\n\n  resetDsCurVal () {\n    // nop\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsClock () {\n    return decoding__namespace.readVarUint(this.restDecoder)\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsLen () {\n    return decoding__namespace.readVarUint(this.restDecoder)\n  }\n}\n\nclass UpdateDecoderV1 extends DSDecoderV1 {\n  /**\n   * @return {ID}\n   */\n  readLeftID () {\n    return createID(decoding__namespace.readVarUint(this.restDecoder), decoding__namespace.readVarUint(this.restDecoder))\n  }\n\n  /**\n   * @return {ID}\n   */\n  readRightID () {\n    return createID(decoding__namespace.readVarUint(this.restDecoder), decoding__namespace.readVarUint(this.restDecoder))\n  }\n\n  /**\n   * Read the next client id.\n   * Use this in favor of readID whenever possible to reduce the number of objects created.\n   */\n  readClient () {\n    return decoding__namespace.readVarUint(this.restDecoder)\n  }\n\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readInfo () {\n    return decoding__namespace.readUint8(this.restDecoder)\n  }\n\n  /**\n   * @return {string}\n   */\n  readString () {\n    return decoding__namespace.readVarString(this.restDecoder)\n  }\n\n  /**\n   * @return {boolean} isKey\n   */\n  readParentInfo () {\n    return decoding__namespace.readVarUint(this.restDecoder) === 1\n  }\n\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readTypeRef () {\n    return decoding__namespace.readVarUint(this.restDecoder)\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @return {number} len\n   */\n  readLen () {\n    return decoding__namespace.readVarUint(this.restDecoder)\n  }\n\n  /**\n   * @return {any}\n   */\n  readAny () {\n    return decoding__namespace.readAny(this.restDecoder)\n  }\n\n  /**\n   * @return {Uint8Array}\n   */\n  readBuf () {\n    return buffer__namespace.copyUint8Array(decoding__namespace.readVarUint8Array(this.restDecoder))\n  }\n\n  /**\n   * Legacy implementation uses JSON parse. We use any-decoding in v2.\n   *\n   * @return {any}\n   */\n  readJSON () {\n    return JSON.parse(decoding__namespace.readVarString(this.restDecoder))\n  }\n\n  /**\n   * @return {string}\n   */\n  readKey () {\n    return decoding__namespace.readVarString(this.restDecoder)\n  }\n}\n\nclass DSDecoderV2 {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor (decoder) {\n    /**\n     * @private\n     */\n    this.dsCurrVal = 0;\n    this.restDecoder = decoder;\n  }\n\n  resetDsCurVal () {\n    this.dsCurrVal = 0;\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsClock () {\n    this.dsCurrVal += decoding__namespace.readVarUint(this.restDecoder);\n    return this.dsCurrVal\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsLen () {\n    const diff = decoding__namespace.readVarUint(this.restDecoder) + 1;\n    this.dsCurrVal += diff;\n    return diff\n  }\n}\n\nclass UpdateDecoderV2 extends DSDecoderV2 {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor (decoder) {\n    super(decoder);\n    /**\n     * List of cached keys. If the keys[id] does not exist, we read a new key\n     * from stringEncoder and push it to keys.\n     *\n     * @type {Array<string>}\n     */\n    this.keys = [];\n    decoding__namespace.readVarUint(decoder); // read feature flag - currently unused\n    this.keyClockDecoder = new decoding__namespace.IntDiffOptRleDecoder(decoding__namespace.readVarUint8Array(decoder));\n    this.clientDecoder = new decoding__namespace.UintOptRleDecoder(decoding__namespace.readVarUint8Array(decoder));\n    this.leftClockDecoder = new decoding__namespace.IntDiffOptRleDecoder(decoding__namespace.readVarUint8Array(decoder));\n    this.rightClockDecoder = new decoding__namespace.IntDiffOptRleDecoder(decoding__namespace.readVarUint8Array(decoder));\n    this.infoDecoder = new decoding__namespace.RleDecoder(decoding__namespace.readVarUint8Array(decoder), decoding__namespace.readUint8);\n    this.stringDecoder = new decoding__namespace.StringDecoder(decoding__namespace.readVarUint8Array(decoder));\n    this.parentInfoDecoder = new decoding__namespace.RleDecoder(decoding__namespace.readVarUint8Array(decoder), decoding__namespace.readUint8);\n    this.typeRefDecoder = new decoding__namespace.UintOptRleDecoder(decoding__namespace.readVarUint8Array(decoder));\n    this.lenDecoder = new decoding__namespace.UintOptRleDecoder(decoding__namespace.readVarUint8Array(decoder));\n  }\n\n  /**\n   * @return {ID}\n   */\n  readLeftID () {\n    return new ID(this.clientDecoder.read(), this.leftClockDecoder.read())\n  }\n\n  /**\n   * @return {ID}\n   */\n  readRightID () {\n    return new ID(this.clientDecoder.read(), this.rightClockDecoder.read())\n  }\n\n  /**\n   * Read the next client id.\n   * Use this in favor of readID whenever possible to reduce the number of objects created.\n   */\n  readClient () {\n    return this.clientDecoder.read()\n  }\n\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readInfo () {\n    return /** @type {number} */ (this.infoDecoder.read())\n  }\n\n  /**\n   * @return {string}\n   */\n  readString () {\n    return this.stringDecoder.read()\n  }\n\n  /**\n   * @return {boolean}\n   */\n  readParentInfo () {\n    return this.parentInfoDecoder.read() === 1\n  }\n\n  /**\n   * @return {number} An unsigned 8-bit integer\n   */\n  readTypeRef () {\n    return this.typeRefDecoder.read()\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @return {number}\n   */\n  readLen () {\n    return this.lenDecoder.read()\n  }\n\n  /**\n   * @return {any}\n   */\n  readAny () {\n    return decoding__namespace.readAny(this.restDecoder)\n  }\n\n  /**\n   * @return {Uint8Array}\n   */\n  readBuf () {\n    return decoding__namespace.readVarUint8Array(this.restDecoder)\n  }\n\n  /**\n   * This is mainly here for legacy purposes.\n   *\n   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.\n   *\n   * @return {any}\n   */\n  readJSON () {\n    return decoding__namespace.readAny(this.restDecoder)\n  }\n\n  /**\n   * @return {string}\n   */\n  readKey () {\n    const keyClock = this.keyClockDecoder.read();\n    if (keyClock < this.keys.length) {\n      return this.keys[keyClock]\n    } else {\n      const key = this.stringDecoder.read();\n      this.keys.push(key);\n      return key\n    }\n  }\n}\n\nclass DSEncoderV1 {\n  constructor () {\n    this.restEncoder = encoding__namespace.createEncoder();\n  }\n\n  toUint8Array () {\n    return encoding__namespace.toUint8Array(this.restEncoder)\n  }\n\n  resetDsCurVal () {\n    // nop\n  }\n\n  /**\n   * @param {number} clock\n   */\n  writeDsClock (clock) {\n    encoding__namespace.writeVarUint(this.restEncoder, clock);\n  }\n\n  /**\n   * @param {number} len\n   */\n  writeDsLen (len) {\n    encoding__namespace.writeVarUint(this.restEncoder, len);\n  }\n}\n\nclass UpdateEncoderV1 extends DSEncoderV1 {\n  /**\n   * @param {ID} id\n   */\n  writeLeftID (id) {\n    encoding__namespace.writeVarUint(this.restEncoder, id.client);\n    encoding__namespace.writeVarUint(this.restEncoder, id.clock);\n  }\n\n  /**\n   * @param {ID} id\n   */\n  writeRightID (id) {\n    encoding__namespace.writeVarUint(this.restEncoder, id.client);\n    encoding__namespace.writeVarUint(this.restEncoder, id.clock);\n  }\n\n  /**\n   * Use writeClient and writeClock instead of writeID if possible.\n   * @param {number} client\n   */\n  writeClient (client) {\n    encoding__namespace.writeVarUint(this.restEncoder, client);\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeInfo (info) {\n    encoding__namespace.writeUint8(this.restEncoder, info);\n  }\n\n  /**\n   * @param {string} s\n   */\n  writeString (s) {\n    encoding__namespace.writeVarString(this.restEncoder, s);\n  }\n\n  /**\n   * @param {boolean} isYKey\n   */\n  writeParentInfo (isYKey) {\n    encoding__namespace.writeVarUint(this.restEncoder, isYKey ? 1 : 0);\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeTypeRef (info) {\n    encoding__namespace.writeVarUint(this.restEncoder, info);\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @param {number} len\n   */\n  writeLen (len) {\n    encoding__namespace.writeVarUint(this.restEncoder, len);\n  }\n\n  /**\n   * @param {any} any\n   */\n  writeAny (any) {\n    encoding__namespace.writeAny(this.restEncoder, any);\n  }\n\n  /**\n   * @param {Uint8Array} buf\n   */\n  writeBuf (buf) {\n    encoding__namespace.writeVarUint8Array(this.restEncoder, buf);\n  }\n\n  /**\n   * @param {any} embed\n   */\n  writeJSON (embed) {\n    encoding__namespace.writeVarString(this.restEncoder, JSON.stringify(embed));\n  }\n\n  /**\n   * @param {string} key\n   */\n  writeKey (key) {\n    encoding__namespace.writeVarString(this.restEncoder, key);\n  }\n}\n\nclass DSEncoderV2 {\n  constructor () {\n    this.restEncoder = encoding__namespace.createEncoder(); // encodes all the rest / non-optimized\n    this.dsCurrVal = 0;\n  }\n\n  toUint8Array () {\n    return encoding__namespace.toUint8Array(this.restEncoder)\n  }\n\n  resetDsCurVal () {\n    this.dsCurrVal = 0;\n  }\n\n  /**\n   * @param {number} clock\n   */\n  writeDsClock (clock) {\n    const diff = clock - this.dsCurrVal;\n    this.dsCurrVal = clock;\n    encoding__namespace.writeVarUint(this.restEncoder, diff);\n  }\n\n  /**\n   * @param {number} len\n   */\n  writeDsLen (len) {\n    if (len === 0) {\n      error__namespace.unexpectedCase();\n    }\n    encoding__namespace.writeVarUint(this.restEncoder, len - 1);\n    this.dsCurrVal += len;\n  }\n}\n\nclass UpdateEncoderV2 extends DSEncoderV2 {\n  constructor () {\n    super();\n    /**\n     * @type {Map<string,number>}\n     */\n    this.keyMap = new Map();\n    /**\n     * Refers to the next uniqe key-identifier to me used.\n     * See writeKey method for more information.\n     *\n     * @type {number}\n     */\n    this.keyClock = 0;\n    this.keyClockEncoder = new encoding__namespace.IntDiffOptRleEncoder();\n    this.clientEncoder = new encoding__namespace.UintOptRleEncoder();\n    this.leftClockEncoder = new encoding__namespace.IntDiffOptRleEncoder();\n    this.rightClockEncoder = new encoding__namespace.IntDiffOptRleEncoder();\n    this.infoEncoder = new encoding__namespace.RleEncoder(encoding__namespace.writeUint8);\n    this.stringEncoder = new encoding__namespace.StringEncoder();\n    this.parentInfoEncoder = new encoding__namespace.RleEncoder(encoding__namespace.writeUint8);\n    this.typeRefEncoder = new encoding__namespace.UintOptRleEncoder();\n    this.lenEncoder = new encoding__namespace.UintOptRleEncoder();\n  }\n\n  toUint8Array () {\n    const encoder = encoding__namespace.createEncoder();\n    encoding__namespace.writeVarUint(encoder, 0); // this is a feature flag that we might use in the future\n    encoding__namespace.writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array());\n    encoding__namespace.writeVarUint8Array(encoder, this.clientEncoder.toUint8Array());\n    encoding__namespace.writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array());\n    encoding__namespace.writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array());\n    encoding__namespace.writeVarUint8Array(encoder, encoding__namespace.toUint8Array(this.infoEncoder));\n    encoding__namespace.writeVarUint8Array(encoder, this.stringEncoder.toUint8Array());\n    encoding__namespace.writeVarUint8Array(encoder, encoding__namespace.toUint8Array(this.parentInfoEncoder));\n    encoding__namespace.writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array());\n    encoding__namespace.writeVarUint8Array(encoder, this.lenEncoder.toUint8Array());\n    // @note The rest encoder is appended! (note the missing var)\n    encoding__namespace.writeUint8Array(encoder, encoding__namespace.toUint8Array(this.restEncoder));\n    return encoding__namespace.toUint8Array(encoder)\n  }\n\n  /**\n   * @param {ID} id\n   */\n  writeLeftID (id) {\n    this.clientEncoder.write(id.client);\n    this.leftClockEncoder.write(id.clock);\n  }\n\n  /**\n   * @param {ID} id\n   */\n  writeRightID (id) {\n    this.clientEncoder.write(id.client);\n    this.rightClockEncoder.write(id.clock);\n  }\n\n  /**\n   * @param {number} client\n   */\n  writeClient (client) {\n    this.clientEncoder.write(client);\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeInfo (info) {\n    this.infoEncoder.write(info);\n  }\n\n  /**\n   * @param {string} s\n   */\n  writeString (s) {\n    this.stringEncoder.write(s);\n  }\n\n  /**\n   * @param {boolean} isYKey\n   */\n  writeParentInfo (isYKey) {\n    this.parentInfoEncoder.write(isYKey ? 1 : 0);\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeTypeRef (info) {\n    this.typeRefEncoder.write(info);\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @param {number} len\n   */\n  writeLen (len) {\n    this.lenEncoder.write(len);\n  }\n\n  /**\n   * @param {any} any\n   */\n  writeAny (any) {\n    encoding__namespace.writeAny(this.restEncoder, any);\n  }\n\n  /**\n   * @param {Uint8Array} buf\n   */\n  writeBuf (buf) {\n    encoding__namespace.writeVarUint8Array(this.restEncoder, buf);\n  }\n\n  /**\n   * This is mainly here for legacy purposes.\n   *\n   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.\n   *\n   * @param {any} embed\n   */\n  writeJSON (embed) {\n    encoding__namespace.writeAny(this.restEncoder, embed);\n  }\n\n  /**\n   * Property keys are often reused. For example, in y-prosemirror the key `bold` might\n   * occur very often. For a 3d application, the key `position` might occur very often.\n   *\n   * We cache these keys in a Map and refer to them via a unique number.\n   *\n   * @param {string} key\n   */\n  writeKey (key) {\n    const clock = this.keyMap.get(key);\n    if (clock === undefined) {\n      this.keyClockEncoder.write(this.keyClock++);\n      this.stringEncoder.write(key);\n    } else {\n      this.keyClockEncoder.write(this.keyClock++);\n    }\n  }\n}\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Array<GC|Item>} structs All structs by `client`\n * @param {number} client\n * @param {number} clock write structs starting with `ID(client,clock)`\n *\n * @function\n */\nconst writeStructs = (encoder, structs, client, clock) => {\n  // write first id\n  clock = math__namespace.max(clock, structs[0].id.clock); // make sure the first id exists\n  const startNewStructs = findIndexSS(structs, clock);\n  // write # encoded structs\n  encoding__namespace.writeVarUint(encoder.restEncoder, structs.length - startNewStructs);\n  encoder.writeClient(client);\n  encoding__namespace.writeVarUint(encoder.restEncoder, clock);\n  const firstStruct = structs[startNewStructs];\n  // write first struct with an offset\n  firstStruct.write(encoder, clock - firstStruct.id.clock);\n  for (let i = startNewStructs + 1; i < structs.length; i++) {\n    structs[i].write(encoder, 0);\n  }\n};\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {StructStore} store\n * @param {Map<number,number>} _sm\n *\n * @private\n * @function\n */\nconst writeClientsStructs = (encoder, store, _sm) => {\n  // we filter all valid _sm entries into sm\n  const sm = new Map();\n  _sm.forEach((clock, client) => {\n    // only write if new structs are available\n    if (getState(store, client) > clock) {\n      sm.set(client, clock);\n    }\n  });\n  getStateVector(store).forEach((clock, client) => {\n    if (!_sm.has(client)) {\n      sm.set(client, 0);\n    }\n  });\n  // write # states that were updated\n  encoding__namespace.writeVarUint(encoder.restEncoder, sm.size);\n  // Write items with higher client ids first\n  // This heavily improves the conflict algorithm.\n  Array.from(sm.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {\n    // @ts-ignore\n    writeStructs(encoder, store.clients.get(client), client, clock);\n  });\n};\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder The decoder object to read data from.\n * @param {Doc} doc\n * @return {Map<number, { i: number, refs: Array<Item | GC> }>}\n *\n * @private\n * @function\n */\nconst readClientsStructRefs = (decoder, doc) => {\n  /**\n   * @type {Map<number, { i: number, refs: Array<Item | GC> }>}\n   */\n  const clientRefs = map__namespace.create();\n  const numOfStateUpdates = decoding__namespace.readVarUint(decoder.restDecoder);\n  for (let i = 0; i < numOfStateUpdates; i++) {\n    const numberOfStructs = decoding__namespace.readVarUint(decoder.restDecoder);\n    /**\n     * @type {Array<GC|Item>}\n     */\n    const refs = new Array(numberOfStructs);\n    const client = decoder.readClient();\n    let clock = decoding__namespace.readVarUint(decoder.restDecoder);\n    // const start = performance.now()\n    clientRefs.set(client, { i: 0, refs });\n    for (let i = 0; i < numberOfStructs; i++) {\n      const info = decoder.readInfo();\n      switch (binary__namespace.BITS5 & info) {\n        case 0: { // GC\n          const len = decoder.readLen();\n          refs[i] = new GC(createID(client, clock), len);\n          clock += len;\n          break\n        }\n        case 10: { // Skip Struct (nothing to apply)\n          // @todo we could reduce the amount of checks by adding Skip struct to clientRefs so we know that something is missing.\n          const len = decoding__namespace.readVarUint(decoder.restDecoder);\n          refs[i] = new Skip(createID(client, clock), len);\n          clock += len;\n          break\n        }\n        default: { // Item with content\n          /**\n           * The optimized implementation doesn't use any variables because inlining variables is faster.\n           * Below a non-optimized version is shown that implements the basic algorithm with\n           * a few comments\n           */\n          const cantCopyParentInfo = (info & (binary__namespace.BIT7 | binary__namespace.BIT8)) === 0;\n          // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n          // and we read the next string as parentYKey.\n          // It indicates how we store/retrieve parent from `y.share`\n          // @type {string|null}\n          const struct = new Item(\n            createID(client, clock),\n            null, // leftd\n            (info & binary__namespace.BIT8) === binary__namespace.BIT8 ? decoder.readLeftID() : null, // origin\n            null, // right\n            (info & binary__namespace.BIT7) === binary__namespace.BIT7 ? decoder.readRightID() : null, // right origin\n            cantCopyParentInfo ? (decoder.readParentInfo() ? doc.get(decoder.readString()) : decoder.readLeftID()) : null, // parent\n            cantCopyParentInfo && (info & binary__namespace.BIT6) === binary__namespace.BIT6 ? decoder.readString() : null, // parentSub\n            readItemContent(decoder, info) // item content\n          );\n          /* A non-optimized implementation of the above algorithm:\n\n          // The item that was originally to the left of this item.\n          const origin = (info & binary.BIT8) === binary.BIT8 ? decoder.readLeftID() : null\n          // The item that was originally to the right of this item.\n          const rightOrigin = (info & binary.BIT7) === binary.BIT7 ? decoder.readRightID() : null\n          const cantCopyParentInfo = (info & (binary.BIT7 | binary.BIT8)) === 0\n          const hasParentYKey = cantCopyParentInfo ? decoder.readParentInfo() : false\n          // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n          // and we read the next string as parentYKey.\n          // It indicates how we store/retrieve parent from `y.share`\n          // @type {string|null}\n          const parentYKey = cantCopyParentInfo && hasParentYKey ? decoder.readString() : null\n\n          const struct = new Item(\n            createID(client, clock),\n            null, // leftd\n            origin, // origin\n            null, // right\n            rightOrigin, // right origin\n            cantCopyParentInfo && !hasParentYKey ? decoder.readLeftID() : (parentYKey !== null ? doc.get(parentYKey) : null), // parent\n            cantCopyParentInfo && (info & binary.BIT6) === binary.BIT6 ? decoder.readString() : null, // parentSub\n            readItemContent(decoder, info) // item content\n          )\n          */\n          refs[i] = struct;\n          clock += struct.length;\n        }\n      }\n    }\n    // console.log('time to read: ', performance.now() - start) // @todo remove\n  }\n  return clientRefs\n};\n\n/**\n * Resume computing structs generated by struct readers.\n *\n * While there is something to do, we integrate structs in this order\n * 1. top element on stack, if stack is not empty\n * 2. next element from current struct reader (if empty, use next struct reader)\n *\n * If struct causally depends on another struct (ref.missing), we put next reader of\n * `ref.id.client` on top of stack.\n *\n * At some point we find a struct that has no causal dependencies,\n * then we start emptying the stack.\n *\n * It is not possible to have circles: i.e. struct1 (from client1) depends on struct2 (from client2)\n * depends on struct3 (from client1). Therefore the max stack size is eqaul to `structReaders.length`.\n *\n * This method is implemented in a way so that we can resume computation if this update\n * causally depends on another update.\n *\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @param {Map<number, { i: number, refs: (GC | Item)[] }>} clientsStructRefs\n * @return { null | { update: Uint8Array, missing: Map<number,number> } }\n *\n * @private\n * @function\n */\nconst integrateStructs = (transaction, store, clientsStructRefs) => {\n  /**\n   * @type {Array<Item | GC>}\n   */\n  const stack = [];\n  // sort them so that we take the higher id first, in case of conflicts the lower id will probably not conflict with the id from the higher user.\n  let clientsStructRefsIds = Array.from(clientsStructRefs.keys()).sort((a, b) => a - b);\n  if (clientsStructRefsIds.length === 0) {\n    return null\n  }\n  const getNextStructTarget = () => {\n    if (clientsStructRefsIds.length === 0) {\n      return null\n    }\n    let nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */ (clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]));\n    while (nextStructsTarget.refs.length === nextStructsTarget.i) {\n      clientsStructRefsIds.pop();\n      if (clientsStructRefsIds.length > 0) {\n        nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */ (clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]));\n      } else {\n        return null\n      }\n    }\n    return nextStructsTarget\n  };\n  let curStructsTarget = getNextStructTarget();\n  if (curStructsTarget === null && stack.length === 0) {\n    return null\n  }\n\n  /**\n   * @type {StructStore}\n   */\n  const restStructs = new StructStore();\n  const missingSV = new Map();\n  /**\n   * @param {number} client\n   * @param {number} clock\n   */\n  const updateMissingSv = (client, clock) => {\n    const mclock = missingSV.get(client);\n    if (mclock == null || mclock > clock) {\n      missingSV.set(client, clock);\n    }\n  };\n  /**\n   * @type {GC|Item}\n   */\n  let stackHead = /** @type {any} */ (curStructsTarget).refs[/** @type {any} */ (curStructsTarget).i++];\n  // caching the state because it is used very often\n  const state = new Map();\n\n  const addStackToRestSS = () => {\n    for (const item of stack) {\n      const client = item.id.client;\n      const unapplicableItems = clientsStructRefs.get(client);\n      if (unapplicableItems) {\n        // decrement because we weren't able to apply previous operation\n        unapplicableItems.i--;\n        restStructs.clients.set(client, unapplicableItems.refs.slice(unapplicableItems.i));\n        clientsStructRefs.delete(client);\n        unapplicableItems.i = 0;\n        unapplicableItems.refs = [];\n      } else {\n        // item was the last item on clientsStructRefs and the field was already cleared. Add item to restStructs and continue\n        restStructs.clients.set(client, [item]);\n      }\n      // remove client from clientsStructRefsIds to prevent users from applying the same update again\n      clientsStructRefsIds = clientsStructRefsIds.filter(c => c !== client);\n    }\n    stack.length = 0;\n  };\n\n  // iterate over all struct readers until we are done\n  while (true) {\n    if (stackHead.constructor !== Skip) {\n      const localClock = map__namespace.setIfUndefined(state, stackHead.id.client, () => getState(store, stackHead.id.client));\n      const offset = localClock - stackHead.id.clock;\n      if (offset < 0) {\n        // update from the same client is missing\n        stack.push(stackHead);\n        updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);\n        // hid a dead wall, add all items from stack to restSS\n        addStackToRestSS();\n      } else {\n        const missing = stackHead.getMissing(transaction, store);\n        if (missing !== null) {\n          stack.push(stackHead);\n          // get the struct reader that has the missing struct\n          /**\n           * @type {{ refs: Array<GC|Item>, i: number }}\n           */\n          const structRefs = clientsStructRefs.get(/** @type {number} */ (missing)) || { refs: [], i: 0 };\n          if (structRefs.refs.length === structRefs.i) {\n            // This update message causally depends on another update message that doesn't exist yet\n            updateMissingSv(/** @type {number} */ (missing), getState(store, missing));\n            addStackToRestSS();\n          } else {\n            stackHead = structRefs.refs[structRefs.i++];\n            continue\n          }\n        } else if (offset === 0 || offset < stackHead.length) {\n          // all fine, apply the stackhead\n          stackHead.integrate(transaction, offset);\n          state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);\n        }\n      }\n    }\n    // iterate to next stackHead\n    if (stack.length > 0) {\n      stackHead = /** @type {GC|Item} */ (stack.pop());\n    } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {\n      stackHead = /** @type {GC|Item} */ (curStructsTarget.refs[curStructsTarget.i++]);\n    } else {\n      curStructsTarget = getNextStructTarget();\n      if (curStructsTarget === null) {\n        // we are done!\n        break\n      } else {\n        stackHead = /** @type {GC|Item} */ (curStructsTarget.refs[curStructsTarget.i++]);\n      }\n    }\n  }\n  if (restStructs.clients.size > 0) {\n    const encoder = new UpdateEncoderV2();\n    writeClientsStructs(encoder, restStructs, new Map());\n    // write empty deleteset\n    // writeDeleteSet(encoder, new DeleteSet())\n    encoding__namespace.writeVarUint(encoder.restEncoder, 0); // => no need for an extra function call, just write 0 deletes\n    return { missing: missingSV, update: encoder.toUint8Array() }\n  }\n  return null\n};\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Transaction} transaction\n *\n * @private\n * @function\n */\nconst writeStructsFromTransaction = (encoder, transaction) => writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState);\n\n/**\n * Read and apply a document update.\n *\n * This function has the same effect as `applyUpdate` but accepts an decoder.\n *\n * @param {decoding.Decoder} decoder\n * @param {Doc} ydoc\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n * @param {UpdateDecoderV1 | UpdateDecoderV2} [structDecoder]\n *\n * @function\n */\nconst readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder)) =>\n  transact(ydoc, transaction => {\n    // force that transaction.local is set to non-local\n    transaction.local = false;\n    let retry = false;\n    const doc = transaction.doc;\n    const store = doc.store;\n    // let start = performance.now()\n    const ss = readClientsStructRefs(structDecoder, doc);\n    // console.log('time to read structs: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    // console.log('time to merge: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    const restStructs = integrateStructs(transaction, store, ss);\n    const pending = store.pendingStructs;\n    if (pending) {\n      // check if we can apply something\n      for (const [client, clock] of pending.missing) {\n        if (clock < getState(store, client)) {\n          retry = true;\n          break\n        }\n      }\n      if (restStructs) {\n        // merge restStructs into store.pending\n        for (const [client, clock] of restStructs.missing) {\n          const mclock = pending.missing.get(client);\n          if (mclock == null || mclock > clock) {\n            pending.missing.set(client, clock);\n          }\n        }\n        pending.update = mergeUpdatesV2([pending.update, restStructs.update]);\n      }\n    } else {\n      store.pendingStructs = restStructs;\n    }\n    // console.log('time to integrate: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store);\n    if (store.pendingDs) {\n      // @todo we could make a lower-bound state-vector check as we do above\n      const pendingDSUpdate = new UpdateDecoderV2(decoding__namespace.createDecoder(store.pendingDs));\n      decoding__namespace.readVarUint(pendingDSUpdate.restDecoder); // read 0 structs, because we only encode deletes in pendingdsupdate\n      const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store);\n      if (dsRest && dsRest2) {\n        // case 1: ds1 != null && ds2 != null\n        store.pendingDs = mergeUpdatesV2([dsRest, dsRest2]);\n      } else {\n        // case 2: ds1 != null\n        // case 3: ds2 != null\n        // case 4: ds1 == null && ds2 == null\n        store.pendingDs = dsRest || dsRest2;\n      }\n    } else {\n      // Either dsRest == null && pendingDs == null OR dsRest != null\n      store.pendingDs = dsRest;\n    }\n    // console.log('time to cleanup: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n\n    // console.log('time to resume delete readers: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    if (retry) {\n      const update = /** @type {{update: Uint8Array}} */ (store.pendingStructs).update;\n      store.pendingStructs = null;\n      applyUpdateV2(transaction.doc, update);\n    }\n  }, transactionOrigin, false);\n\n/**\n * Read and apply a document update.\n *\n * This function has the same effect as `applyUpdate` but accepts an decoder.\n *\n * @param {decoding.Decoder} decoder\n * @param {Doc} ydoc\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n *\n * @function\n */\nconst readUpdate = (decoder, ydoc, transactionOrigin) => readUpdateV2(decoder, ydoc, transactionOrigin, new UpdateDecoderV1(decoder));\n\n/**\n * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.\n *\n * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.\n *\n * @param {Doc} ydoc\n * @param {Uint8Array} update\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n *\n * @function\n */\nconst applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2) => {\n  const decoder = decoding__namespace.createDecoder(update);\n  readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder));\n};\n\n/**\n * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.\n *\n * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.\n *\n * @param {Doc} ydoc\n * @param {Uint8Array} update\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n *\n * @function\n */\nconst applyUpdate = (ydoc, update, transactionOrigin) => applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1);\n\n/**\n * Write all the document as a single update message. If you specify the state of the remote client (`targetStateVector`) it will\n * only write the operations that are missing.\n *\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Doc} doc\n * @param {Map<number,number>} [targetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n *\n * @function\n */\nconst writeStateAsUpdate = (encoder, doc, targetStateVector = new Map()) => {\n  writeClientsStructs(encoder, doc.store, targetStateVector);\n  writeDeleteSet(encoder, createDeleteSetFromStructStore(doc.store));\n};\n\n/**\n * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will\n * only write the operations that are missing.\n *\n * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder\n *\n * @param {Doc} doc\n * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n * @param {UpdateEncoderV1 | UpdateEncoderV2} [encoder]\n * @return {Uint8Array}\n *\n * @function\n */\nconst encodeStateAsUpdateV2 = (doc, encodedTargetStateVector = new Uint8Array([0]), encoder = new UpdateEncoderV2()) => {\n  const targetStateVector = decodeStateVector(encodedTargetStateVector);\n  writeStateAsUpdate(encoder, doc, targetStateVector);\n  const updates = [encoder.toUint8Array()];\n  // also add the pending updates (if there are any)\n  // @todo support diffirent encoders\n  if (encoder.constructor === UpdateEncoderV2) {\n    if (doc.store.pendingDs) {\n      updates.push(doc.store.pendingDs);\n    }\n    if (doc.store.pendingStructs) {\n      updates.push(diffUpdateV2(doc.store.pendingStructs.update, encodedTargetStateVector));\n    }\n    if (updates.length > 1) {\n      return mergeUpdatesV2(updates)\n    }\n  }\n  return updates[0]\n};\n\n/**\n * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will\n * only write the operations that are missing.\n *\n * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder\n *\n * @param {Doc} doc\n * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n * @return {Uint8Array}\n *\n * @function\n */\nconst encodeStateAsUpdate = (doc, encodedTargetStateVector) => encodeStateAsUpdateV2(doc, encodedTargetStateVector, new UpdateEncoderV1());\n\n/**\n * Read state vector from Decoder and return as Map\n *\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */\nconst readStateVector = decoder => {\n  const ss = new Map();\n  const ssLength = decoding__namespace.readVarUint(decoder.restDecoder);\n  for (let i = 0; i < ssLength; i++) {\n    const client = decoding__namespace.readVarUint(decoder.restDecoder);\n    const clock = decoding__namespace.readVarUint(decoder.restDecoder);\n    ss.set(client, clock);\n  }\n  return ss\n};\n\n/**\n * Read decodedState and return State as Map.\n *\n * @param {Uint8Array} decodedState\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */\n// export const decodeStateVectorV2 = decodedState => readStateVector(new DSDecoderV2(decoding.createDecoder(decodedState)))\n\n/**\n * Read decodedState and return State as Map.\n *\n * @param {Uint8Array} decodedState\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */\nconst decodeStateVector = decodedState => readStateVector(new DSDecoderV1(decoding__namespace.createDecoder(decodedState)));\n\n/**\n * @param {DSEncoderV1 | DSEncoderV2} encoder\n * @param {Map<number,number>} sv\n * @function\n */\nconst writeStateVector = (encoder, sv) => {\n  encoding__namespace.writeVarUint(encoder.restEncoder, sv.size);\n  sv.forEach((clock, client) => {\n    encoding__namespace.writeVarUint(encoder.restEncoder, client); // @todo use a special client decoder that is based on mapping\n    encoding__namespace.writeVarUint(encoder.restEncoder, clock);\n  });\n  return encoder\n};\n\n/**\n * @param {DSEncoderV1 | DSEncoderV2} encoder\n * @param {Doc} doc\n *\n * @function\n */\nconst writeDocumentStateVector = (encoder, doc) => writeStateVector(encoder, getStateVector(doc.store));\n\n/**\n * Encode State as Uint8Array.\n *\n * @param {Doc|Map<number,number>} doc\n * @param {DSEncoderV1 | DSEncoderV2} [encoder]\n * @return {Uint8Array}\n *\n * @function\n */\nconst encodeStateVectorV2 = (doc, encoder = new DSEncoderV2()) => {\n  if (doc instanceof Map) {\n    writeStateVector(encoder, doc);\n  } else {\n    writeDocumentStateVector(encoder, doc);\n  }\n  return encoder.toUint8Array()\n};\n\n/**\n * Encode State as Uint8Array.\n *\n * @param {Doc|Map<number,number>} doc\n * @return {Uint8Array}\n *\n * @function\n */\nconst encodeStateVector = doc => encodeStateVectorV2(doc, new DSEncoderV1());\n\n/**\n * General event handler implementation.\n *\n * @template ARG0, ARG1\n *\n * @private\n */\nclass EventHandler {\n  constructor () {\n    /**\n     * @type {Array<function(ARG0, ARG1):void>}\n     */\n    this.l = [];\n  }\n}\n\n/**\n * @template ARG0,ARG1\n * @returns {EventHandler<ARG0,ARG1>}\n *\n * @private\n * @function\n */\nconst createEventHandler = () => new EventHandler();\n\n/**\n * Adds an event listener that is called when\n * {@link EventHandler#callEventListeners} is called.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {function(ARG0,ARG1):void} f The event handler.\n *\n * @private\n * @function\n */\nconst addEventHandlerListener = (eventHandler, f) =>\n  eventHandler.l.push(f);\n\n/**\n * Removes an event listener.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {function(ARG0,ARG1):void} f The event handler that was added with\n *                     {@link EventHandler#addEventListener}\n *\n * @private\n * @function\n */\nconst removeEventHandlerListener = (eventHandler, f) => {\n  const l = eventHandler.l;\n  const len = l.length;\n  eventHandler.l = l.filter(g => f !== g);\n  if (len === eventHandler.l.length) {\n    console.error('[yjs] Tried to remove event handler that doesn\\'t exist.');\n  }\n};\n\n/**\n * Call all event listeners that were added via\n * {@link EventHandler#addEventListener}.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {ARG0} arg0\n * @param {ARG1} arg1\n *\n * @private\n * @function\n */\nconst callEventHandlerListeners = (eventHandler, arg0, arg1) =>\n  f__namespace.callAll(eventHandler.l, [arg0, arg1]);\n\nclass ID {\n  /**\n   * @param {number} client client id\n   * @param {number} clock unique per client id, continuous number\n   */\n  constructor (client, clock) {\n    /**\n     * Client id\n     * @type {number}\n     */\n    this.client = client;\n    /**\n     * unique per client id, continuous number\n     * @type {number}\n     */\n    this.clock = clock;\n  }\n}\n\n/**\n * @param {ID | null} a\n * @param {ID | null} b\n * @return {boolean}\n *\n * @function\n */\nconst compareIDs = (a, b) => a === b || (a !== null && b !== null && a.client === b.client && a.clock === b.clock);\n\n/**\n * @param {number} client\n * @param {number} clock\n *\n * @private\n * @function\n */\nconst createID = (client, clock) => new ID(client, clock);\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {ID} id\n *\n * @private\n * @function\n */\nconst writeID = (encoder, id) => {\n  encoding__namespace.writeVarUint(encoder, id.client);\n  encoding__namespace.writeVarUint(encoder, id.clock);\n};\n\n/**\n * Read ID.\n * * If first varUint read is 0xFFFFFF a RootID is returned.\n * * Otherwise an ID is returned\n *\n * @param {decoding.Decoder} decoder\n * @return {ID}\n *\n * @private\n * @function\n */\nconst readID = decoder =>\n  createID(decoding__namespace.readVarUint(decoder), decoding__namespace.readVarUint(decoder));\n\n/**\n * The top types are mapped from y.share.get(keyname) => type.\n * `type` does not store any information about the `keyname`.\n * This function finds the correct `keyname` for `type` and throws otherwise.\n *\n * @param {AbstractType<any>} type\n * @return {string}\n *\n * @private\n * @function\n */\nconst findRootTypeKey = type => {\n  // @ts-ignore _y must be defined, otherwise unexpected case\n  for (const [key, value] of type.doc.share.entries()) {\n    if (value === type) {\n      return key\n    }\n  }\n  throw error__namespace.unexpectedCase()\n};\n\n/**\n * Check if `parent` is a parent of `child`.\n *\n * @param {AbstractType<any>} parent\n * @param {Item|null} child\n * @return {Boolean} Whether `parent` is a parent of `child`.\n *\n * @private\n * @function\n */\nconst isParentOf = (parent, child) => {\n  while (child !== null) {\n    if (child.parent === parent) {\n      return true\n    }\n    child = /** @type {AbstractType<any>} */ (child.parent)._item;\n  }\n  return false\n};\n\n/**\n * Convenient helper to log type information.\n *\n * Do not use in productive systems as the output can be immense!\n *\n * @param {AbstractType<any>} type\n */\nconst logType = type => {\n  const res = [];\n  let n = type._start;\n  while (n) {\n    res.push(n);\n    n = n.right;\n  }\n  console.log('Children: ', res);\n  console.log('Children content: ', res.filter(m => !m.deleted).map(m => m.content));\n};\n\nclass PermanentUserData {\n  /**\n   * @param {Doc} doc\n   * @param {YMap<any>} [storeType]\n   */\n  constructor (doc, storeType = doc.getMap('users')) {\n    /**\n     * @type {Map<string,DeleteSet>}\n     */\n    const dss = new Map();\n    this.yusers = storeType;\n    this.doc = doc;\n    /**\n     * Maps from clientid to userDescription\n     *\n     * @type {Map<number,string>}\n     */\n    this.clients = new Map();\n    this.dss = dss;\n    /**\n     * @param {YMap<any>} user\n     * @param {string} userDescription\n     */\n    const initUser = (user, userDescription) => {\n      /**\n       * @type {YArray<Uint8Array>}\n       */\n      const ds = user.get('ds');\n      const ids = user.get('ids');\n      const addClientId = /** @param {number} clientid */ clientid => this.clients.set(clientid, userDescription);\n      ds.observe(/** @param {YArrayEvent<any>} event */ event => {\n        event.changes.added.forEach(item => {\n          item.content.getContent().forEach(encodedDs => {\n            if (encodedDs instanceof Uint8Array) {\n              this.dss.set(userDescription, mergeDeleteSets([this.dss.get(userDescription) || createDeleteSet(), readDeleteSet(new DSDecoderV1(decoding__namespace.createDecoder(encodedDs)))]));\n            }\n          });\n        });\n      });\n      this.dss.set(userDescription, mergeDeleteSets(ds.map(encodedDs => readDeleteSet(new DSDecoderV1(decoding__namespace.createDecoder(encodedDs))))));\n      ids.observe(/** @param {YArrayEvent<any>} event */ event =>\n        event.changes.added.forEach(item => item.content.getContent().forEach(addClientId))\n      );\n      ids.forEach(addClientId);\n    };\n    // observe users\n    storeType.observe(event => {\n      event.keysChanged.forEach(userDescription =>\n        initUser(storeType.get(userDescription), userDescription)\n      );\n    });\n    // add intial data\n    storeType.forEach(initUser);\n  }\n\n  /**\n   * @param {Doc} doc\n   * @param {number} clientid\n   * @param {string} userDescription\n   * @param {Object} [conf]\n   * @param {function(Transaction, DeleteSet):boolean} [conf.filter]\n   */\n  setUserMapping (doc, clientid, userDescription, { filter = () => true } = {}) {\n    const users = this.yusers;\n    let user = users.get(userDescription);\n    if (!user) {\n      user = new YMap();\n      user.set('ids', new YArray());\n      user.set('ds', new YArray());\n      users.set(userDescription, user);\n    }\n    user.get('ids').push([clientid]);\n    users.observe(event => {\n      setTimeout(() => {\n        const userOverwrite = users.get(userDescription);\n        if (userOverwrite !== user) {\n          // user was overwritten, port all data over to the next user object\n          // @todo Experiment with Y.Sets here\n          user = userOverwrite;\n          // @todo iterate over old type\n          this.clients.forEach((_userDescription, clientid) => {\n            if (userDescription === _userDescription) {\n              user.get('ids').push([clientid]);\n            }\n          });\n          const encoder = new DSEncoderV1();\n          const ds = this.dss.get(userDescription);\n          if (ds) {\n            writeDeleteSet(encoder, ds);\n            user.get('ds').push([encoder.toUint8Array()]);\n          }\n        }\n      }, 0);\n    });\n    doc.on('afterTransaction', /** @param {Transaction} transaction */ transaction => {\n      setTimeout(() => {\n        const yds = user.get('ds');\n        const ds = transaction.deleteSet;\n        if (transaction.local && ds.clients.size > 0 && filter(transaction, ds)) {\n          const encoder = new DSEncoderV1();\n          writeDeleteSet(encoder, ds);\n          yds.push([encoder.toUint8Array()]);\n        }\n      });\n    });\n  }\n\n  /**\n   * @param {number} clientid\n   * @return {any}\n   */\n  getUserByClientId (clientid) {\n    return this.clients.get(clientid) || null\n  }\n\n  /**\n   * @param {ID} id\n   * @return {string | null}\n   */\n  getUserByDeletedId (id) {\n    for (const [userDescription, ds] of this.dss.entries()) {\n      if (isDeleted(ds, id)) {\n        return userDescription\n      }\n    }\n    return null\n  }\n}\n\n/**\n * A relative position is based on the Yjs model and is not affected by document changes.\n * E.g. If you place a relative position before a certain character, it will always point to this character.\n * If you place a relative position at the end of a type, it will always point to the end of the type.\n *\n * A numeric position is often unsuited for user selections, because it does not change when content is inserted\n * before or after.\n *\n * ```Insert(0, 'x')('a|bc') = 'xa|bc'``` Where | is the relative position.\n *\n * One of the properties must be defined.\n *\n * @example\n *   // Current cursor position is at position 10\n *   const relativePosition = createRelativePositionFromIndex(yText, 10)\n *   // modify yText\n *   yText.insert(0, 'abc')\n *   yText.delete(3, 10)\n *   // Compute the cursor position\n *   const absolutePosition = createAbsolutePositionFromRelativePosition(y, relativePosition)\n *   absolutePosition.type === yText // => true\n *   console.log('cursor location is ' + absolutePosition.index) // => cursor location is 3\n *\n */\nclass RelativePosition {\n  /**\n   * @param {ID|null} type\n   * @param {string|null} tname\n   * @param {ID|null} item\n   * @param {number} assoc\n   */\n  constructor (type, tname, item, assoc = 0) {\n    /**\n     * @type {ID|null}\n     */\n    this.type = type;\n    /**\n     * @type {string|null}\n     */\n    this.tname = tname;\n    /**\n     * @type {ID | null}\n     */\n    this.item = item;\n    /**\n     * A relative position is associated to a specific character. By default\n     * assoc >= 0, the relative position is associated to the character\n     * after the meant position.\n     * I.e. position 1 in 'ab' is associated to character 'b'.\n     *\n     * If assoc < 0, then the relative position is associated to the caharacter\n     * before the meant position.\n     *\n     * @type {number}\n     */\n    this.assoc = assoc;\n  }\n}\n\n/**\n * @param {RelativePosition} rpos\n * @return {any}\n */\nconst relativePositionToJSON = rpos => {\n  const json = {};\n  if (rpos.type) {\n    json.type = rpos.type;\n  }\n  if (rpos.tname) {\n    json.tname = rpos.tname;\n  }\n  if (rpos.item) {\n    json.item = rpos.item;\n  }\n  if (rpos.assoc != null) {\n    json.assoc = rpos.assoc;\n  }\n  return json\n};\n\n/**\n * @param {any} json\n * @return {RelativePosition}\n *\n * @function\n */\nconst createRelativePositionFromJSON = json => new RelativePosition(json.type == null ? null : createID(json.type.client, json.type.clock), json.tname || null, json.item == null ? null : createID(json.item.client, json.item.clock), json.assoc == null ? 0 : json.assoc);\n\nclass AbsolutePosition {\n  /**\n   * @param {AbstractType<any>} type\n   * @param {number} index\n   * @param {number} [assoc]\n   */\n  constructor (type, index, assoc = 0) {\n    /**\n     * @type {AbstractType<any>}\n     */\n    this.type = type;\n    /**\n     * @type {number}\n     */\n    this.index = index;\n    this.assoc = assoc;\n  }\n}\n\n/**\n * @param {AbstractType<any>} type\n * @param {number} index\n * @param {number} [assoc]\n *\n * @function\n */\nconst createAbsolutePosition = (type, index, assoc = 0) => new AbsolutePosition(type, index, assoc);\n\n/**\n * @param {AbstractType<any>} type\n * @param {ID|null} item\n * @param {number} [assoc]\n *\n * @function\n */\nconst createRelativePosition = (type, item, assoc) => {\n  let typeid = null;\n  let tname = null;\n  if (type._item === null) {\n    tname = findRootTypeKey(type);\n  } else {\n    typeid = createID(type._item.id.client, type._item.id.clock);\n  }\n  return new RelativePosition(typeid, tname, item, assoc)\n};\n\n/**\n * Create a relativePosition based on a absolute position.\n *\n * @param {AbstractType<any>} type The base type (e.g. YText or YArray).\n * @param {number} index The absolute position.\n * @param {number} [assoc]\n * @return {RelativePosition}\n *\n * @function\n */\nconst createRelativePositionFromTypeIndex = (type, index, assoc = 0) => {\n  let t = type._start;\n  if (assoc < 0) {\n    // associated to the left character or the beginning of a type, increment index if possible.\n    if (index === 0) {\n      return createRelativePosition(type, null, assoc)\n    }\n    index--;\n  }\n  while (t !== null) {\n    if (!t.deleted && t.countable) {\n      if (t.length > index) {\n        // case 1: found position somewhere in the linked list\n        return createRelativePosition(type, createID(t.id.client, t.id.clock + index), assoc)\n      }\n      index -= t.length;\n    }\n    if (t.right === null && assoc < 0) {\n      // left-associated position, return last available id\n      return createRelativePosition(type, t.lastId, assoc)\n    }\n    t = t.right;\n  }\n  return createRelativePosition(type, null, assoc)\n};\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {RelativePosition} rpos\n *\n * @function\n */\nconst writeRelativePosition = (encoder, rpos) => {\n  const { type, tname, item, assoc } = rpos;\n  if (item !== null) {\n    encoding__namespace.writeVarUint(encoder, 0);\n    writeID(encoder, item);\n  } else if (tname !== null) {\n    // case 2: found position at the end of the list and type is stored in y.share\n    encoding__namespace.writeUint8(encoder, 1);\n    encoding__namespace.writeVarString(encoder, tname);\n  } else if (type !== null) {\n    // case 3: found position at the end of the list and type is attached to an item\n    encoding__namespace.writeUint8(encoder, 2);\n    writeID(encoder, type);\n  } else {\n    throw error__namespace.unexpectedCase()\n  }\n  encoding__namespace.writeVarInt(encoder, assoc);\n  return encoder\n};\n\n/**\n * @param {RelativePosition} rpos\n * @return {Uint8Array}\n */\nconst encodeRelativePosition = rpos => {\n  const encoder = encoding__namespace.createEncoder();\n  writeRelativePosition(encoder, rpos);\n  return encoding__namespace.toUint8Array(encoder)\n};\n\n/**\n * @param {decoding.Decoder} decoder\n * @return {RelativePosition}\n *\n * @function\n */\nconst readRelativePosition = decoder => {\n  let type = null;\n  let tname = null;\n  let itemID = null;\n  switch (decoding__namespace.readVarUint(decoder)) {\n    case 0:\n      // case 1: found position somewhere in the linked list\n      itemID = readID(decoder);\n      break\n    case 1:\n      // case 2: found position at the end of the list and type is stored in y.share\n      tname = decoding__namespace.readVarString(decoder);\n      break\n    case 2: {\n      // case 3: found position at the end of the list and type is attached to an item\n      type = readID(decoder);\n    }\n  }\n  const assoc = decoding__namespace.hasContent(decoder) ? decoding__namespace.readVarInt(decoder) : 0;\n  return new RelativePosition(type, tname, itemID, assoc)\n};\n\n/**\n * @param {Uint8Array} uint8Array\n * @return {RelativePosition}\n */\nconst decodeRelativePosition = uint8Array => readRelativePosition(decoding__namespace.createDecoder(uint8Array));\n\n/**\n * @param {RelativePosition} rpos\n * @param {Doc} doc\n * @return {AbsolutePosition|null}\n *\n * @function\n */\nconst createAbsolutePositionFromRelativePosition = (rpos, doc) => {\n  const store = doc.store;\n  const rightID = rpos.item;\n  const typeID = rpos.type;\n  const tname = rpos.tname;\n  const assoc = rpos.assoc;\n  let type = null;\n  let index = 0;\n  if (rightID !== null) {\n    if (getState(store, rightID.client) <= rightID.clock) {\n      return null\n    }\n    const res = followRedone(store, rightID);\n    const right = res.item;\n    if (!(right instanceof Item)) {\n      return null\n    }\n    type = /** @type {AbstractType<any>} */ (right.parent);\n    if (type._item === null || !type._item.deleted) {\n      index = (right.deleted || !right.countable) ? 0 : (res.diff + (assoc >= 0 ? 0 : 1)); // adjust position based on left association if necessary\n      let n = right.left;\n      while (n !== null) {\n        if (!n.deleted && n.countable) {\n          index += n.length;\n        }\n        n = n.left;\n      }\n    }\n  } else {\n    if (tname !== null) {\n      type = doc.get(tname);\n    } else if (typeID !== null) {\n      if (getState(store, typeID.client) <= typeID.clock) {\n        // type does not exist yet\n        return null\n      }\n      const { item } = followRedone(store, typeID);\n      if (item instanceof Item && item.content instanceof ContentType) {\n        type = item.content.type;\n      } else {\n        // struct is garbage collected\n        return null\n      }\n    } else {\n      throw error__namespace.unexpectedCase()\n    }\n    if (assoc >= 0) {\n      index = type._length;\n    } else {\n      index = 0;\n    }\n  }\n  return createAbsolutePosition(type, index, rpos.assoc)\n};\n\n/**\n * @param {RelativePosition|null} a\n * @param {RelativePosition|null} b\n * @return {boolean}\n *\n * @function\n */\nconst compareRelativePositions = (a, b) => a === b || (\n  a !== null && b !== null && a.tname === b.tname && compareIDs(a.item, b.item) && compareIDs(a.type, b.type) && a.assoc === b.assoc\n);\n\nclass Snapshot {\n  /**\n   * @param {DeleteSet} ds\n   * @param {Map<number,number>} sv state map\n   */\n  constructor (ds, sv) {\n    /**\n     * @type {DeleteSet}\n     */\n    this.ds = ds;\n    /**\n     * State Map\n     * @type {Map<number,number>}\n     */\n    this.sv = sv;\n  }\n}\n\n/**\n * @param {Snapshot} snap1\n * @param {Snapshot} snap2\n * @return {boolean}\n */\nconst equalSnapshots = (snap1, snap2) => {\n  const ds1 = snap1.ds.clients;\n  const ds2 = snap2.ds.clients;\n  const sv1 = snap1.sv;\n  const sv2 = snap2.sv;\n  if (sv1.size !== sv2.size || ds1.size !== ds2.size) {\n    return false\n  }\n  for (const [key, value] of sv1.entries()) {\n    if (sv2.get(key) !== value) {\n      return false\n    }\n  }\n  for (const [client, dsitems1] of ds1.entries()) {\n    const dsitems2 = ds2.get(client) || [];\n    if (dsitems1.length !== dsitems2.length) {\n      return false\n    }\n    for (let i = 0; i < dsitems1.length; i++) {\n      const dsitem1 = dsitems1[i];\n      const dsitem2 = dsitems2[i];\n      if (dsitem1.clock !== dsitem2.clock || dsitem1.len !== dsitem2.len) {\n        return false\n      }\n    }\n  }\n  return true\n};\n\n/**\n * @param {Snapshot} snapshot\n * @param {DSEncoderV1 | DSEncoderV2} [encoder]\n * @return {Uint8Array}\n */\nconst encodeSnapshotV2 = (snapshot, encoder = new DSEncoderV2()) => {\n  writeDeleteSet(encoder, snapshot.ds);\n  writeStateVector(encoder, snapshot.sv);\n  return encoder.toUint8Array()\n};\n\n/**\n * @param {Snapshot} snapshot\n * @return {Uint8Array}\n */\nconst encodeSnapshot = snapshot => encodeSnapshotV2(snapshot, new DSEncoderV1());\n\n/**\n * @param {Uint8Array} buf\n * @param {DSDecoderV1 | DSDecoderV2} [decoder]\n * @return {Snapshot}\n */\nconst decodeSnapshotV2 = (buf, decoder = new DSDecoderV2(decoding__namespace.createDecoder(buf))) => {\n  return new Snapshot(readDeleteSet(decoder), readStateVector(decoder))\n};\n\n/**\n * @param {Uint8Array} buf\n * @return {Snapshot}\n */\nconst decodeSnapshot = buf => decodeSnapshotV2(buf, new DSDecoderV1(decoding__namespace.createDecoder(buf)));\n\n/**\n * @param {DeleteSet} ds\n * @param {Map<number,number>} sm\n * @return {Snapshot}\n */\nconst createSnapshot = (ds, sm) => new Snapshot(ds, sm);\n\nconst emptySnapshot = createSnapshot(createDeleteSet(), new Map());\n\n/**\n * @param {Doc} doc\n * @return {Snapshot}\n */\nconst snapshot = doc => createSnapshot(createDeleteSetFromStructStore(doc.store), getStateVector(doc.store));\n\n/**\n * @param {Item} item\n * @param {Snapshot|undefined} snapshot\n *\n * @protected\n * @function\n */\nconst isVisible = (item, snapshot) => snapshot === undefined ? !item.deleted : (\n  snapshot.sv.has(item.id.client) && (snapshot.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot.ds, item.id)\n);\n\n/**\n * @param {Transaction} transaction\n * @param {Snapshot} snapshot\n */\nconst splitSnapshotAffectedStructs = (transaction, snapshot) => {\n  const meta = map__namespace.setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, set__namespace.create);\n  const store = transaction.doc.store;\n  // check if we already split for this snapshot\n  if (!meta.has(snapshot)) {\n    snapshot.sv.forEach((clock, client) => {\n      if (clock < getState(store, client)) {\n        getItemCleanStart(transaction, createID(client, clock));\n      }\n    });\n    iterateDeletedStructs(transaction, snapshot.ds, item => {});\n    meta.add(snapshot);\n  }\n};\n\n/**\n * @param {Doc} originDoc\n * @param {Snapshot} snapshot\n * @param {Doc} [newDoc] Optionally, you may define the Yjs document that receives the data from originDoc\n * @return {Doc}\n */\nconst createDocFromSnapshot = (originDoc, snapshot, newDoc = new Doc()) => {\n  if (originDoc.gc) {\n    // we should not try to restore a GC-ed document, because some of the restored items might have their content deleted\n    throw new Error('originDoc must not be garbage collected')\n  }\n  const { sv, ds } = snapshot;\n\n  const encoder = new UpdateEncoderV2();\n  originDoc.transact(transaction => {\n    let size = 0;\n    sv.forEach(clock => {\n      if (clock > 0) {\n        size++;\n      }\n    });\n    encoding__namespace.writeVarUint(encoder.restEncoder, size);\n    // splitting the structs before writing them to the encoder\n    for (const [client, clock] of sv) {\n      if (clock === 0) {\n        continue\n      }\n      if (clock < getState(originDoc.store, client)) {\n        getItemCleanStart(transaction, createID(client, clock));\n      }\n      const structs = originDoc.store.clients.get(client) || [];\n      const lastStructIndex = findIndexSS(structs, clock - 1);\n      // write # encoded structs\n      encoding__namespace.writeVarUint(encoder.restEncoder, lastStructIndex + 1);\n      encoder.writeClient(client);\n      // first clock written is 0\n      encoding__namespace.writeVarUint(encoder.restEncoder, 0);\n      for (let i = 0; i <= lastStructIndex; i++) {\n        structs[i].write(encoder, 0);\n      }\n    }\n    writeDeleteSet(encoder, ds);\n  });\n\n  applyUpdateV2(newDoc, encoder.toUint8Array(), 'snapshot');\n  return newDoc\n};\n\nclass StructStore {\n  constructor () {\n    /**\n     * @type {Map<number,Array<GC|Item>>}\n     */\n    this.clients = new Map();\n    /**\n     * @type {null | { missing: Map<number, number>, update: Uint8Array }}\n     */\n    this.pendingStructs = null;\n    /**\n     * @type {null | Uint8Array}\n     */\n    this.pendingDs = null;\n  }\n}\n\n/**\n * Return the states as a Map<client,clock>.\n * Note that clock refers to the next expected clock id.\n *\n * @param {StructStore} store\n * @return {Map<number,number>}\n *\n * @public\n * @function\n */\nconst getStateVector = store => {\n  const sm = new Map();\n  store.clients.forEach((structs, client) => {\n    const struct = structs[structs.length - 1];\n    sm.set(client, struct.id.clock + struct.length);\n  });\n  return sm\n};\n\n/**\n * @param {StructStore} store\n * @param {number} client\n * @return {number}\n *\n * @public\n * @function\n */\nconst getState = (store, client) => {\n  const structs = store.clients.get(client);\n  if (structs === undefined) {\n    return 0\n  }\n  const lastStruct = structs[structs.length - 1];\n  return lastStruct.id.clock + lastStruct.length\n};\n\n/**\n * @param {StructStore} store\n * @param {GC|Item} struct\n *\n * @private\n * @function\n */\nconst addStruct = (store, struct) => {\n  let structs = store.clients.get(struct.id.client);\n  if (structs === undefined) {\n    structs = [];\n    store.clients.set(struct.id.client, structs);\n  } else {\n    const lastStruct = structs[structs.length - 1];\n    if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {\n      throw error__namespace.unexpectedCase()\n    }\n  }\n  structs.push(struct);\n};\n\n/**\n * Perform a binary search on a sorted array\n * @param {Array<Item|GC>} structs\n * @param {number} clock\n * @return {number}\n *\n * @private\n * @function\n */\nconst findIndexSS = (structs, clock) => {\n  let left = 0;\n  let right = structs.length - 1;\n  let mid = structs[right];\n  let midclock = mid.id.clock;\n  if (midclock === clock) {\n    return right\n  }\n  // @todo does it even make sense to pivot the search?\n  // If a good split misses, it might actually increase the time to find the correct item.\n  // Currently, the only advantage is that search with pivoting might find the item on the first try.\n  let midindex = math__namespace.floor((clock / (midclock + mid.length - 1)) * right); // pivoting the search\n  while (left <= right) {\n    mid = structs[midindex];\n    midclock = mid.id.clock;\n    if (midclock <= clock) {\n      if (clock < midclock + mid.length) {\n        return midindex\n      }\n      left = midindex + 1;\n    } else {\n      right = midindex - 1;\n    }\n    midindex = math__namespace.floor((left + right) / 2);\n  }\n  // Always check state before looking for a struct in StructStore\n  // Therefore the case of not finding a struct is unexpected\n  throw error__namespace.unexpectedCase()\n};\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {StructStore} store\n * @param {ID} id\n * @return {GC|Item}\n *\n * @private\n * @function\n */\nconst find = (store, id) => {\n  /**\n   * @type {Array<GC|Item>}\n   */\n  // @ts-ignore\n  const structs = store.clients.get(id.client);\n  return structs[findIndexSS(structs, id.clock)]\n};\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n * @private\n * @function\n */\nconst getItem = /** @type {function(StructStore,ID):Item} */ (find);\n\n/**\n * @param {Transaction} transaction\n * @param {Array<Item|GC>} structs\n * @param {number} clock\n */\nconst findIndexCleanStart = (transaction, structs, clock) => {\n  const index = findIndexSS(structs, clock);\n  const struct = structs[index];\n  if (struct.id.clock < clock && struct instanceof Item) {\n    structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));\n    return index + 1\n  }\n  return index\n};\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {Transaction} transaction\n * @param {ID} id\n * @return {Item}\n *\n * @private\n * @function\n */\nconst getItemCleanStart = (transaction, id) => {\n  const structs = /** @type {Array<Item>} */ (transaction.doc.store.clients.get(id.client));\n  return structs[findIndexCleanStart(transaction, structs, id.clock)]\n};\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @param {ID} id\n * @return {Item}\n *\n * @private\n * @function\n */\nconst getItemCleanEnd = (transaction, store, id) => {\n  /**\n   * @type {Array<Item>}\n   */\n  // @ts-ignore\n  const structs = store.clients.get(id.client);\n  const index = findIndexSS(structs, id.clock);\n  const struct = structs[index];\n  if (id.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {\n    structs.splice(index + 1, 0, splitItem(transaction, struct, id.clock - struct.id.clock + 1));\n  }\n  return struct\n};\n\n/**\n * Replace `item` with `newitem` in store\n * @param {StructStore} store\n * @param {GC|Item} struct\n * @param {GC|Item} newStruct\n *\n * @private\n * @function\n */\nconst replaceStruct = (store, struct, newStruct) => {\n  const structs = /** @type {Array<GC|Item>} */ (store.clients.get(struct.id.client));\n  structs[findIndexSS(structs, struct.id.clock)] = newStruct;\n};\n\n/**\n * Iterate over a range of structs\n *\n * @param {Transaction} transaction\n * @param {Array<Item|GC>} structs\n * @param {number} clockStart Inclusive start\n * @param {number} len\n * @param {function(GC|Item):void} f\n *\n * @function\n */\nconst iterateStructs = (transaction, structs, clockStart, len, f) => {\n  if (len === 0) {\n    return\n  }\n  const clockEnd = clockStart + len;\n  let index = findIndexCleanStart(transaction, structs, clockStart);\n  let struct;\n  do {\n    struct = structs[index++];\n    if (clockEnd < struct.id.clock + struct.length) {\n      findIndexCleanStart(transaction, structs, clockEnd);\n    }\n    f(struct);\n  } while (index < structs.length && structs[index].id.clock < clockEnd)\n};\n\n/**\n * A transaction is created for every change on the Yjs model. It is possible\n * to bundle changes on the Yjs model in a single transaction to\n * minimize the number on messages sent and the number of observer calls.\n * If possible the user of this library should bundle as many changes as\n * possible. Here is an example to illustrate the advantages of bundling:\n *\n * @example\n * const map = y.define('map', YMap)\n * // Log content when change is triggered\n * map.observe(() => {\n *   console.log('change triggered')\n * })\n * // Each change on the map type triggers a log message:\n * map.set('a', 0) // => \"change triggered\"\n * map.set('b', 0) // => \"change triggered\"\n * // When put in a transaction, it will trigger the log after the transaction:\n * y.transact(() => {\n *   map.set('a', 1)\n *   map.set('b', 1)\n * }) // => \"change triggered\"\n *\n * @public\n */\nclass Transaction {\n  /**\n   * @param {Doc} doc\n   * @param {any} origin\n   * @param {boolean} local\n   */\n  constructor (doc, origin, local) {\n    /**\n     * The Yjs instance.\n     * @type {Doc}\n     */\n    this.doc = doc;\n    /**\n     * Describes the set of deleted items by ids\n     * @type {DeleteSet}\n     */\n    this.deleteSet = new DeleteSet();\n    /**\n     * Holds the state before the transaction started.\n     * @type {Map<Number,Number>}\n     */\n    this.beforeState = getStateVector(doc.store);\n    /**\n     * Holds the state after the transaction.\n     * @type {Map<Number,Number>}\n     */\n    this.afterState = new Map();\n    /**\n     * All types that were directly modified (property added or child\n     * inserted/deleted). New types are not included in this Set.\n     * Maps from type to parentSubs (`item.parentSub = null` for YArray)\n     * @type {Map<AbstractType<YEvent>,Set<String|null>>}\n     */\n    this.changed = new Map();\n    /**\n     * Stores the events for the types that observe also child elements.\n     * It is mainly used by `observeDeep`.\n     * @type {Map<AbstractType<YEvent>,Array<YEvent>>}\n     */\n    this.changedParentTypes = new Map();\n    /**\n     * @type {Array<AbstractStruct>}\n     */\n    this._mergeStructs = [];\n    /**\n     * @type {any}\n     */\n    this.origin = origin;\n    /**\n     * Stores meta information on the transaction\n     * @type {Map<any,any>}\n     */\n    this.meta = new Map();\n    /**\n     * Whether this change originates from this doc.\n     * @type {boolean}\n     */\n    this.local = local;\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocsAdded = new Set();\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocsRemoved = new Set();\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocsLoaded = new Set();\n  }\n}\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Transaction} transaction\n * @return {boolean} Whether data was written.\n */\nconst writeUpdateMessageFromTransaction = (encoder, transaction) => {\n  if (transaction.deleteSet.clients.size === 0 && !map__namespace.any(transaction.afterState, (clock, client) => transaction.beforeState.get(client) !== clock)) {\n    return false\n  }\n  sortAndMergeDeleteSet(transaction.deleteSet);\n  writeStructsFromTransaction(encoder, transaction);\n  writeDeleteSet(encoder, transaction.deleteSet);\n  return true\n};\n\n/**\n * If `type.parent` was added in current transaction, `type` technically\n * did not change, it was just added and we should not fire events for `type`.\n *\n * @param {Transaction} transaction\n * @param {AbstractType<YEvent>} type\n * @param {string|null} parentSub\n */\nconst addChangedTypeToTransaction = (transaction, type, parentSub) => {\n  const item = type._item;\n  if (item === null || (item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted)) {\n    map__namespace.setIfUndefined(transaction.changed, type, set__namespace.create).add(parentSub);\n  }\n};\n\n/**\n * @param {Array<AbstractStruct>} structs\n * @param {number} pos\n */\nconst tryToMergeWithLeft = (structs, pos) => {\n  const left = structs[pos - 1];\n  const right = structs[pos];\n  if (left.deleted === right.deleted && left.constructor === right.constructor) {\n    if (left.mergeWith(right)) {\n      structs.splice(pos, 1);\n      if (right instanceof Item && right.parentSub !== null && /** @type {AbstractType<any>} */ (right.parent)._map.get(right.parentSub) === right) {\n        /** @type {AbstractType<any>} */ (right.parent)._map.set(right.parentSub, /** @type {Item} */ (left));\n      }\n    }\n  }\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {StructStore} store\n * @param {function(Item):boolean} gcFilter\n */\nconst tryGcDeleteSet = (ds, store, gcFilter) => {\n  for (const [client, deleteItems] of ds.clients.entries()) {\n    const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));\n    for (let di = deleteItems.length - 1; di >= 0; di--) {\n      const deleteItem = deleteItems[di];\n      const endDeleteItemClock = deleteItem.clock + deleteItem.len;\n      for (\n        let si = findIndexSS(structs, deleteItem.clock), struct = structs[si];\n        si < structs.length && struct.id.clock < endDeleteItemClock;\n        struct = structs[++si]\n      ) {\n        const struct = structs[si];\n        if (deleteItem.clock + deleteItem.len <= struct.id.clock) {\n          break\n        }\n        if (struct instanceof Item && struct.deleted && !struct.keep && gcFilter(struct)) {\n          struct.gc(store, false);\n        }\n      }\n    }\n  }\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {StructStore} store\n */\nconst tryMergeDeleteSet = (ds, store) => {\n  // try to merge deleted / gc'd items\n  // merge from right to left for better efficiecy and so we don't miss any merge targets\n  ds.clients.forEach((deleteItems, client) => {\n    const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));\n    for (let di = deleteItems.length - 1; di >= 0; di--) {\n      const deleteItem = deleteItems[di];\n      // start with merging the item next to the last deleted item\n      const mostRightIndexToCheck = math__namespace.min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));\n      for (\n        let si = mostRightIndexToCheck, struct = structs[si];\n        si > 0 && struct.id.clock >= deleteItem.clock;\n        struct = structs[--si]\n      ) {\n        tryToMergeWithLeft(structs, si);\n      }\n    }\n  });\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {StructStore} store\n * @param {function(Item):boolean} gcFilter\n */\nconst tryGc = (ds, store, gcFilter) => {\n  tryGcDeleteSet(ds, store, gcFilter);\n  tryMergeDeleteSet(ds, store);\n};\n\n/**\n * @param {Array<Transaction>} transactionCleanups\n * @param {number} i\n */\nconst cleanupTransactions = (transactionCleanups, i) => {\n  if (i < transactionCleanups.length) {\n    const transaction = transactionCleanups[i];\n    const doc = transaction.doc;\n    const store = doc.store;\n    const ds = transaction.deleteSet;\n    const mergeStructs = transaction._mergeStructs;\n    try {\n      sortAndMergeDeleteSet(ds);\n      transaction.afterState = getStateVector(transaction.doc.store);\n      doc._transaction = null;\n      doc.emit('beforeObserverCalls', [transaction, doc]);\n      /**\n       * An array of event callbacks.\n       *\n       * Each callback is called even if the other ones throw errors.\n       *\n       * @type {Array<function():void>}\n       */\n      const fs = [];\n      // observe events on changed types\n      transaction.changed.forEach((subs, itemtype) =>\n        fs.push(() => {\n          if (itemtype._item === null || !itemtype._item.deleted) {\n            itemtype._callObserver(transaction, subs);\n          }\n        })\n      );\n      fs.push(() => {\n        // deep observe events\n        transaction.changedParentTypes.forEach((events, type) =>\n          fs.push(() => {\n            // We need to think about the possibility that the user transforms the\n            // Y.Doc in the event.\n            if (type._item === null || !type._item.deleted) {\n              events = events\n                .filter(event =>\n                  event.target._item === null || !event.target._item.deleted\n                );\n              events\n                .forEach(event => {\n                  event.currentTarget = type;\n                });\n              // sort events by path length so that top-level events are fired first.\n              events\n                .sort((event1, event2) => event1.path.length - event2.path.length);\n              // We don't need to check for events.length\n              // because we know it has at least one element\n              callEventHandlerListeners(type._dEH, events, transaction);\n            }\n          })\n        );\n        fs.push(() => doc.emit('afterTransaction', [transaction, doc]));\n      });\n      f.callAll(fs, []);\n    } finally {\n      // Replace deleted items with ItemDeleted / GC.\n      // This is where content is actually remove from the Yjs Doc.\n      if (doc.gc) {\n        tryGcDeleteSet(ds, store, doc.gcFilter);\n      }\n      tryMergeDeleteSet(ds, store);\n\n      // on all affected store.clients props, try to merge\n      transaction.afterState.forEach((clock, client) => {\n        const beforeClock = transaction.beforeState.get(client) || 0;\n        if (beforeClock !== clock) {\n          const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));\n          // we iterate from right to left so we can safely remove entries\n          const firstChangePos = math__namespace.max(findIndexSS(structs, beforeClock), 1);\n          for (let i = structs.length - 1; i >= firstChangePos; i--) {\n            tryToMergeWithLeft(structs, i);\n          }\n        }\n      });\n      // try to merge mergeStructs\n      // @todo: it makes more sense to transform mergeStructs to a DS, sort it, and merge from right to left\n      //        but at the moment DS does not handle duplicates\n      for (let i = 0; i < mergeStructs.length; i++) {\n        const { client, clock } = mergeStructs[i].id;\n        const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));\n        const replacedStructPos = findIndexSS(structs, clock);\n        if (replacedStructPos + 1 < structs.length) {\n          tryToMergeWithLeft(structs, replacedStructPos + 1);\n        }\n        if (replacedStructPos > 0) {\n          tryToMergeWithLeft(structs, replacedStructPos);\n        }\n      }\n      if (!transaction.local && transaction.afterState.get(doc.clientID) !== transaction.beforeState.get(doc.clientID)) {\n        doc.clientID = generateNewClientId();\n        logging__namespace.print(logging__namespace.ORANGE, logging__namespace.BOLD, '[yjs] ', logging__namespace.UNBOLD, logging__namespace.RED, 'Changed the client-id because another client seems to be using it.');\n      }\n      // @todo Merge all the transactions into one and provide send the data as a single update message\n      doc.emit('afterTransactionCleanup', [transaction, doc]);\n      if (doc._observers.has('update')) {\n        const encoder = new UpdateEncoderV1();\n        const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);\n        if (hasContent) {\n          doc.emit('update', [encoder.toUint8Array(), transaction.origin, doc, transaction]);\n        }\n      }\n      if (doc._observers.has('updateV2')) {\n        const encoder = new UpdateEncoderV2();\n        const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);\n        if (hasContent) {\n          doc.emit('updateV2', [encoder.toUint8Array(), transaction.origin, doc, transaction]);\n        }\n      }\n      transaction.subdocsAdded.forEach(subdoc => doc.subdocs.add(subdoc));\n      transaction.subdocsRemoved.forEach(subdoc => doc.subdocs.delete(subdoc));\n\n      doc.emit('subdocs', [{ loaded: transaction.subdocsLoaded, added: transaction.subdocsAdded, removed: transaction.subdocsRemoved }]);\n      transaction.subdocsRemoved.forEach(subdoc => subdoc.destroy());\n\n      if (transactionCleanups.length <= i + 1) {\n        doc._transactionCleanups = [];\n        doc.emit('afterAllTransactions', [doc, transactionCleanups]);\n      } else {\n        cleanupTransactions(transactionCleanups, i + 1);\n      }\n    }\n  }\n};\n\n/**\n * Implements the functionality of `y.transact(()=>{..})`\n *\n * @param {Doc} doc\n * @param {function(Transaction):void} f\n * @param {any} [origin=true]\n *\n * @function\n */\nconst transact = (doc, f, origin = null, local = true) => {\n  const transactionCleanups = doc._transactionCleanups;\n  let initialCall = false;\n  if (doc._transaction === null) {\n    initialCall = true;\n    doc._transaction = new Transaction(doc, origin, local);\n    transactionCleanups.push(doc._transaction);\n    if (transactionCleanups.length === 1) {\n      doc.emit('beforeAllTransactions', [doc]);\n    }\n    doc.emit('beforeTransaction', [doc._transaction, doc]);\n  }\n  try {\n    f(doc._transaction);\n  } finally {\n    if (initialCall && transactionCleanups[0] === doc._transaction) {\n      // The first transaction ended, now process observer calls.\n      // Observer call may create new transactions for which we need to call the observers and do cleanup.\n      // We don't want to nest these calls, so we execute these calls one after\n      // another.\n      // Also we need to ensure that all cleanups are called, even if the\n      // observes throw errors.\n      // This file is full of hacky try {} finally {} blocks to ensure that an\n      // event can throw errors and also that the cleanup is called.\n      cleanupTransactions(transactionCleanups, 0);\n    }\n  }\n};\n\nclass StackItem {\n  /**\n   * @param {DeleteSet} deletions\n   * @param {DeleteSet} insertions\n   */\n  constructor (deletions, insertions) {\n    this.insertions = insertions;\n    this.deletions = deletions;\n    /**\n     * Use this to save and restore metadata like selection range\n     */\n    this.meta = new Map();\n  }\n}\n\n/**\n * @param {UndoManager} undoManager\n * @param {Array<StackItem>} stack\n * @param {string} eventType\n * @return {StackItem?}\n */\nconst popStackItem = (undoManager, stack, eventType) => {\n  /**\n   * Whether a change happened\n   * @type {StackItem?}\n   */\n  let result = null;\n  /**\n   * Keep a reference to the transaction so we can fire the event with the changedParentTypes\n   * @type {any}\n   */\n  let _tr = null;\n  const doc = undoManager.doc;\n  const scope = undoManager.scope;\n  transact(doc, transaction => {\n    while (stack.length > 0 && result === null) {\n      const store = doc.store;\n      const stackItem = /** @type {StackItem} */ (stack.pop());\n      /**\n       * @type {Set<Item>}\n       */\n      const itemsToRedo = new Set();\n      /**\n       * @type {Array<Item>}\n       */\n      const itemsToDelete = [];\n      let performedChange = false;\n      iterateDeletedStructs(transaction, stackItem.insertions, struct => {\n        if (struct instanceof Item) {\n          if (struct.redone !== null) {\n            let { item, diff } = followRedone(store, struct.id);\n            if (diff > 0) {\n              item = getItemCleanStart(transaction, createID(item.id.client, item.id.clock + diff));\n            }\n            struct = item;\n          }\n          if (!struct.deleted && scope.some(type => isParentOf(type, /** @type {Item} */ (struct)))) {\n            itemsToDelete.push(struct);\n          }\n        }\n      });\n      iterateDeletedStructs(transaction, stackItem.deletions, struct => {\n        if (\n          struct instanceof Item &&\n          scope.some(type => isParentOf(type, struct)) &&\n          // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.\n          !isDeleted(stackItem.insertions, struct.id)\n        ) {\n          itemsToRedo.add(struct);\n        }\n      });\n      itemsToRedo.forEach(struct => {\n        performedChange = redoItem(transaction, struct, itemsToRedo) !== null || performedChange;\n      });\n      // We want to delete in reverse order so that children are deleted before\n      // parents, so we have more information available when items are filtered.\n      for (let i = itemsToDelete.length - 1; i >= 0; i--) {\n        const item = itemsToDelete[i];\n        if (undoManager.deleteFilter(item)) {\n          item.delete(transaction);\n          performedChange = true;\n        }\n      }\n      result = performedChange ? stackItem : null;\n    }\n    transaction.changed.forEach((subProps, type) => {\n      // destroy search marker if necessary\n      if (subProps.has(null) && type._searchMarker) {\n        type._searchMarker.length = 0;\n      }\n    });\n    _tr = transaction;\n  }, undoManager);\n  if (result != null) {\n    const changedParentTypes = _tr.changedParentTypes;\n    undoManager.emit('stack-item-popped', [{ stackItem: result, type: eventType, changedParentTypes }, undoManager]);\n  }\n  return result\n};\n\n/**\n * @typedef {Object} UndoManagerOptions\n * @property {number} [UndoManagerOptions.captureTimeout=500]\n * @property {function(Item):boolean} [UndoManagerOptions.deleteFilter=()=>true] Sometimes\n * it is necessary to filter whan an Undo/Redo operation can delete. If this\n * filter returns false, the type/item won't be deleted even it is in the\n * undo/redo scope.\n * @property {Set<any>} [UndoManagerOptions.trackedOrigins=new Set([null])]\n */\n\n/**\n * Fires 'stack-item-added' event when a stack item was added to either the undo- or\n * the redo-stack. You may store additional stack information via the\n * metadata property on `event.stackItem.meta` (it is a `Map` of metadata properties).\n * Fires 'stack-item-popped' event when a stack item was popped from either the\n * undo- or the redo-stack. You may restore the saved stack information from `event.stackItem.meta`.\n *\n * @extends {Observable<'stack-item-added'|'stack-item-popped'>}\n */\nclass UndoManager extends observable.Observable {\n  /**\n   * @param {AbstractType<any>|Array<AbstractType<any>>} typeScope Accepts either a single type, or an array of types\n   * @param {UndoManagerOptions} options\n   */\n  constructor (typeScope, { captureTimeout = 500, deleteFilter = () => true, trackedOrigins = new Set([null]) } = {}) {\n    super();\n    this.scope = typeScope instanceof Array ? typeScope : [typeScope];\n    this.deleteFilter = deleteFilter;\n    trackedOrigins.add(this);\n    this.trackedOrigins = trackedOrigins;\n    /**\n     * @type {Array<StackItem>}\n     */\n    this.undoStack = [];\n    /**\n     * @type {Array<StackItem>}\n     */\n    this.redoStack = [];\n    /**\n     * Whether the client is currently undoing (calling UndoManager.undo)\n     *\n     * @type {boolean}\n     */\n    this.undoing = false;\n    this.redoing = false;\n    this.doc = /** @type {Doc} */ (this.scope[0].doc);\n    this.lastChange = 0;\n    this.doc.on('afterTransaction', /** @param {Transaction} transaction */ transaction => {\n      // Only track certain transactions\n      if (!this.scope.some(type => transaction.changedParentTypes.has(type)) || (!this.trackedOrigins.has(transaction.origin) && (!transaction.origin || !this.trackedOrigins.has(transaction.origin.constructor)))) {\n        return\n      }\n      const undoing = this.undoing;\n      const redoing = this.redoing;\n      const stack = undoing ? this.redoStack : this.undoStack;\n      if (undoing) {\n        this.stopCapturing(); // next undo should not be appended to last stack item\n      } else if (!redoing) {\n        // neither undoing nor redoing: delete redoStack\n        this.redoStack = [];\n      }\n      const insertions = new DeleteSet();\n      transaction.afterState.forEach((endClock, client) => {\n        const startClock = transaction.beforeState.get(client) || 0;\n        const len = endClock - startClock;\n        if (len > 0) {\n          addToDeleteSet(insertions, client, startClock, len);\n        }\n      });\n      const now = time__namespace.getUnixTime();\n      if (now - this.lastChange < captureTimeout && stack.length > 0 && !undoing && !redoing) {\n        // append change to last stack op\n        const lastOp = stack[stack.length - 1];\n        lastOp.deletions = mergeDeleteSets([lastOp.deletions, transaction.deleteSet]);\n        lastOp.insertions = mergeDeleteSets([lastOp.insertions, insertions]);\n      } else {\n        // create a new stack op\n        stack.push(new StackItem(transaction.deleteSet, insertions));\n      }\n      if (!undoing && !redoing) {\n        this.lastChange = now;\n      }\n      // make sure that deleted structs are not gc'd\n      iterateDeletedStructs(transaction, transaction.deleteSet, /** @param {Item|GC} item */ item => {\n        if (item instanceof Item && this.scope.some(type => isParentOf(type, item))) {\n          keepItem(item, true);\n        }\n      });\n      this.emit('stack-item-added', [{ stackItem: stack[stack.length - 1], origin: transaction.origin, type: undoing ? 'redo' : 'undo', changedParentTypes: transaction.changedParentTypes }, this]);\n    });\n  }\n\n  clear () {\n    this.doc.transact(transaction => {\n      /**\n       * @param {StackItem} stackItem\n       */\n      const clearItem = stackItem => {\n        iterateDeletedStructs(transaction, stackItem.deletions, item => {\n          if (item instanceof Item && this.scope.some(type => isParentOf(type, item))) {\n            keepItem(item, false);\n          }\n        });\n      };\n      this.undoStack.forEach(clearItem);\n      this.redoStack.forEach(clearItem);\n    });\n    this.undoStack = [];\n    this.redoStack = [];\n  }\n\n  /**\n   * UndoManager merges Undo-StackItem if they are created within time-gap\n   * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next\n   * StackItem won't be merged.\n   *\n   *\n   * @example\n   *     // without stopCapturing\n   *     ytext.insert(0, 'a')\n   *     ytext.insert(1, 'b')\n   *     um.undo()\n   *     ytext.toString() // => '' (note that 'ab' was removed)\n   *     // with stopCapturing\n   *     ytext.insert(0, 'a')\n   *     um.stopCapturing()\n   *     ytext.insert(0, 'b')\n   *     um.undo()\n   *     ytext.toString() // => 'a' (note that only 'b' was removed)\n   *\n   */\n  stopCapturing () {\n    this.lastChange = 0;\n  }\n\n  /**\n   * Undo last changes on type.\n   *\n   * @return {StackItem?} Returns StackItem if a change was applied\n   */\n  undo () {\n    this.undoing = true;\n    let res;\n    try {\n      res = popStackItem(this, this.undoStack, 'undo');\n    } finally {\n      this.undoing = false;\n    }\n    return res\n  }\n\n  /**\n   * Redo last undo operation.\n   *\n   * @return {StackItem?} Returns StackItem if a change was applied\n   */\n  redo () {\n    this.redoing = true;\n    let res;\n    try {\n      res = popStackItem(this, this.redoStack, 'redo');\n    } finally {\n      this.redoing = false;\n    }\n    return res\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n */\nfunction * lazyStructReaderGenerator (decoder) {\n  const numOfStateUpdates = decoding__namespace.readVarUint(decoder.restDecoder);\n  for (let i = 0; i < numOfStateUpdates; i++) {\n    const numberOfStructs = decoding__namespace.readVarUint(decoder.restDecoder);\n    const client = decoder.readClient();\n    let clock = decoding__namespace.readVarUint(decoder.restDecoder);\n    for (let i = 0; i < numberOfStructs; i++) {\n      const info = decoder.readInfo();\n      // @todo use switch instead of ifs\n      if (info === 10) {\n        const len = decoding__namespace.readVarUint(decoder.restDecoder);\n        yield new Skip(createID(client, clock), len);\n        clock += len;\n      } else if ((binary__namespace.BITS5 & info) !== 0) {\n        const cantCopyParentInfo = (info & (binary__namespace.BIT7 | binary__namespace.BIT8)) === 0;\n        // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n        // and we read the next string as parentYKey.\n        // It indicates how we store/retrieve parent from `y.share`\n        // @type {string|null}\n        const struct = new Item(\n          createID(client, clock),\n          null, // left\n          (info & binary__namespace.BIT8) === binary__namespace.BIT8 ? decoder.readLeftID() : null, // origin\n          null, // right\n          (info & binary__namespace.BIT7) === binary__namespace.BIT7 ? decoder.readRightID() : null, // right origin\n          // @ts-ignore Force writing a string here.\n          cantCopyParentInfo ? (decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID()) : null, // parent\n          cantCopyParentInfo && (info & binary__namespace.BIT6) === binary__namespace.BIT6 ? decoder.readString() : null, // parentSub\n          readItemContent(decoder, info) // item content\n        );\n        yield struct;\n        clock += struct.length;\n      } else {\n        const len = decoder.readLen();\n        yield new GC(createID(client, clock), len);\n        clock += len;\n      }\n    }\n  }\n}\n\nclass LazyStructReader {\n  /**\n   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n   * @param {boolean} filterSkips\n   */\n  constructor (decoder, filterSkips) {\n    this.gen = lazyStructReaderGenerator(decoder);\n    /**\n     * @type {null | Item | Skip | GC}\n     */\n    this.curr = null;\n    this.done = false;\n    this.filterSkips = filterSkips;\n    this.next();\n  }\n\n  /**\n   * @return {Item | GC | Skip |null}\n   */\n  next () {\n    // ignore \"Skip\" structs\n    do {\n      this.curr = this.gen.next().value || null;\n    } while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip)\n    return this.curr\n  }\n}\n\n/**\n * @param {Uint8Array} update\n *\n */\nconst logUpdate = update => logUpdateV2(update, UpdateDecoderV1);\n\n/**\n * @param {Uint8Array} update\n * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]\n *\n */\nconst logUpdateV2 = (update, YDecoder = UpdateDecoderV2) => {\n  const structs = [];\n  const updateDecoder = new YDecoder(decoding__namespace.createDecoder(update));\n  const lazyDecoder = new LazyStructReader(updateDecoder, false);\n  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {\n    structs.push(curr);\n  }\n  logging__namespace.print('Structs: ', structs);\n  const ds = readDeleteSet(updateDecoder);\n  logging__namespace.print('DeleteSet: ', ds);\n};\n\nclass LazyStructWriter {\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  constructor (encoder) {\n    this.currClient = 0;\n    this.startClock = 0;\n    this.written = 0;\n    this.encoder = encoder;\n    /**\n     * We want to write operations lazily, but also we need to know beforehand how many operations we want to write for each client.\n     *\n     * This kind of meta-information (#clients, #structs-per-client-written) is written to the restEncoder.\n     *\n     * We fragment the restEncoder and store a slice of it per-client until we know how many clients there are.\n     * When we flush (toUint8Array) we write the restEncoder using the fragments and the meta-information.\n     *\n     * @type {Array<{ written: number, restEncoder: Uint8Array }>}\n     */\n    this.clientStructs = [];\n  }\n}\n\n/**\n * @param {Array<Uint8Array>} updates\n * @return {Uint8Array}\n */\nconst mergeUpdates = updates => mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1);\n\n/**\n * @param {Uint8Array} update\n * @param {typeof DSEncoderV1 | typeof DSEncoderV2} YEncoder\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder\n * @return {Uint8Array}\n */\nconst encodeStateVectorFromUpdateV2 = (update, YEncoder = DSEncoderV2, YDecoder = UpdateDecoderV2) => {\n  const encoder = new YEncoder();\n  const updateDecoder = new LazyStructReader(new YDecoder(decoding__namespace.createDecoder(update)), false);\n  let curr = updateDecoder.curr;\n  if (curr !== null) {\n    let size = 0;\n    let currClient = curr.id.client;\n    let currClock = 0;\n    let stopCounting = curr.id.clock !== 0; // must start at 0\n    for (; curr !== null; curr = updateDecoder.next()) {\n      // we ignore skips\n      if (curr.constructor === Skip) {\n        stopCounting = true;\n      }\n      if (!stopCounting) {\n        currClock = curr.id.clock + curr.length;\n      }\n      if (currClient !== curr.id.client) {\n        if (currClock !== 0) {\n          size++;\n          // We found a new client\n          // write what we have to the encoder\n          encoding__namespace.writeVarUint(encoder.restEncoder, currClient);\n          encoding__namespace.writeVarUint(encoder.restEncoder, currClock);\n        }\n        currClient = curr.id.client;\n        stopCounting = false;\n      }\n    }\n    // write what we have\n    if (currClock !== 0) {\n      size++;\n      encoding__namespace.writeVarUint(encoder.restEncoder, currClient);\n      encoding__namespace.writeVarUint(encoder.restEncoder, currClock);\n    }\n    // prepend the size of the state vector\n    const enc = encoding__namespace.createEncoder();\n    encoding__namespace.writeVarUint(enc, size);\n    encoding__namespace.writeBinaryEncoder(enc, encoder.restEncoder);\n    encoder.restEncoder = enc;\n    return encoder.toUint8Array()\n  } else {\n    encoding__namespace.writeVarUint(encoder.restEncoder, 0);\n    return encoder.toUint8Array()\n  }\n};\n\n/**\n * @param {Uint8Array} update\n * @return {Uint8Array}\n */\nconst encodeStateVectorFromUpdate = update => encodeStateVectorFromUpdateV2(update, DSEncoderV1, UpdateDecoderV1);\n\n/**\n * @param {Uint8Array} update\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder\n * @return {{ from: Map<number,number>, to: Map<number,number> }}\n */\nconst parseUpdateMetaV2 = (update, YDecoder = UpdateDecoderV2) => {\n  /**\n   * @type {Map<number, number>}\n   */\n  const from = new Map();\n  /**\n   * @type {Map<number, number>}\n   */\n  const to = new Map();\n  const updateDecoder = new LazyStructReader(new YDecoder(decoding__namespace.createDecoder(update)), false);\n  let curr = updateDecoder.curr;\n  if (curr !== null) {\n    let currClient = curr.id.client;\n    let currClock = curr.id.clock;\n    // write the beginning to `from`\n    from.set(currClient, currClock);\n    for (; curr !== null; curr = updateDecoder.next()) {\n      if (currClient !== curr.id.client) {\n        // We found a new client\n        // write the end to `to`\n        to.set(currClient, currClock);\n        // write the beginning to `from`\n        from.set(curr.id.client, curr.id.clock);\n        // update currClient\n        currClient = curr.id.client;\n      }\n      currClock = curr.id.clock + curr.length;\n    }\n    // write the end to `to`\n    to.set(currClient, currClock);\n  }\n  return { from, to }\n};\n\n/**\n * @param {Uint8Array} update\n * @return {{ from: Map<number,number>, to: Map<number,number> }}\n */\nconst parseUpdateMeta = update => parseUpdateMetaV2(update, UpdateDecoderV1);\n\n/**\n * This method is intended to slice any kind of struct and retrieve the right part.\n * It does not handle side-effects, so it should only be used by the lazy-encoder.\n *\n * @param {Item | GC | Skip} left\n * @param {number} diff\n * @return {Item | GC}\n */\nconst sliceStruct = (left, diff) => {\n  if (left.constructor === GC) {\n    const { client, clock } = left.id;\n    return new GC(createID(client, clock + diff), left.length - diff)\n  } else if (left.constructor === Skip) {\n    const { client, clock } = left.id;\n    return new Skip(createID(client, clock + diff), left.length - diff)\n  } else {\n    const leftItem = /** @type {Item} */ (left);\n    const { client, clock } = leftItem.id;\n    return new Item(\n      createID(client, clock + diff),\n      null,\n      createID(client, clock + diff - 1),\n      null,\n      leftItem.rightOrigin,\n      leftItem.parent,\n      leftItem.parentSub,\n      leftItem.content.splice(diff)\n    )\n  }\n};\n\n/**\n *\n * This function works similarly to `readUpdateV2`.\n *\n * @param {Array<Uint8Array>} updates\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]\n * @return {Uint8Array}\n */\nconst mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {\n  const updateDecoders = updates.map(update => new YDecoder(decoding__namespace.createDecoder(update)));\n  let lazyStructDecoders = updateDecoders.map(decoder => new LazyStructReader(decoder, true));\n\n  /**\n   * @todo we don't need offset because we always slice before\n   * @type {null | { struct: Item | GC | Skip, offset: number }}\n   */\n  let currWrite = null;\n\n  const updateEncoder = new YEncoder();\n  // write structs lazily\n  const lazyStructEncoder = new LazyStructWriter(updateEncoder);\n\n  // Note: We need to ensure that all lazyStructDecoders are fully consumed\n  // Note: Should merge document updates whenever possible - even from different updates\n  // Note: Should handle that some operations cannot be applied yet ()\n\n  while (true) {\n    // Write higher clients first  sort by clientID & clock and remove decoders without content\n    lazyStructDecoders = lazyStructDecoders.filter(dec => dec.curr !== null);\n    lazyStructDecoders.sort(\n      /** @type {function(any,any):number} */ (dec1, dec2) => {\n        if (dec1.curr.id.client === dec2.curr.id.client) {\n          const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;\n          if (clockDiff === 0) {\n            return dec1.curr.constructor === dec2.curr.constructor ? 0 : (\n              dec1.curr.constructor === Skip ? 1 : -1\n            )\n          } else {\n            return clockDiff\n          }\n        } else {\n          return dec2.curr.id.client - dec1.curr.id.client\n        }\n      }\n    );\n    if (lazyStructDecoders.length === 0) {\n      break\n    }\n    const currDecoder = lazyStructDecoders[0];\n    // write from currDecoder until the next operation is from another client or if filler-struct\n    // then we need to reorder the decoders and find the next operation to write\n    const firstClient = /** @type {Item | GC} */ (currDecoder.curr).id.client;\n\n    if (currWrite !== null) {\n      let curr = /** @type {Item | GC | null} */ (currDecoder.curr);\n\n      // iterate until we find something that we haven't written already\n      // remember: first the high client-ids are written\n      while (curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client) {\n        curr = currDecoder.next();\n      }\n      if (curr === null || curr.id.client !== firstClient) {\n        continue\n      }\n\n      if (firstClient !== currWrite.struct.id.client) {\n        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n        currWrite = { struct: curr, offset: 0 };\n        currDecoder.next();\n      } else {\n        if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {\n          // @todo write currStruct & set currStruct = Skip(clock = currStruct.id.clock + currStruct.length, length = curr.id.clock - self.clock)\n          if (currWrite.struct.constructor === Skip) {\n            // extend existing skip\n            currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;\n          } else {\n            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n            const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;\n            /**\n             * @type {Skip}\n             */\n            const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);\n            currWrite = { struct, offset: 0 };\n          }\n        } else { // if (currWrite.struct.id.clock + currWrite.struct.length >= curr.id.clock) {\n          const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;\n          if (diff > 0) {\n            if (currWrite.struct.constructor === Skip) {\n              // prefer to slice Skip because the other struct might contain more information\n              currWrite.struct.length -= diff;\n            } else {\n              curr = sliceStruct(curr, diff);\n            }\n          }\n          if (!currWrite.struct.mergeWith(/** @type {any} */ (curr))) {\n            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n            currWrite = { struct: curr, offset: 0 };\n            currDecoder.next();\n          }\n        }\n      }\n    } else {\n      currWrite = { struct: /** @type {Item | GC} */ (currDecoder.curr), offset: 0 };\n      currDecoder.next();\n    }\n    for (\n      let next = currDecoder.curr;\n      next !== null && next.id.client === firstClient && next.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next.constructor !== Skip;\n      next = currDecoder.next()\n    ) {\n      writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n      currWrite = { struct: next, offset: 0 };\n    }\n  }\n  if (currWrite !== null) {\n    writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n    currWrite = null;\n  }\n  finishLazyStructWriting(lazyStructEncoder);\n\n  const dss = updateDecoders.map(decoder => readDeleteSet(decoder));\n  const ds = mergeDeleteSets(dss);\n  writeDeleteSet(updateEncoder, ds);\n  return updateEncoder.toUint8Array()\n};\n\n/**\n * @param {Uint8Array} update\n * @param {Uint8Array} sv\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]\n */\nconst diffUpdateV2 = (update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {\n  const state = decodeStateVector(sv);\n  const encoder = new YEncoder();\n  const lazyStructWriter = new LazyStructWriter(encoder);\n  const decoder = new YDecoder(decoding__namespace.createDecoder(update));\n  const reader = new LazyStructReader(decoder, false);\n  while (reader.curr) {\n    const curr = reader.curr;\n    const currClient = curr.id.client;\n    const svClock = state.get(currClient) || 0;\n    if (reader.curr.constructor === Skip) {\n      // the first written struct shouldn't be a skip\n      reader.next();\n      continue\n    }\n    if (curr.id.clock + curr.length > svClock) {\n      writeStructToLazyStructWriter(lazyStructWriter, curr, math__namespace.max(svClock - curr.id.clock, 0));\n      reader.next();\n      while (reader.curr && reader.curr.id.client === currClient) {\n        writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);\n        reader.next();\n      }\n    } else {\n      // read until something new comes up\n      while (reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock) {\n        reader.next();\n      }\n    }\n  }\n  finishLazyStructWriting(lazyStructWriter);\n  // write ds\n  const ds = readDeleteSet(decoder);\n  writeDeleteSet(encoder, ds);\n  return encoder.toUint8Array()\n};\n\n/**\n * @param {Uint8Array} update\n * @param {Uint8Array} sv\n */\nconst diffUpdate = (update, sv) => diffUpdateV2(update, sv, UpdateDecoderV1, UpdateEncoderV1);\n\n/**\n * @param {LazyStructWriter} lazyWriter\n */\nconst flushLazyStructWriter = lazyWriter => {\n  if (lazyWriter.written > 0) {\n    lazyWriter.clientStructs.push({ written: lazyWriter.written, restEncoder: encoding__namespace.toUint8Array(lazyWriter.encoder.restEncoder) });\n    lazyWriter.encoder.restEncoder = encoding__namespace.createEncoder();\n    lazyWriter.written = 0;\n  }\n};\n\n/**\n * @param {LazyStructWriter} lazyWriter\n * @param {Item | GC} struct\n * @param {number} offset\n */\nconst writeStructToLazyStructWriter = (lazyWriter, struct, offset) => {\n  // flush curr if we start another client\n  if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {\n    flushLazyStructWriter(lazyWriter);\n  }\n  if (lazyWriter.written === 0) {\n    lazyWriter.currClient = struct.id.client;\n    // write next client\n    lazyWriter.encoder.writeClient(struct.id.client);\n    // write startClock\n    encoding__namespace.writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset);\n  }\n  struct.write(lazyWriter.encoder, offset);\n  lazyWriter.written++;\n};\n/**\n * Call this function when we collected all parts and want to\n * put all the parts together. After calling this method,\n * you can continue using the UpdateEncoder.\n *\n * @param {LazyStructWriter} lazyWriter\n */\nconst finishLazyStructWriting = (lazyWriter) => {\n  flushLazyStructWriter(lazyWriter);\n\n  // this is a fresh encoder because we called flushCurr\n  const restEncoder = lazyWriter.encoder.restEncoder;\n\n  /**\n   * Now we put all the fragments together.\n   * This works similarly to `writeClientsStructs`\n   */\n\n  // write # states that were updated - i.e. the clients\n  encoding__namespace.writeVarUint(restEncoder, lazyWriter.clientStructs.length);\n\n  for (let i = 0; i < lazyWriter.clientStructs.length; i++) {\n    const partStructs = lazyWriter.clientStructs[i];\n    /**\n     * Works similarly to `writeStructs`\n     */\n    // write # encoded structs\n    encoding__namespace.writeVarUint(restEncoder, partStructs.written);\n    // write the rest of the fragment\n    encoding__namespace.writeUint8Array(restEncoder, partStructs.restEncoder);\n  }\n};\n\n/**\n * YEvent describes the changes on a YType.\n */\nclass YEvent {\n  /**\n   * @param {AbstractType<any>} target The changed type.\n   * @param {Transaction} transaction\n   */\n  constructor (target, transaction) {\n    /**\n     * The type on which this event was created on.\n     * @type {AbstractType<any>}\n     */\n    this.target = target;\n    /**\n     * The current target on which the observe callback is called.\n     * @type {AbstractType<any>}\n     */\n    this.currentTarget = target;\n    /**\n     * The transaction that triggered this event.\n     * @type {Transaction}\n     */\n    this.transaction = transaction;\n    /**\n     * @type {Object|null}\n     */\n    this._changes = null;\n    /**\n     * @type {null | Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}\n     */\n    this._keys = null;\n    /**\n     * @type {null | Array<{ insert?: string | Array<any>, retain?: number, delete?: number, attributes?: Object<string, any> }>}\n     */\n    this._delta = null;\n  }\n\n  /**\n   * Computes the path from `y` to the changed type.\n   *\n   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.\n   *\n   * The following property holds:\n   * @example\n   *   let type = y\n   *   event.path.forEach(dir => {\n   *     type = type.get(dir)\n   *   })\n   *   type === event.target // => true\n   */\n  get path () {\n    // @ts-ignore _item is defined because target is integrated\n    return getPathTo(this.currentTarget, this.target)\n  }\n\n  /**\n   * Check if a struct is deleted by this event.\n   *\n   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.\n   *\n   * @param {AbstractStruct} struct\n   * @return {boolean}\n   */\n  deletes (struct) {\n    return isDeleted(this.transaction.deleteSet, struct.id)\n  }\n\n  /**\n   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}\n   */\n  get keys () {\n    if (this._keys === null) {\n      const keys = new Map();\n      const target = this.target;\n      const changed = /** @type Set<string|null> */ (this.transaction.changed.get(target));\n      changed.forEach(key => {\n        if (key !== null) {\n          const item = /** @type {Item} */ (target._map.get(key));\n          /**\n           * @type {'delete' | 'add' | 'update'}\n           */\n          let action;\n          let oldValue;\n          if (this.adds(item)) {\n            let prev = item.left;\n            while (prev !== null && this.adds(prev)) {\n              prev = prev.left;\n            }\n            if (this.deletes(item)) {\n              if (prev !== null && this.deletes(prev)) {\n                action = 'delete';\n                oldValue = array__namespace.last(prev.content.getContent());\n              } else {\n                return\n              }\n            } else {\n              if (prev !== null && this.deletes(prev)) {\n                action = 'update';\n                oldValue = array__namespace.last(prev.content.getContent());\n              } else {\n                action = 'add';\n                oldValue = undefined;\n              }\n            }\n          } else {\n            if (this.deletes(item)) {\n              action = 'delete';\n              oldValue = array__namespace.last(/** @type {Item} */ item.content.getContent());\n            } else {\n              return // nop\n            }\n          }\n          keys.set(key, { action, oldValue });\n        }\n      });\n      this._keys = keys;\n    }\n    return this._keys\n  }\n\n  /**\n   * @type {Array<{insert?: string | Array<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}\n   */\n  get delta () {\n    return this.changes.delta\n  }\n\n  /**\n   * Check if a struct is added by this event.\n   *\n   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.\n   *\n   * @param {AbstractStruct} struct\n   * @return {boolean}\n   */\n  adds (struct) {\n    return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0)\n  }\n\n  /**\n   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}\n   */\n  get changes () {\n    let changes = this._changes;\n    if (changes === null) {\n      const target = this.target;\n      const added = set__namespace.create();\n      const deleted = set__namespace.create();\n      /**\n       * @type {Array<{insert:Array<any>}|{delete:number}|{retain:number}>}\n       */\n      const delta = [];\n      changes = {\n        added,\n        deleted,\n        delta,\n        keys: this.keys\n      };\n      const changed = /** @type Set<string|null> */ (this.transaction.changed.get(target));\n      if (changed.has(null)) {\n        /**\n         * @type {any}\n         */\n        let lastOp = null;\n        const packOp = () => {\n          if (lastOp) {\n            delta.push(lastOp);\n          }\n        };\n        for (let item = target._start; item !== null; item = item.right) {\n          if (item.deleted) {\n            if (this.deletes(item) && !this.adds(item)) {\n              if (lastOp === null || lastOp.delete === undefined) {\n                packOp();\n                lastOp = { delete: 0 };\n              }\n              lastOp.delete += item.length;\n              deleted.add(item);\n            } // else nop\n          } else {\n            if (this.adds(item)) {\n              if (lastOp === null || lastOp.insert === undefined) {\n                packOp();\n                lastOp = { insert: [] };\n              }\n              lastOp.insert = lastOp.insert.concat(item.content.getContent());\n              added.add(item);\n            } else {\n              if (lastOp === null || lastOp.retain === undefined) {\n                packOp();\n                lastOp = { retain: 0 };\n              }\n              lastOp.retain += item.length;\n            }\n          }\n        }\n        if (lastOp !== null && lastOp.retain === undefined) {\n          packOp();\n        }\n      }\n      this._changes = changes;\n    }\n    return /** @type {any} */ (changes)\n  }\n}\n\n/**\n * Compute the path from this type to the specified target.\n *\n * @example\n *   // `child` should be accessible via `type.get(path[0]).get(path[1])..`\n *   const path = type.getPathTo(child)\n *   // assuming `type instanceof YArray`\n *   console.log(path) // might look like => [2, 'key1']\n *   child === type.get(path[0]).get(path[1])\n *\n * @param {AbstractType<any>} parent\n * @param {AbstractType<any>} child target\n * @return {Array<string|number>} Path to the target\n *\n * @private\n * @function\n */\nconst getPathTo = (parent, child) => {\n  const path = [];\n  while (child._item !== null && child !== parent) {\n    if (child._item.parentSub !== null) {\n      // parent is map-ish\n      path.unshift(child._item.parentSub);\n    } else {\n      // parent is array-ish\n      let i = 0;\n      let c = /** @type {AbstractType<any>} */ (child._item.parent)._start;\n      while (c !== child._item && c !== null) {\n        if (!c.deleted) {\n          i++;\n        }\n        c = c.right;\n      }\n      path.unshift(i);\n    }\n    child = /** @type {AbstractType<any>} */ (child._item.parent);\n  }\n  return path\n};\n\nconst maxSearchMarker = 80;\n\n/**\n * A unique timestamp that identifies each marker.\n *\n * Time is relative,.. this is more like an ever-increasing clock.\n *\n * @type {number}\n */\nlet globalSearchMarkerTimestamp = 0;\n\nclass ArraySearchMarker {\n  /**\n   * @param {Item} p\n   * @param {number} index\n   */\n  constructor (p, index) {\n    p.marker = true;\n    this.p = p;\n    this.index = index;\n    this.timestamp = globalSearchMarkerTimestamp++;\n  }\n}\n\n/**\n * @param {ArraySearchMarker} marker\n */\nconst refreshMarkerTimestamp = marker => { marker.timestamp = globalSearchMarkerTimestamp++; };\n\n/**\n * This is rather complex so this function is the only thing that should overwrite a marker\n *\n * @param {ArraySearchMarker} marker\n * @param {Item} p\n * @param {number} index\n */\nconst overwriteMarker = (marker, p, index) => {\n  marker.p.marker = false;\n  marker.p = p;\n  p.marker = true;\n  marker.index = index;\n  marker.timestamp = globalSearchMarkerTimestamp++;\n};\n\n/**\n * @param {Array<ArraySearchMarker>} searchMarker\n * @param {Item} p\n * @param {number} index\n */\nconst markPosition = (searchMarker, p, index) => {\n  if (searchMarker.length >= maxSearchMarker) {\n    // override oldest marker (we don't want to create more objects)\n    const marker = searchMarker.reduce((a, b) => a.timestamp < b.timestamp ? a : b);\n    overwriteMarker(marker, p, index);\n    return marker\n  } else {\n    // create new marker\n    const pm = new ArraySearchMarker(p, index);\n    searchMarker.push(pm);\n    return pm\n  }\n};\n\n/**\n * Search marker help us to find positions in the associative array faster.\n *\n * They speed up the process of finding a position without much bookkeeping.\n *\n * A maximum of `maxSearchMarker` objects are created.\n *\n * This function always returns a refreshed marker (updated timestamp)\n *\n * @param {AbstractType<any>} yarray\n * @param {number} index\n */\nconst findMarker = (yarray, index) => {\n  if (yarray._start === null || index === 0 || yarray._searchMarker === null) {\n    return null\n  }\n  const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a, b) => math__namespace.abs(index - a.index) < math__namespace.abs(index - b.index) ? a : b);\n  let p = yarray._start;\n  let pindex = 0;\n  if (marker !== null) {\n    p = marker.p;\n    pindex = marker.index;\n    refreshMarkerTimestamp(marker); // we used it, we might need to use it again\n  }\n  // iterate to right if possible\n  while (p.right !== null && pindex < index) {\n    if (!p.deleted && p.countable) {\n      if (index < pindex + p.length) {\n        break\n      }\n      pindex += p.length;\n    }\n    p = p.right;\n  }\n  // iterate to left if necessary (might be that pindex > index)\n  while (p.left !== null && pindex > index) {\n    p = p.left;\n    if (!p.deleted && p.countable) {\n      pindex -= p.length;\n    }\n  }\n  // we want to make sure that p can't be merged with left, because that would screw up everything\n  // in that cas just return what we have (it is most likely the best marker anyway)\n  // iterate to left until p can't be merged with left\n  while (p.left !== null && p.left.id.client === p.id.client && p.left.id.clock + p.left.length === p.id.clock) {\n    p = p.left;\n    if (!p.deleted && p.countable) {\n      pindex -= p.length;\n    }\n  }\n\n  // @todo remove!\n  // assure position\n  // {\n  //   let start = yarray._start\n  //   let pos = 0\n  //   while (start !== p) {\n  //     if (!start.deleted && start.countable) {\n  //       pos += start.length\n  //     }\n  //     start = /** @type {Item} */ (start.right)\n  //   }\n  //   if (pos !== pindex) {\n  //     debugger\n  //     throw new Error('Gotcha position fail!')\n  //   }\n  // }\n  // if (marker) {\n  //   if (window.lengthes == null) {\n  //     window.lengthes = []\n  //     window.getLengthes = () => window.lengthes.sort((a, b) => a - b)\n  //   }\n  //   window.lengthes.push(marker.index - pindex)\n  //   console.log('distance', marker.index - pindex, 'len', p && p.parent.length)\n  // }\n  if (marker !== null && math__namespace.abs(marker.index - pindex) < /** @type {YText|YArray<any>} */ (p.parent).length / maxSearchMarker) {\n    // adjust existing marker\n    overwriteMarker(marker, p, pindex);\n    return marker\n  } else {\n    // create new marker\n    return markPosition(yarray._searchMarker, p, pindex)\n  }\n};\n\n/**\n * Update markers when a change happened.\n *\n * This should be called before doing a deletion!\n *\n * @param {Array<ArraySearchMarker>} searchMarker\n * @param {number} index\n * @param {number} len If insertion, len is positive. If deletion, len is negative.\n */\nconst updateMarkerChanges = (searchMarker, index, len) => {\n  for (let i = searchMarker.length - 1; i >= 0; i--) {\n    const m = searchMarker[i];\n    if (len > 0) {\n      /**\n       * @type {Item|null}\n       */\n      let p = m.p;\n      p.marker = false;\n      // Ideally we just want to do a simple position comparison, but this will only work if\n      // search markers don't point to deleted items for formats.\n      // Iterate marker to prev undeleted countable position so we know what to do when updating a position\n      while (p && (p.deleted || !p.countable)) {\n        p = p.left;\n        if (p && !p.deleted && p.countable) {\n          // adjust position. the loop should break now\n          m.index -= p.length;\n        }\n      }\n      if (p === null || p.marker === true) {\n        // remove search marker if updated position is null or if position is already marked\n        searchMarker.splice(i, 1);\n        continue\n      }\n      m.p = p;\n      p.marker = true;\n    }\n    if (index < m.index || (len > 0 && index === m.index)) { // a simple index <= m.index check would actually suffice\n      m.index = math__namespace.max(index, m.index + len);\n    }\n  }\n};\n\n/**\n * Accumulate all (list) children of a type and return them as an Array.\n *\n * @param {AbstractType<any>} t\n * @return {Array<Item>}\n */\nconst getTypeChildren = t => {\n  let s = t._start;\n  const arr = [];\n  while (s) {\n    arr.push(s);\n    s = s.right;\n  }\n  return arr\n};\n\n/**\n * Call event listeners with an event. This will also add an event to all\n * parents (for `.observeDeep` handlers).\n *\n * @template EventType\n * @param {AbstractType<EventType>} type\n * @param {Transaction} transaction\n * @param {EventType} event\n */\nconst callTypeObservers = (type, transaction, event) => {\n  const changedType = type;\n  const changedParentTypes = transaction.changedParentTypes;\n  while (true) {\n    // @ts-ignore\n    map__namespace.setIfUndefined(changedParentTypes, type, () => []).push(event);\n    if (type._item === null) {\n      break\n    }\n    type = /** @type {AbstractType<any>} */ (type._item.parent);\n  }\n  callEventHandlerListeners(changedType._eH, event, transaction);\n};\n\n/**\n * @template EventType\n * Abstract Yjs Type class\n */\nclass AbstractType {\n  constructor () {\n    /**\n     * @type {Item|null}\n     */\n    this._item = null;\n    /**\n     * @type {Map<string,Item>}\n     */\n    this._map = new Map();\n    /**\n     * @type {Item|null}\n     */\n    this._start = null;\n    /**\n     * @type {Doc|null}\n     */\n    this.doc = null;\n    this._length = 0;\n    /**\n     * Event handlers\n     * @type {EventHandler<EventType,Transaction>}\n     */\n    this._eH = createEventHandler();\n    /**\n     * Deep event handlers\n     * @type {EventHandler<Array<YEvent>,Transaction>}\n     */\n    this._dEH = createEventHandler();\n    /**\n     * @type {null | Array<ArraySearchMarker>}\n     */\n    this._searchMarker = null;\n  }\n\n  /**\n   * @return {AbstractType<any>|null}\n   */\n  get parent () {\n    return this._item ? /** @type {AbstractType<any>} */ (this._item.parent) : null\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item|null} item\n   */\n  _integrate (y, item) {\n    this.doc = y;\n    this._item = item;\n  }\n\n  /**\n   * @return {AbstractType<EventType>}\n   */\n  _copy () {\n    throw error__namespace.methodUnimplemented()\n  }\n\n  /**\n   * @return {AbstractType<EventType>}\n   */\n  clone () {\n    throw error__namespace.methodUnimplemented()\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) { }\n\n  /**\n   * The first non-deleted item\n   */\n  get _first () {\n    let n = this._start;\n    while (n !== null && n.deleted) {\n      n = n.right;\n    }\n    return n\n  }\n\n  /**\n   * Creates YEvent and calls all type observers.\n   * Must be implemented by each type.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    if (!transaction.local && this._searchMarker) {\n      this._searchMarker.length = 0;\n    }\n  }\n\n  /**\n   * Observe all events that are created on this type.\n   *\n   * @param {function(EventType, Transaction):void} f Observer function\n   */\n  observe (f) {\n    addEventHandlerListener(this._eH, f);\n  }\n\n  /**\n   * Observe all events that are created by this type and its children.\n   *\n   * @param {function(Array<YEvent>,Transaction):void} f Observer function\n   */\n  observeDeep (f) {\n    addEventHandlerListener(this._dEH, f);\n  }\n\n  /**\n   * Unregister an observer function.\n   *\n   * @param {function(EventType,Transaction):void} f Observer function\n   */\n  unobserve (f) {\n    removeEventHandlerListener(this._eH, f);\n  }\n\n  /**\n   * Unregister an observer function.\n   *\n   * @param {function(Array<YEvent>,Transaction):void} f Observer function\n   */\n  unobserveDeep (f) {\n    removeEventHandlerListener(this._dEH, f);\n  }\n\n  /**\n   * @abstract\n   * @return {any}\n   */\n  toJSON () {}\n}\n\n/**\n * @param {AbstractType<any>} type\n * @param {number} start\n * @param {number} end\n * @return {Array<any>}\n *\n * @private\n * @function\n */\nconst typeListSlice = (type, start, end) => {\n  if (start < 0) {\n    start = type._length + start;\n  }\n  if (end < 0) {\n    end = type._length + end;\n  }\n  let len = end - start;\n  const cs = [];\n  let n = type._start;\n  while (n !== null && len > 0) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent();\n      if (c.length <= start) {\n        start -= c.length;\n      } else {\n        for (let i = start; i < c.length && len > 0; i++) {\n          cs.push(c[i]);\n          len--;\n        }\n        start = 0;\n      }\n    }\n    n = n.right;\n  }\n  return cs\n};\n\n/**\n * @param {AbstractType<any>} type\n * @return {Array<any>}\n *\n * @private\n * @function\n */\nconst typeListToArray = type => {\n  const cs = [];\n  let n = type._start;\n  while (n !== null) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent();\n      for (let i = 0; i < c.length; i++) {\n        cs.push(c[i]);\n      }\n    }\n    n = n.right;\n  }\n  return cs\n};\n\n/**\n * @param {AbstractType<any>} type\n * @param {Snapshot} snapshot\n * @return {Array<any>}\n *\n * @private\n * @function\n */\nconst typeListToArraySnapshot = (type, snapshot) => {\n  const cs = [];\n  let n = type._start;\n  while (n !== null) {\n    if (n.countable && isVisible(n, snapshot)) {\n      const c = n.content.getContent();\n      for (let i = 0; i < c.length; i++) {\n        cs.push(c[i]);\n      }\n    }\n    n = n.right;\n  }\n  return cs\n};\n\n/**\n * Executes a provided function on once on overy element of this YArray.\n *\n * @param {AbstractType<any>} type\n * @param {function(any,number,any):void} f A function to execute on every element of this YArray.\n *\n * @private\n * @function\n */\nconst typeListForEach = (type, f) => {\n  let index = 0;\n  let n = type._start;\n  while (n !== null) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent();\n      for (let i = 0; i < c.length; i++) {\n        f(c[i], index++, type);\n      }\n    }\n    n = n.right;\n  }\n};\n\n/**\n * @template C,R\n * @param {AbstractType<any>} type\n * @param {function(C,number,AbstractType<any>):R} f\n * @return {Array<R>}\n *\n * @private\n * @function\n */\nconst typeListMap = (type, f) => {\n  /**\n   * @type {Array<any>}\n   */\n  const result = [];\n  typeListForEach(type, (c, i) => {\n    result.push(f(c, i, type));\n  });\n  return result\n};\n\n/**\n * @param {AbstractType<any>} type\n * @return {IterableIterator<any>}\n *\n * @private\n * @function\n */\nconst typeListCreateIterator = type => {\n  let n = type._start;\n  /**\n   * @type {Array<any>|null}\n   */\n  let currentContent = null;\n  let currentContentIndex = 0;\n  return {\n    [Symbol.iterator] () {\n      return this\n    },\n    next: () => {\n      // find some content\n      if (currentContent === null) {\n        while (n !== null && n.deleted) {\n          n = n.right;\n        }\n        // check if we reached the end, no need to check currentContent, because it does not exist\n        if (n === null) {\n          return {\n            done: true,\n            value: undefined\n          }\n        }\n        // we found n, so we can set currentContent\n        currentContent = n.content.getContent();\n        currentContentIndex = 0;\n        n = n.right; // we used the content of n, now iterate to next\n      }\n      const value = currentContent[currentContentIndex++];\n      // check if we need to empty currentContent\n      if (currentContent.length <= currentContentIndex) {\n        currentContent = null;\n      }\n      return {\n        done: false,\n        value\n      }\n    }\n  }\n};\n\n/**\n * @param {AbstractType<any>} type\n * @param {number} index\n * @return {any}\n *\n * @private\n * @function\n */\nconst typeListGet = (type, index) => {\n  const marker = findMarker(type, index);\n  let n = type._start;\n  if (marker !== null) {\n    n = marker.p;\n    index -= marker.index;\n  }\n  for (; n !== null; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index < n.length) {\n        return n.content.getContent()[index]\n      }\n      index -= n.length;\n    }\n  }\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {Item?} referenceItem\n * @param {Array<Object<string,any>|Array<any>|boolean|number|string|Uint8Array>} content\n *\n * @private\n * @function\n */\nconst typeListInsertGenericsAfter = (transaction, parent, referenceItem, content) => {\n  let left = referenceItem;\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  const store = doc.store;\n  const right = referenceItem === null ? parent._start : referenceItem.right;\n  /**\n   * @type {Array<Object|Array<any>|number>}\n   */\n  let jsonContent = [];\n  const packJsonContent = () => {\n    if (jsonContent.length > 0) {\n      left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));\n      left.integrate(transaction, 0);\n      jsonContent = [];\n    }\n  };\n  content.forEach(c => {\n    switch (c.constructor) {\n      case Number:\n      case Object:\n      case Boolean:\n      case Array:\n      case String:\n        jsonContent.push(c);\n        break\n      default:\n        packJsonContent();\n        switch (c.constructor) {\n          case Uint8Array:\n          case ArrayBuffer:\n            left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(/** @type {Uint8Array} */ (c))));\n            left.integrate(transaction, 0);\n            break\n          case Doc:\n            left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(/** @type {Doc} */ (c)));\n            left.integrate(transaction, 0);\n            break\n          default:\n            if (c instanceof AbstractType) {\n              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c));\n              left.integrate(transaction, 0);\n            } else {\n              throw new Error('Unexpected content type in insert operation')\n            }\n        }\n    }\n  });\n  packJsonContent();\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {number} index\n * @param {Array<Object<string,any>|Array<any>|number|string|Uint8Array>} content\n *\n * @private\n * @function\n */\nconst typeListInsertGenerics = (transaction, parent, index, content) => {\n  if (index === 0) {\n    if (parent._searchMarker) {\n      updateMarkerChanges(parent._searchMarker, index, content.length);\n    }\n    return typeListInsertGenericsAfter(transaction, parent, null, content)\n  }\n  const startIndex = index;\n  const marker = findMarker(parent, index);\n  let n = parent._start;\n  if (marker !== null) {\n    n = marker.p;\n    index -= marker.index;\n    // we need to iterate one to the left so that the algorithm works\n    if (index === 0) {\n      // @todo refactor this as it actually doesn't consider formats\n      n = n.prev; // important! get the left undeleted item so that we can actually decrease index\n      index += (n && n.countable && !n.deleted) ? n.length : 0;\n    }\n  }\n  for (; n !== null; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index <= n.length) {\n        if (index < n.length) {\n          // insert in-between\n          getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));\n        }\n        break\n      }\n      index -= n.length;\n    }\n  }\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, startIndex, content.length);\n  }\n  return typeListInsertGenericsAfter(transaction, parent, n, content)\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {number} index\n * @param {number} length\n *\n * @private\n * @function\n */\nconst typeListDelete = (transaction, parent, index, length) => {\n  if (length === 0) { return }\n  const startIndex = index;\n  const startLength = length;\n  const marker = findMarker(parent, index);\n  let n = parent._start;\n  if (marker !== null) {\n    n = marker.p;\n    index -= marker.index;\n  }\n  // compute the first item to be deleted\n  for (; n !== null && index > 0; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index < n.length) {\n        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));\n      }\n      index -= n.length;\n    }\n  }\n  // delete all items until done\n  while (length > 0 && n !== null) {\n    if (!n.deleted) {\n      if (length < n.length) {\n        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length));\n      }\n      n.delete(transaction);\n      length -= n.length;\n    }\n    n = n.right;\n  }\n  if (length > 0) {\n    throw error__namespace.create('array length exceeded')\n  }\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, startIndex, -startLength + length /* in case we remove the above exception */);\n  }\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {string} key\n *\n * @private\n * @function\n */\nconst typeMapDelete = (transaction, parent, key) => {\n  const c = parent._map.get(key);\n  if (c !== undefined) {\n    c.delete(transaction);\n  }\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @param {Object|number|Array<any>|string|Uint8Array|AbstractType<any>} value\n *\n * @private\n * @function\n */\nconst typeMapSet = (transaction, parent, key, value) => {\n  const left = parent._map.get(key) || null;\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  let content;\n  if (value == null) {\n    content = new ContentAny([value]);\n  } else {\n    switch (value.constructor) {\n      case Number:\n      case Object:\n      case Boolean:\n      case Array:\n      case String:\n        content = new ContentAny([value]);\n        break\n      case Uint8Array:\n        content = new ContentBinary(/** @type {Uint8Array} */ (value));\n        break\n      case Doc:\n        content = new ContentDoc(/** @type {Doc} */ (value));\n        break\n      default:\n        if (value instanceof AbstractType) {\n          content = new ContentType(value);\n        } else {\n          throw new Error('Unexpected content type')\n        }\n    }\n  }\n  new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction, 0);\n};\n\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @return {Object<string,any>|number|Array<any>|string|Uint8Array|AbstractType<any>|undefined}\n *\n * @private\n * @function\n */\nconst typeMapGet = (parent, key) => {\n  const val = parent._map.get(key);\n  return val !== undefined && !val.deleted ? val.content.getContent()[val.length - 1] : undefined\n};\n\n/**\n * @param {AbstractType<any>} parent\n * @return {Object<string,Object<string,any>|number|Array<any>|string|Uint8Array|AbstractType<any>|undefined>}\n *\n * @private\n * @function\n */\nconst typeMapGetAll = (parent) => {\n  /**\n   * @type {Object<string,any>}\n   */\n  const res = {};\n  parent._map.forEach((value, key) => {\n    if (!value.deleted) {\n      res[key] = value.content.getContent()[value.length - 1];\n    }\n  });\n  return res\n};\n\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @return {boolean}\n *\n * @private\n * @function\n */\nconst typeMapHas = (parent, key) => {\n  const val = parent._map.get(key);\n  return val !== undefined && !val.deleted\n};\n\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @param {Snapshot} snapshot\n * @return {Object<string,any>|number|Array<any>|string|Uint8Array|AbstractType<any>|undefined}\n *\n * @private\n * @function\n */\nconst typeMapGetSnapshot = (parent, key, snapshot) => {\n  let v = parent._map.get(key) || null;\n  while (v !== null && (!snapshot.sv.has(v.id.client) || v.id.clock >= (snapshot.sv.get(v.id.client) || 0))) {\n    v = v.left;\n  }\n  return v !== null && isVisible(v, snapshot) ? v.content.getContent()[v.length - 1] : undefined\n};\n\n/**\n * @param {Map<string,Item>} map\n * @return {IterableIterator<Array<any>>}\n *\n * @private\n * @function\n */\nconst createMapIterator = map => iterator__namespace.iteratorFilter(map.entries(), /** @param {any} entry */ entry => !entry[1].deleted);\n\n/**\n * @module YArray\n */\n\n/**\n * Event that describes the changes on a YArray\n * @template T\n */\nclass YArrayEvent extends YEvent {\n  /**\n   * @param {YArray<T>} yarray The changed type\n   * @param {Transaction} transaction The transaction object\n   */\n  constructor (yarray, transaction) {\n    super(yarray, transaction);\n    this._transaction = transaction;\n  }\n}\n\n/**\n * A shared Array implementation.\n * @template T\n * @extends AbstractType<YArrayEvent<T>>\n * @implements {Iterable<T>}\n */\nclass YArray extends AbstractType {\n  constructor () {\n    super();\n    /**\n     * @type {Array<any>?}\n     * @private\n     */\n    this._prelimContent = [];\n    /**\n     * @type {Array<ArraySearchMarker>}\n     */\n    this._searchMarker = [];\n  }\n\n  /**\n   * Construct a new YArray containing the specified items.\n   * @template T\n   * @param {Array<T>} items\n   * @return {YArray<T>}\n   */\n  static from (items) {\n    const a = new YArray();\n    a.push(items);\n    return a\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item);\n    this.insert(0, /** @type {Array<any>} */ (this._prelimContent));\n    this._prelimContent = null;\n  }\n\n  _copy () {\n    return new YArray()\n  }\n\n  /**\n   * @return {YArray<T>}\n   */\n  clone () {\n    const arr = new YArray();\n    arr.insert(0, this.toArray().map(el =>\n      el instanceof AbstractType ? el.clone() : el\n    ));\n    return arr\n  }\n\n  get length () {\n    return this._prelimContent === null ? this._length : this._prelimContent.length\n  }\n\n  /**\n   * Creates YArrayEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    super._callObserver(transaction, parentSubs);\n    callTypeObservers(this, transaction, new YArrayEvent(this, transaction));\n  }\n\n  /**\n   * Inserts new content at an index.\n   *\n   * Important: This function expects an array of content. Not just a content\n   * object. The reason for this \"weirdness\" is that inserting several elements\n   * is very efficient when it is done as a single operation.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  yarray.insert(0, ['a'])\n   *  // Insert numbers 1, 2 at position 1\n   *  yarray.insert(1, [1, 2])\n   *\n   * @param {number} index The index to insert content at.\n   * @param {Array<T>} content The array of content\n   */\n  insert (index, content) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListInsertGenerics(transaction, this, index, content);\n      });\n    } else {\n      /** @type {Array<any>} */ (this._prelimContent).splice(index, 0, ...content);\n    }\n  }\n\n  /**\n   * Appends content to this YArray.\n   *\n   * @param {Array<T>} content Array of content to append.\n   */\n  push (content) {\n    this.insert(this.length, content);\n  }\n\n  /**\n   * Preppends content to this YArray.\n   *\n   * @param {Array<T>} content Array of content to preppend.\n   */\n  unshift (content) {\n    this.insert(0, content);\n  }\n\n  /**\n   * Deletes elements starting from an index.\n   *\n   * @param {number} index Index at which to start deleting elements\n   * @param {number} length The number of elements to remove. Defaults to 1.\n   */\n  delete (index, length = 1) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListDelete(transaction, this, index, length);\n      });\n    } else {\n      /** @type {Array<any>} */ (this._prelimContent).splice(index, length);\n    }\n  }\n\n  /**\n   * Returns the i-th element from a YArray.\n   *\n   * @param {number} index The index of the element to return from the YArray\n   * @return {T}\n   */\n  get (index) {\n    return typeListGet(this, index)\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @return {Array<T>}\n   */\n  toArray () {\n    return typeListToArray(this)\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {Array<T>}\n   */\n  slice (start = 0, end = this.length) {\n    return typeListSlice(this, start, end)\n  }\n\n  /**\n   * Transforms this Shared Type to a JSON object.\n   *\n   * @return {Array<any>}\n   */\n  toJSON () {\n    return this.map(c => c instanceof AbstractType ? c.toJSON() : c)\n  }\n\n  /**\n   * Returns an Array with the result of calling a provided function on every\n   * element of this YArray.\n   *\n   * @template T,M\n   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array\n   * @return {Array<M>} A new array with each element being the result of the\n   *                 callback function\n   */\n  map (f) {\n    return typeListMap(this, /** @type {any} */ (f))\n  }\n\n  /**\n   * Executes a provided function on once on overy element of this YArray.\n   *\n   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.\n   */\n  forEach (f) {\n    typeListForEach(this, f);\n  }\n\n  /**\n   * @return {IterableIterator<T>}\n   */\n  [Symbol.iterator] () {\n    return typeListCreateIterator(this)\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YArrayRefID);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n *\n * @private\n * @function\n */\nconst readYArray = decoder => new YArray();\n\n/**\n * @template T\n * Event that describes the changes on a YMap.\n */\nclass YMapEvent extends YEvent {\n  /**\n   * @param {YMap<T>} ymap The YArray that changed.\n   * @param {Transaction} transaction\n   * @param {Set<any>} subs The keys that changed.\n   */\n  constructor (ymap, transaction, subs) {\n    super(ymap, transaction);\n    this.keysChanged = subs;\n  }\n}\n\n/**\n * @template T number|string|Object|Array|Uint8Array\n * A shared Map implementation.\n *\n * @extends AbstractType<YMapEvent<T>>\n * @implements {Iterable<T>}\n */\nclass YMap extends AbstractType {\n  /**\n   *\n   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap\n   */\n  constructor (entries) {\n    super();\n    /**\n     * @type {Map<string,any>?}\n     * @private\n     */\n    this._prelimContent = null;\n\n    if (entries === undefined) {\n      this._prelimContent = new Map();\n    } else {\n      this._prelimContent = new Map(entries);\n    }\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item)\n    ;/** @type {Map<string, any>} */ (this._prelimContent).forEach((value, key) => {\n      this.set(key, value);\n    });\n    this._prelimContent = null;\n  }\n\n  _copy () {\n    return new YMap()\n  }\n\n  /**\n   * @return {YMap<T>}\n   */\n  clone () {\n    const map = new YMap();\n    this.forEach((value, key) => {\n      map.set(key, value instanceof AbstractType ? value.clone() : value);\n    });\n    return map\n  }\n\n  /**\n   * Creates YMapEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));\n  }\n\n  /**\n   * Transforms this Shared Type to a JSON object.\n   *\n   * @return {Object<string,T>}\n   */\n  toJSON () {\n    /**\n     * @type {Object<string,T>}\n     */\n    const map = {};\n    this._map.forEach((item, key) => {\n      if (!item.deleted) {\n        const v = item.content.getContent()[item.length - 1];\n        map[key] = v instanceof AbstractType ? v.toJSON() : v;\n      }\n    });\n    return map\n  }\n\n  /**\n   * Returns the size of the YMap (count of key/value pairs)\n   *\n   * @return {number}\n   */\n  get size () {\n    return [...createMapIterator(this._map)].length\n  }\n\n  /**\n   * Returns the keys for each element in the YMap Type.\n   *\n   * @return {IterableIterator<string>}\n   */\n  keys () {\n    return iterator__namespace.iteratorMap(createMapIterator(this._map), /** @param {any} v */ v => v[0])\n  }\n\n  /**\n   * Returns the values for each element in the YMap Type.\n   *\n   * @return {IterableIterator<any>}\n   */\n  values () {\n    return iterator__namespace.iteratorMap(createMapIterator(this._map), /** @param {any} v */ v => v[1].content.getContent()[v[1].length - 1])\n  }\n\n  /**\n   * Returns an Iterator of [key, value] pairs\n   *\n   * @return {IterableIterator<any>}\n   */\n  entries () {\n    return iterator__namespace.iteratorMap(createMapIterator(this._map), /** @param {any} v */ v => [v[0], v[1].content.getContent()[v[1].length - 1]])\n  }\n\n  /**\n   * Executes a provided function on once on every key-value pair.\n   *\n   * @param {function(T,string,YMap<T>):void} f A function to execute on every element of this YArray.\n   */\n  forEach (f) {\n    /**\n     * @type {Object<string,T>}\n     */\n    const map = {};\n    this._map.forEach((item, key) => {\n      if (!item.deleted) {\n        f(item.content.getContent()[item.length - 1], key, this);\n      }\n    });\n    return map\n  }\n\n  /**\n   * @return {IterableIterator<T>}\n   */\n  [Symbol.iterator] () {\n    return this.entries()\n  }\n\n  /**\n   * Remove a specified element from this YMap.\n   *\n   * @param {string} key The key of the element to remove.\n   */\n  delete (key) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapDelete(transaction, this, key);\n      });\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimContent).delete(key);\n    }\n  }\n\n  /**\n   * Adds or updates an element with a specified key and value.\n   *\n   * @param {string} key The key of the element to add to this YMap\n   * @param {T} value The value of the element to add\n   */\n  set (key, value) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapSet(transaction, this, key, value);\n      });\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimContent).set(key, value);\n    }\n    return value\n  }\n\n  /**\n   * Returns a specified element from this YMap.\n   *\n   * @param {string} key\n   * @return {T|undefined}\n   */\n  get (key) {\n    return /** @type {any} */ (typeMapGet(this, key))\n  }\n\n  /**\n   * Returns a boolean indicating whether the specified key exists or not.\n   *\n   * @param {string} key The key to test.\n   * @return {boolean}\n   */\n  has (key) {\n    return typeMapHas(this, key)\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YMapRefID);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n *\n * @private\n * @function\n */\nconst readYMap = decoder => new YMap();\n\n/**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */\nconst equalAttrs = (a, b) => a === b || (typeof a === 'object' && typeof b === 'object' && a && b && object__namespace.equalFlat(a, b));\n\nclass ItemTextListPosition {\n  /**\n   * @param {Item|null} left\n   * @param {Item|null} right\n   * @param {number} index\n   * @param {Map<string,any>} currentAttributes\n   */\n  constructor (left, right, index, currentAttributes) {\n    this.left = left;\n    this.right = right;\n    this.index = index;\n    this.currentAttributes = currentAttributes;\n  }\n\n  /**\n   * Only call this if you know that this.right is defined\n   */\n  forward () {\n    if (this.right === null) {\n      error__namespace.unexpectedCase();\n    }\n    switch (this.right.content.constructor) {\n      case ContentEmbed:\n      case ContentString:\n        if (!this.right.deleted) {\n          this.index += this.right.length;\n        }\n        break\n      case ContentFormat:\n        if (!this.right.deleted) {\n          updateCurrentAttributes(this.currentAttributes, /** @type {ContentFormat} */ (this.right.content));\n        }\n        break\n    }\n    this.left = this.right;\n    this.right = this.right.right;\n  }\n}\n\n/**\n * @param {Transaction} transaction\n * @param {ItemTextListPosition} pos\n * @param {number} count steps to move forward\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */\nconst findNextPosition = (transaction, pos, count) => {\n  while (pos.right !== null && count > 0) {\n    switch (pos.right.content.constructor) {\n      case ContentEmbed:\n      case ContentString:\n        if (!pos.right.deleted) {\n          if (count < pos.right.length) {\n            // split right\n            getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count));\n          }\n          pos.index += pos.right.length;\n          count -= pos.right.length;\n        }\n        break\n      case ContentFormat:\n        if (!pos.right.deleted) {\n          updateCurrentAttributes(pos.currentAttributes, /** @type {ContentFormat} */ (pos.right.content));\n        }\n        break\n    }\n    pos.left = pos.right;\n    pos.right = pos.right.right;\n    // pos.forward() - we don't forward because that would halve the performance because we already do the checks above\n  }\n  return pos\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {number} index\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */\nconst findPosition = (transaction, parent, index) => {\n  const currentAttributes = new Map();\n  const marker = findMarker(parent, index);\n  if (marker) {\n    const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);\n    return findNextPosition(transaction, pos, index - marker.index)\n  } else {\n    const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);\n    return findNextPosition(transaction, pos, index)\n  }\n};\n\n/**\n * Negate applied formats\n *\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {Map<string,any>} negatedAttributes\n *\n * @private\n * @function\n */\nconst insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes) => {\n  // check if we really need to remove attributes\n  while (\n    currPos.right !== null && (\n      currPos.right.deleted === true || (\n        currPos.right.content.constructor === ContentFormat &&\n        equalAttrs(negatedAttributes.get(/** @type {ContentFormat} */ (currPos.right.content).key), /** @type {ContentFormat} */ (currPos.right.content).value)\n      )\n    )\n  ) {\n    if (!currPos.right.deleted) {\n      negatedAttributes.delete(/** @type {ContentFormat} */ (currPos.right.content).key);\n    }\n    currPos.forward();\n  }\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  let nextFormat = currPos.left;\n  const right = currPos.right;\n  negatedAttributes.forEach((val, key) => {\n    nextFormat = new Item(createID(ownClientId, getState(doc.store, ownClientId)), nextFormat, nextFormat && nextFormat.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));\n    nextFormat.integrate(transaction, 0);\n    currPos.right = nextFormat;\n  });\n};\n\n/**\n * @param {Map<string,any>} currentAttributes\n * @param {ContentFormat} format\n *\n * @private\n * @function\n */\nconst updateCurrentAttributes = (currentAttributes, format) => {\n  const { key, value } = format;\n  if (value === null) {\n    currentAttributes.delete(key);\n  } else {\n    currentAttributes.set(key, value);\n  }\n};\n\n/**\n * @param {ItemTextListPosition} currPos\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n */\nconst minimizeAttributeChanges = (currPos, attributes) => {\n  // go right while attributes[right.key] === right.value (or right is deleted)\n  while (true) {\n    if (currPos.right === null) {\n      break\n    } else if (currPos.right.deleted || (currPos.right.content.constructor === ContentFormat && equalAttrs(attributes[(/** @type {ContentFormat} */ (currPos.right.content)).key] || null, /** @type {ContentFormat} */ (currPos.right.content).value))) ; else {\n      break\n    }\n    currPos.forward();\n  }\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {Object<string,any>} attributes\n * @return {Map<string,any>}\n *\n * @private\n * @function\n **/\nconst insertAttributes = (transaction, parent, currPos, attributes) => {\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  const negatedAttributes = new Map();\n  // insert format-start items\n  for (const key in attributes) {\n    const val = attributes[key];\n    const currentVal = currPos.currentAttributes.get(key) || null;\n    if (!equalAttrs(currentVal, val)) {\n      // save negated attribute (set null if currentVal undefined)\n      negatedAttributes.set(key, currentVal);\n      const { left, right } = currPos;\n      currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));\n      currPos.right.integrate(transaction, 0);\n      currPos.forward();\n    }\n  }\n  return negatedAttributes\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {string|object} text\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n **/\nconst insertText = (transaction, parent, currPos, text, attributes) => {\n  currPos.currentAttributes.forEach((val, key) => {\n    if (attributes[key] === undefined) {\n      attributes[key] = null;\n    }\n  });\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  minimizeAttributeChanges(currPos, attributes);\n  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);\n  // insert content\n  const content = text.constructor === String ? new ContentString(/** @type {string} */ (text)) : new ContentEmbed(text);\n  let { left, right, index } = currPos;\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength());\n  }\n  right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content);\n  right.integrate(transaction, 0);\n  currPos.right = right;\n  currPos.index = index;\n  currPos.forward();\n  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {number} length\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n */\nconst formatText = (transaction, parent, currPos, length, attributes) => {\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  minimizeAttributeChanges(currPos, attributes);\n  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);\n  // iterate until first non-format or null is found\n  // delete all formats with attributes[format.key] != null\n  while (length > 0 && currPos.right !== null) {\n    if (!currPos.right.deleted) {\n      switch (currPos.right.content.constructor) {\n        case ContentFormat: {\n          const { key, value } = /** @type {ContentFormat} */ (currPos.right.content);\n          const attr = attributes[key];\n          if (attr !== undefined) {\n            if (equalAttrs(attr, value)) {\n              negatedAttributes.delete(key);\n            } else {\n              negatedAttributes.set(key, value);\n            }\n            currPos.right.delete(transaction);\n          }\n          break\n        }\n        case ContentEmbed:\n        case ContentString:\n          if (length < currPos.right.length) {\n            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length));\n          }\n          length -= currPos.right.length;\n          break\n      }\n    }\n    currPos.forward();\n  }\n  // Quill just assumes that the editor starts with a newline and that it always\n  // ends with a newline. We only insert that newline when a new newline is\n  // inserted - i.e when length is bigger than type.length\n  if (length > 0) {\n    let newlines = '';\n    for (; length > 0; length--) {\n      newlines += '\\n';\n    }\n    currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));\n    currPos.right.integrate(transaction, 0);\n    currPos.forward();\n  }\n  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);\n};\n\n/**\n * Call this function after string content has been deleted in order to\n * clean up formatting Items.\n *\n * @param {Transaction} transaction\n * @param {Item} start\n * @param {Item|null} end exclusive end, automatically iterates to the next Content Item\n * @param {Map<string,any>} startAttributes\n * @param {Map<string,any>} endAttributes This attribute is modified!\n * @return {number} The amount of formatting Items deleted.\n *\n * @function\n */\nconst cleanupFormattingGap = (transaction, start, end, startAttributes, endAttributes) => {\n  while (end && end.content.constructor !== ContentString && end.content.constructor !== ContentEmbed) {\n    if (!end.deleted && end.content.constructor === ContentFormat) {\n      updateCurrentAttributes(endAttributes, /** @type {ContentFormat} */ (end.content));\n    }\n    end = end.right;\n  }\n  let cleanups = 0;\n  while (start !== end) {\n    if (!start.deleted) {\n      const content = start.content;\n      switch (content.constructor) {\n        case ContentFormat: {\n          const { key, value } = /** @type {ContentFormat} */ (content);\n          if ((endAttributes.get(key) || null) !== value || (startAttributes.get(key) || null) === value) {\n            // Either this format is overwritten or it is not necessary because the attribute already existed.\n            start.delete(transaction);\n            cleanups++;\n          }\n          break\n        }\n      }\n    }\n    start = /** @type {Item} */ (start.right);\n  }\n  return cleanups\n};\n\n/**\n * @param {Transaction} transaction\n * @param {Item | null} item\n */\nconst cleanupContextlessFormattingGap = (transaction, item) => {\n  // iterate until item.right is null or content\n  while (item && item.right && (item.right.deleted || (item.right.content.constructor !== ContentString && item.right.content.constructor !== ContentEmbed))) {\n    item = item.right;\n  }\n  const attrs = new Set();\n  // iterate back until a content item is found\n  while (item && (item.deleted || (item.content.constructor !== ContentString && item.content.constructor !== ContentEmbed))) {\n    if (!item.deleted && item.content.constructor === ContentFormat) {\n      const key = /** @type {ContentFormat} */ (item.content).key;\n      if (attrs.has(key)) {\n        item.delete(transaction);\n      } else {\n        attrs.add(key);\n      }\n    }\n    item = item.left;\n  }\n};\n\n/**\n * This function is experimental and subject to change / be removed.\n *\n * Ideally, we don't need this function at all. Formatting attributes should be cleaned up\n * automatically after each change. This function iterates twice over the complete YText type\n * and removes unnecessary formatting attributes. This is also helpful for testing.\n *\n * This function won't be exported anymore as soon as there is confidence that the YText type works as intended.\n *\n * @param {YText} type\n * @return {number} How many formatting attributes have been cleaned up.\n */\nconst cleanupYTextFormatting = type => {\n  let res = 0;\n  transact(/** @type {Doc} */ (type.doc), transaction => {\n    let start = /** @type {Item} */ (type._start);\n    let end = type._start;\n    let startAttributes = map__namespace.create();\n    const currentAttributes = map__namespace.copy(startAttributes);\n    while (end) {\n      if (end.deleted === false) {\n        switch (end.content.constructor) {\n          case ContentFormat:\n            updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ (end.content));\n            break\n          case ContentEmbed:\n          case ContentString:\n            res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);\n            startAttributes = map__namespace.copy(currentAttributes);\n            start = end;\n            break\n        }\n      }\n      end = end.right;\n    }\n  });\n  return res\n};\n\n/**\n * @param {Transaction} transaction\n * @param {ItemTextListPosition} currPos\n * @param {number} length\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */\nconst deleteText = (transaction, currPos, length) => {\n  const startLength = length;\n  const startAttrs = map__namespace.copy(currPos.currentAttributes);\n  const start = currPos.right;\n  while (length > 0 && currPos.right !== null) {\n    if (currPos.right.deleted === false) {\n      switch (currPos.right.content.constructor) {\n        case ContentEmbed:\n        case ContentString:\n          if (length < currPos.right.length) {\n            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length));\n          }\n          length -= currPos.right.length;\n          currPos.right.delete(transaction);\n          break\n      }\n    }\n    currPos.forward();\n  }\n  if (start) {\n    cleanupFormattingGap(transaction, start, currPos.right, startAttrs, map__namespace.copy(currPos.currentAttributes));\n  }\n  const parent = /** @type {AbstractType<any>} */ (/** @type {Item} */ (currPos.left || currPos.right).parent);\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length);\n  }\n  return currPos\n};\n\n/**\n * The Quill Delta format represents changes on a text document with\n * formatting information. For mor information visit {@link https://quilljs.com/docs/delta/|Quill Delta}\n *\n * @example\n *   {\n *     ops: [\n *       { insert: 'Gandalf', attributes: { bold: true } },\n *       { insert: ' the ' },\n *       { insert: 'Grey', attributes: { color: '#cccccc' } }\n *     ]\n *   }\n *\n */\n\n/**\n  * Attributes that can be assigned to a selection of text.\n  *\n  * @example\n  *   {\n  *     bold: true,\n  *     font-size: '40px'\n  *   }\n  *\n  * @typedef {Object} TextAttributes\n  */\n\n/**\n * Event that describes the changes on a YText type.\n */\nclass YTextEvent extends YEvent {\n  /**\n   * @param {YText} ytext\n   * @param {Transaction} transaction\n   * @param {Set<any>} subs The keys that changed\n   */\n  constructor (ytext, transaction, subs) {\n    super(ytext, transaction);\n    /**\n     * Whether the children changed.\n     * @type {Boolean}\n     * @private\n     */\n    this.childListChanged = false;\n    /**\n     * Set of all changed attributes.\n     * @type {Set<string>}\n     */\n    this.keysChanged = new Set();\n    subs.forEach((sub) => {\n      if (sub === null) {\n        this.childListChanged = true;\n      } else {\n        this.keysChanged.add(sub);\n      }\n    });\n  }\n\n  /**\n   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}\n   */\n  get changes () {\n    if (this._changes === null) {\n      /**\n       * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}\n       */\n      const changes = {\n        keys: this.keys,\n        delta: this.delta,\n        added: new Set(),\n        deleted: new Set()\n      };\n      this._changes = changes;\n    }\n    return /** @type {any} */ (this._changes)\n  }\n\n  /**\n   * Compute the changes in the delta format.\n   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.\n   *\n   * @type {Array<{insert?:string, delete?:number, retain?:number, attributes?: Object<string,any>}>}\n   *\n   * @public\n   */\n  get delta () {\n    if (this._delta === null) {\n      const y = /** @type {Doc} */ (this.target.doc);\n      /**\n       * @type {Array<{insert?:string, delete?:number, retain?:number, attributes?: Object<string,any>}>}\n       */\n      const delta = [];\n      transact(y, transaction => {\n        const currentAttributes = new Map(); // saves all current attributes for insert\n        const oldAttributes = new Map();\n        let item = this.target._start;\n        /**\n         * @type {string?}\n         */\n        let action = null;\n        /**\n         * @type {Object<string,any>}\n         */\n        const attributes = {}; // counts added or removed new attributes for retain\n        /**\n         * @type {string|object}\n         */\n        let insert = '';\n        let retain = 0;\n        let deleteLen = 0;\n        const addOp = () => {\n          if (action !== null) {\n            /**\n             * @type {any}\n             */\n            let op;\n            switch (action) {\n              case 'delete':\n                op = { delete: deleteLen };\n                deleteLen = 0;\n                break\n              case 'insert':\n                op = { insert };\n                if (currentAttributes.size > 0) {\n                  op.attributes = {};\n                  currentAttributes.forEach((value, key) => {\n                    if (value !== null) {\n                      op.attributes[key] = value;\n                    }\n                  });\n                }\n                insert = '';\n                break\n              case 'retain':\n                op = { retain };\n                if (Object.keys(attributes).length > 0) {\n                  op.attributes = {};\n                  for (const key in attributes) {\n                    op.attributes[key] = attributes[key];\n                  }\n                }\n                retain = 0;\n                break\n            }\n            delta.push(op);\n            action = null;\n          }\n        };\n        while (item !== null) {\n          switch (item.content.constructor) {\n            case ContentEmbed:\n              if (this.adds(item)) {\n                if (!this.deletes(item)) {\n                  addOp();\n                  action = 'insert';\n                  insert = /** @type {ContentEmbed} */ (item.content).embed;\n                  addOp();\n                }\n              } else if (this.deletes(item)) {\n                if (action !== 'delete') {\n                  addOp();\n                  action = 'delete';\n                }\n                deleteLen += 1;\n              } else if (!item.deleted) {\n                if (action !== 'retain') {\n                  addOp();\n                  action = 'retain';\n                }\n                retain += 1;\n              }\n              break\n            case ContentString:\n              if (this.adds(item)) {\n                if (!this.deletes(item)) {\n                  if (action !== 'insert') {\n                    addOp();\n                    action = 'insert';\n                  }\n                  insert += /** @type {ContentString} */ (item.content).str;\n                }\n              } else if (this.deletes(item)) {\n                if (action !== 'delete') {\n                  addOp();\n                  action = 'delete';\n                }\n                deleteLen += item.length;\n              } else if (!item.deleted) {\n                if (action !== 'retain') {\n                  addOp();\n                  action = 'retain';\n                }\n                retain += item.length;\n              }\n              break\n            case ContentFormat: {\n              const { key, value } = /** @type {ContentFormat} */ (item.content);\n              if (this.adds(item)) {\n                if (!this.deletes(item)) {\n                  const curVal = currentAttributes.get(key) || null;\n                  if (!equalAttrs(curVal, value)) {\n                    if (action === 'retain') {\n                      addOp();\n                    }\n                    if (equalAttrs(value, (oldAttributes.get(key) || null))) {\n                      delete attributes[key];\n                    } else {\n                      attributes[key] = value;\n                    }\n                  } else {\n                    item.delete(transaction);\n                  }\n                }\n              } else if (this.deletes(item)) {\n                oldAttributes.set(key, value);\n                const curVal = currentAttributes.get(key) || null;\n                if (!equalAttrs(curVal, value)) {\n                  if (action === 'retain') {\n                    addOp();\n                  }\n                  attributes[key] = curVal;\n                }\n              } else if (!item.deleted) {\n                oldAttributes.set(key, value);\n                const attr = attributes[key];\n                if (attr !== undefined) {\n                  if (!equalAttrs(attr, value)) {\n                    if (action === 'retain') {\n                      addOp();\n                    }\n                    if (value === null) {\n                      attributes[key] = value;\n                    } else {\n                      delete attributes[key];\n                    }\n                  } else {\n                    item.delete(transaction);\n                  }\n                }\n              }\n              if (!item.deleted) {\n                if (action === 'insert') {\n                  addOp();\n                }\n                updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ (item.content));\n              }\n              break\n            }\n          }\n          item = item.right;\n        }\n        addOp();\n        while (delta.length > 0) {\n          const lastOp = delta[delta.length - 1];\n          if (lastOp.retain !== undefined && lastOp.attributes === undefined) {\n            // retain delta's if they don't assign attributes\n            delta.pop();\n          } else {\n            break\n          }\n        }\n      });\n      this._delta = delta;\n    }\n    return /** @type {any} */ (this._delta)\n  }\n}\n\n/**\n * Type that represents text with formatting information.\n *\n * This type replaces y-richtext as this implementation is able to handle\n * block formats (format information on a paragraph), embeds (complex elements\n * like pictures and videos), and text formats (**bold**, *italic*).\n *\n * @extends AbstractType<YTextEvent>\n */\nclass YText extends AbstractType {\n  /**\n   * @param {String} [string] The initial value of the YText.\n   */\n  constructor (string) {\n    super();\n    /**\n     * Array of pending operations on this type\n     * @type {Array<function():void>?}\n     */\n    this._pending = string !== undefined ? [() => this.insert(0, string)] : [];\n    /**\n     * @type {Array<ArraySearchMarker>}\n     */\n    this._searchMarker = [];\n  }\n\n  /**\n   * Number of characters of this text type.\n   *\n   * @type {number}\n   */\n  get length () {\n    return this._length\n  }\n\n  /**\n   * @param {Doc} y\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item);\n    try {\n      /** @type {Array<function>} */ (this._pending).forEach(f => f());\n    } catch (e) {\n      console.error(e);\n    }\n    this._pending = null;\n  }\n\n  _copy () {\n    return new YText()\n  }\n\n  /**\n   * @return {YText}\n   */\n  clone () {\n    const text = new YText();\n    text.applyDelta(this.toDelta());\n    return text\n  }\n\n  /**\n   * Creates YTextEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    super._callObserver(transaction, parentSubs);\n    const event = new YTextEvent(this, transaction, parentSubs);\n    const doc = transaction.doc;\n    callTypeObservers(this, transaction, event);\n    // If a remote change happened, we try to cleanup potential formatting duplicates.\n    if (!transaction.local) {\n      // check if another formatting item was inserted\n      let foundFormattingItem = false;\n      for (const [client, afterClock] of transaction.afterState.entries()) {\n        const clock = transaction.beforeState.get(client) || 0;\n        if (afterClock === clock) {\n          continue\n        }\n        iterateStructs(transaction, /** @type {Array<Item|GC>} */ (doc.store.clients.get(client)), clock, afterClock, item => {\n          if (!item.deleted && /** @type {Item} */ (item).content.constructor === ContentFormat) {\n            foundFormattingItem = true;\n          }\n        });\n        if (foundFormattingItem) {\n          break\n        }\n      }\n      if (!foundFormattingItem) {\n        iterateDeletedStructs(transaction, transaction.deleteSet, item => {\n          if (item instanceof GC || foundFormattingItem) {\n            return\n          }\n          if (item.parent === this && item.content.constructor === ContentFormat) {\n            foundFormattingItem = true;\n          }\n        });\n      }\n      transact(doc, (t) => {\n        if (foundFormattingItem) {\n          // If a formatting item was inserted, we simply clean the whole type.\n          // We need to compute currentAttributes for the current position anyway.\n          cleanupYTextFormatting(this);\n        } else {\n          // If no formatting attribute was inserted, we can make due with contextless\n          // formatting cleanups.\n          // Contextless: it is not necessary to compute currentAttributes for the affected position.\n          iterateDeletedStructs(t, t.deleteSet, item => {\n            if (item instanceof GC) {\n              return\n            }\n            if (item.parent === this) {\n              cleanupContextlessFormattingGap(t, item);\n            }\n          });\n        }\n      });\n    }\n  }\n\n  /**\n   * Returns the unformatted string representation of this YText type.\n   *\n   * @public\n   */\n  toString () {\n    let str = '';\n    /**\n     * @type {Item|null}\n     */\n    let n = this._start;\n    while (n !== null) {\n      if (!n.deleted && n.countable && n.content.constructor === ContentString) {\n        str += /** @type {ContentString} */ (n.content).str;\n      }\n      n = n.right;\n    }\n    return str\n  }\n\n  /**\n   * Returns the unformatted string representation of this YText type.\n   *\n   * @return {string}\n   * @public\n   */\n  toJSON () {\n    return this.toString()\n  }\n\n  /**\n   * Apply a {@link Delta} on this shared YText type.\n   *\n   * @param {any} delta The changes to apply on this element.\n   * @param {object}  [opts]\n   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.\n   *\n   *\n   * @public\n   */\n  applyDelta (delta, { sanitize = true } = {}) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        const currPos = new ItemTextListPosition(null, this._start, 0, new Map());\n        for (let i = 0; i < delta.length; i++) {\n          const op = delta[i];\n          if (op.insert !== undefined) {\n            // Quill assumes that the content starts with an empty paragraph.\n            // Yjs/Y.Text assumes that it starts empty. We always hide that\n            // there is a newline at the end of the content.\n            // If we omit this step, clients will see a different number of\n            // paragraphs, but nothing bad will happen.\n            const ins = (!sanitize && typeof op.insert === 'string' && i === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === '\\n') ? op.insert.slice(0, -1) : op.insert;\n            if (typeof ins !== 'string' || ins.length > 0) {\n              insertText(transaction, this, currPos, ins, op.attributes || {});\n            }\n          } else if (op.retain !== undefined) {\n            formatText(transaction, this, currPos, op.retain, op.attributes || {});\n          } else if (op.delete !== undefined) {\n            deleteText(transaction, currPos, op.delete);\n          }\n        }\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.applyDelta(delta));\n    }\n  }\n\n  /**\n   * Returns the Delta representation of this YText type.\n   *\n   * @param {Snapshot} [snapshot]\n   * @param {Snapshot} [prevSnapshot]\n   * @param {function('removed' | 'added', ID):any} [computeYChange]\n   * @return {any} The Delta representation of this type.\n   *\n   * @public\n   */\n  toDelta (snapshot, prevSnapshot, computeYChange) {\n    /**\n     * @type{Array<any>}\n     */\n    const ops = [];\n    const currentAttributes = new Map();\n    const doc = /** @type {Doc} */ (this.doc);\n    let str = '';\n    let n = this._start;\n    function packStr () {\n      if (str.length > 0) {\n        // pack str with attributes to ops\n        /**\n         * @type {Object<string,any>}\n         */\n        const attributes = {};\n        let addAttributes = false;\n        currentAttributes.forEach((value, key) => {\n          addAttributes = true;\n          attributes[key] = value;\n        });\n        /**\n         * @type {Object<string,any>}\n         */\n        const op = { insert: str };\n        if (addAttributes) {\n          op.attributes = attributes;\n        }\n        ops.push(op);\n        str = '';\n      }\n    }\n    // snapshots are merged again after the transaction, so we need to keep the\n    // transalive until we are done\n    transact(doc, transaction => {\n      if (snapshot) {\n        splitSnapshotAffectedStructs(transaction, snapshot);\n      }\n      if (prevSnapshot) {\n        splitSnapshotAffectedStructs(transaction, prevSnapshot);\n      }\n      while (n !== null) {\n        if (isVisible(n, snapshot) || (prevSnapshot !== undefined && isVisible(n, prevSnapshot))) {\n          switch (n.content.constructor) {\n            case ContentString: {\n              const cur = currentAttributes.get('ychange');\n              if (snapshot !== undefined && !isVisible(n, snapshot)) {\n                if (cur === undefined || cur.user !== n.id.client || cur.state !== 'removed') {\n                  packStr();\n                  currentAttributes.set('ychange', computeYChange ? computeYChange('removed', n.id) : { type: 'removed' });\n                }\n              } else if (prevSnapshot !== undefined && !isVisible(n, prevSnapshot)) {\n                if (cur === undefined || cur.user !== n.id.client || cur.state !== 'added') {\n                  packStr();\n                  currentAttributes.set('ychange', computeYChange ? computeYChange('added', n.id) : { type: 'added' });\n                }\n              } else if (cur !== undefined) {\n                packStr();\n                currentAttributes.delete('ychange');\n              }\n              str += /** @type {ContentString} */ (n.content).str;\n              break\n            }\n            case ContentEmbed: {\n              packStr();\n              /**\n               * @type {Object<string,any>}\n               */\n              const op = {\n                insert: /** @type {ContentEmbed} */ (n.content).embed\n              };\n              if (currentAttributes.size > 0) {\n                const attrs = /** @type {Object<string,any>} */ ({});\n                op.attributes = attrs;\n                currentAttributes.forEach((value, key) => {\n                  attrs[key] = value;\n                });\n              }\n              ops.push(op);\n              break\n            }\n            case ContentFormat:\n              if (isVisible(n, snapshot)) {\n                packStr();\n                updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ (n.content));\n              }\n              break\n          }\n        }\n        n = n.right;\n      }\n      packStr();\n    }, splitSnapshotAffectedStructs);\n    return ops\n  }\n\n  /**\n   * Insert text at a given index.\n   *\n   * @param {number} index The index at which to start inserting.\n   * @param {String} text The text to insert at the specified position.\n   * @param {TextAttributes} [attributes] Optionally define some formatting\n   *                                    information to apply on the inserted\n   *                                    Text.\n   * @public\n   */\n  insert (index, text, attributes) {\n    if (text.length <= 0) {\n      return\n    }\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, transaction => {\n        const pos = findPosition(transaction, this, index);\n        if (!attributes) {\n          attributes = {};\n          // @ts-ignore\n          pos.currentAttributes.forEach((v, k) => { attributes[k] = v; });\n        }\n        insertText(transaction, this, pos, text, attributes);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.insert(index, text, attributes));\n    }\n  }\n\n  /**\n   * Inserts an embed at a index.\n   *\n   * @param {number} index The index to insert the embed at.\n   * @param {Object} embed The Object that represents the embed.\n   * @param {TextAttributes} attributes Attribute information to apply on the\n   *                                    embed\n   *\n   * @public\n   */\n  insertEmbed (index, embed, attributes = {}) {\n    if (embed.constructor !== Object) {\n      throw new Error('Embed must be an Object')\n    }\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, transaction => {\n        const pos = findPosition(transaction, this, index);\n        insertText(transaction, this, pos, embed, attributes);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.insertEmbed(index, embed, attributes));\n    }\n  }\n\n  /**\n   * Deletes text starting from an index.\n   *\n   * @param {number} index Index at which to start deleting.\n   * @param {number} length The number of characters to remove. Defaults to 1.\n   *\n   * @public\n   */\n  delete (index, length) {\n    if (length === 0) {\n      return\n    }\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, transaction => {\n        deleteText(transaction, findPosition(transaction, this, index), length);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.delete(index, length));\n    }\n  }\n\n  /**\n   * Assigns properties to a range of text.\n   *\n   * @param {number} index The position where to start formatting.\n   * @param {number} length The amount of characters to assign properties to.\n   * @param {TextAttributes} attributes Attribute information to apply on the\n   *                                    text.\n   *\n   * @public\n   */\n  format (index, length, attributes) {\n    if (length === 0) {\n      return\n    }\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, transaction => {\n        const pos = findPosition(transaction, this, index);\n        if (pos.right === null) {\n          return\n        }\n        formatText(transaction, this, pos, length, attributes);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.format(index, length, attributes));\n    }\n  }\n\n  /**\n   * Removes an attribute.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that is to be removed.\n   *\n   * @public\n   */\n  removeAttribute (attributeName) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapDelete(transaction, this, attributeName);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.removeAttribute(attributeName));\n    }\n  }\n\n  /**\n   * Sets or updates an attribute.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that is to be set.\n   * @param {any} attributeValue The attribute value that is to be set.\n   *\n   * @public\n   */\n  setAttribute (attributeName, attributeValue) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapSet(transaction, this, attributeName, attributeValue);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.setAttribute(attributeName, attributeValue));\n    }\n  }\n\n  /**\n   * Returns an attribute value that belongs to the attribute name.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that identifies the\n   *                               queried value.\n   * @return {any} The queried attribute value.\n   *\n   * @public\n   */\n  getAttribute (attributeName) {\n    return /** @type {any} */ (typeMapGet(this, attributeName))\n  }\n\n  /**\n   * Returns all attribute name/value pairs in a JSON Object.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {Snapshot} [snapshot]\n   * @return {Object<string, any>} A JSON Object that describes the attributes.\n   *\n   * @public\n   */\n  getAttributes (snapshot) {\n    return typeMapGetAll(this)\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YTextRefID);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YText}\n *\n * @private\n * @function\n */\nconst readYText = decoder => new YText();\n\n/**\n * @module YXml\n */\n\n/**\n * Define the elements to which a set of CSS queries apply.\n * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors|CSS_Selectors}\n *\n * @example\n *   query = '.classSelector'\n *   query = 'nodeSelector'\n *   query = '#idSelector'\n *\n * @typedef {string} CSS_Selector\n */\n\n/**\n * Dom filter function.\n *\n * @callback domFilter\n * @param {string} nodeName The nodeName of the element\n * @param {Map} attributes The map of attributes.\n * @return {boolean} Whether to include the Dom node in the YXmlElement.\n */\n\n/**\n * Represents a subset of the nodes of a YXmlElement / YXmlFragment and a\n * position within them.\n *\n * Can be created with {@link YXmlFragment#createTreeWalker}\n *\n * @public\n * @implements {Iterable<YXmlElement|YXmlText|YXmlElement|YXmlHook>}\n */\nclass YXmlTreeWalker {\n  /**\n   * @param {YXmlFragment | YXmlElement} root\n   * @param {function(AbstractType<any>):boolean} [f]\n   */\n  constructor (root, f = () => true) {\n    this._filter = f;\n    this._root = root;\n    /**\n     * @type {Item}\n     */\n    this._currentNode = /** @type {Item} */ (root._start);\n    this._firstCall = true;\n  }\n\n  [Symbol.iterator] () {\n    return this\n  }\n\n  /**\n   * Get the next node.\n   *\n   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.\n   *\n   * @public\n   */\n  next () {\n    /**\n     * @type {Item|null}\n     */\n    let n = this._currentNode;\n    let type = n && n.content && /** @type {any} */ (n.content).type;\n    if (n !== null && (!this._firstCall || n.deleted || !this._filter(type))) { // if first call, we check if we can use the first item\n      do {\n        type = /** @type {any} */ (n.content).type;\n        if (!n.deleted && (type.constructor === YXmlElement || type.constructor === YXmlFragment) && type._start !== null) {\n          // walk down in the tree\n          n = type._start;\n        } else {\n          // walk right or up in the tree\n          while (n !== null) {\n            if (n.right !== null) {\n              n = n.right;\n              break\n            } else if (n.parent === this._root) {\n              n = null;\n            } else {\n              n = /** @type {AbstractType<any>} */ (n.parent)._item;\n            }\n          }\n        }\n      } while (n !== null && (n.deleted || !this._filter(/** @type {ContentType} */ (n.content).type)))\n    }\n    this._firstCall = false;\n    if (n === null) {\n      // @ts-ignore\n      return { value: undefined, done: true }\n    }\n    this._currentNode = n;\n    return { value: /** @type {any} */ (n.content).type, done: false }\n  }\n}\n\n/**\n * Represents a list of {@link YXmlElement}.and {@link YXmlText} types.\n * A YxmlFragment is similar to a {@link YXmlElement}, but it does not have a\n * nodeName and it does not have attributes. Though it can be bound to a DOM\n * element - in this case the attributes and the nodeName are not shared.\n *\n * @public\n * @extends AbstractType<YXmlEvent>\n */\nclass YXmlFragment extends AbstractType {\n  constructor () {\n    super();\n    /**\n     * @type {Array<any>|null}\n     */\n    this._prelimContent = [];\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get firstChild () {\n    const first = this._first;\n    return first ? first.content.getContent()[0] : null\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item);\n    this.insert(0, /** @type {Array<any>} */ (this._prelimContent));\n    this._prelimContent = null;\n  }\n\n  _copy () {\n    return new YXmlFragment()\n  }\n\n  /**\n   * @return {YXmlFragment}\n   */\n  clone () {\n    const el = new YXmlFragment();\n    // @ts-ignore\n    el.insert(0, el.toArray().map(item => item instanceof AbstractType ? item.clone() : item));\n    return el\n  }\n\n  get length () {\n    return this._prelimContent === null ? this._length : this._prelimContent.length\n  }\n\n  /**\n   * Create a subtree of childNodes.\n   *\n   * @example\n   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')\n   * for (let node in walker) {\n   *   // `node` is a div node\n   *   nop(node)\n   * }\n   *\n   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and\n   *                          returns a Boolean indicating whether the child\n   *                          is to be included in the subtree.\n   * @return {YXmlTreeWalker} A subtree and a position within it.\n   *\n   * @public\n   */\n  createTreeWalker (filter) {\n    return new YXmlTreeWalker(this, filter)\n  }\n\n  /**\n   * Returns the first YXmlElement that matches the query.\n   * Similar to DOM's {@link querySelector}.\n   *\n   * Query support:\n   *   - tagname\n   * TODO:\n   *   - id\n   *   - attribute\n   *\n   * @param {CSS_Selector} query The query on the children.\n   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.\n   *\n   * @public\n   */\n  querySelector (query) {\n    query = query.toUpperCase();\n    // @ts-ignore\n    const iterator = new YXmlTreeWalker(this, element => element.nodeName && element.nodeName.toUpperCase() === query);\n    const next = iterator.next();\n    if (next.done) {\n      return null\n    } else {\n      return next.value\n    }\n  }\n\n  /**\n   * Returns all YXmlElements that match the query.\n   * Similar to Dom's {@link querySelectorAll}.\n   *\n   * @todo Does not yet support all queries. Currently only query by tagName.\n   *\n   * @param {CSS_Selector} query The query on the children\n   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.\n   *\n   * @public\n   */\n  querySelectorAll (query) {\n    query = query.toUpperCase();\n    // @ts-ignore\n    return Array.from(new YXmlTreeWalker(this, element => element.nodeName && element.nodeName.toUpperCase() === query))\n  }\n\n  /**\n   * Creates YXmlEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));\n  }\n\n  /**\n   * Get the string representation of all the children of this YXmlFragment.\n   *\n   * @return {string} The string representation of all children.\n   */\n  toString () {\n    return typeListMap(this, xml => xml.toString()).join('')\n  }\n\n  /**\n   * @return {string}\n   */\n  toJSON () {\n    return this.toString()\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks = {}, binding) {\n    const fragment = _document.createDocumentFragment();\n    if (binding !== undefined) {\n      binding._createAssociation(fragment, this);\n    }\n    typeListForEach(this, xmlType => {\n      fragment.insertBefore(xmlType.toDOM(_document, hooks, binding), null);\n    });\n    return fragment\n  }\n\n  /**\n   * Inserts new content at an index.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  xml.insert(0, [new Y.XmlText('text')])\n   *\n   * @param {number} index The index to insert content at\n   * @param {Array<YXmlElement|YXmlText>} content The array of content\n   */\n  insert (index, content) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListInsertGenerics(transaction, this, index, content);\n      });\n    } else {\n      // @ts-ignore _prelimContent is defined because this is not yet integrated\n      this._prelimContent.splice(index, 0, ...content);\n    }\n  }\n\n  /**\n   * Inserts new content at an index.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  xml.insert(0, [new Y.XmlText('text')])\n   *\n   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at\n   * @param {Array<YXmlElement|YXmlText>} content The array of content\n   */\n  insertAfter (ref, content) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        const refItem = (ref && ref instanceof AbstractType) ? ref._item : ref;\n        typeListInsertGenericsAfter(transaction, this, refItem, content);\n      });\n    } else {\n      const pc = /** @type {Array<any>} */ (this._prelimContent);\n      const index = ref === null ? 0 : pc.findIndex(el => el === ref) + 1;\n      if (index === 0 && ref !== null) {\n        throw error__namespace.create('Reference item not found')\n      }\n      pc.splice(index, 0, ...content);\n    }\n  }\n\n  /**\n   * Deletes elements starting from an index.\n   *\n   * @param {number} index Index at which to start deleting elements\n   * @param {number} [length=1] The number of elements to remove. Defaults to 1.\n   */\n  delete (index, length = 1) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListDelete(transaction, this, index, length);\n      });\n    } else {\n      // @ts-ignore _prelimContent is defined because this is not yet integrated\n      this._prelimContent.splice(index, length);\n    }\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @return {Array<YXmlElement|YXmlText|YXmlHook>}\n   */\n  toArray () {\n    return typeListToArray(this)\n  }\n\n  /**\n   * Appends content to this YArray.\n   *\n   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.\n   */\n  push (content) {\n    this.insert(this.length, content);\n  }\n\n  /**\n   * Preppends content to this YArray.\n   *\n   * @param {Array<YXmlElement|YXmlText>} content Array of content to preppend.\n   */\n  unshift (content) {\n    this.insert(0, content);\n  }\n\n  /**\n   * Returns the i-th element from a YArray.\n   *\n   * @param {number} index The index of the element to return from the YArray\n   * @return {YXmlElement|YXmlText}\n   */\n  get (index) {\n    return typeListGet(this, index)\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {Array<YXmlElement|YXmlText>}\n   */\n  slice (start = 0, end = this.length) {\n    return typeListSlice(this, start, end)\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlFragmentRefID);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlFragment}\n *\n * @private\n * @function\n */\nconst readYXmlFragment = decoder => new YXmlFragment();\n\n/**\n * An YXmlElement imitates the behavior of a\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}.\n *\n * * An YXmlElement has attributes (key value pairs)\n * * An YXmlElement has childElements that must inherit from YXmlElement\n */\nclass YXmlElement extends YXmlFragment {\n  constructor (nodeName = 'UNDEFINED') {\n    super();\n    this.nodeName = nodeName;\n    /**\n     * @type {Map<string, any>|null}\n     */\n    this._prelimAttrs = new Map();\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get nextSibling () {\n    const n = this._item ? this._item.next : null;\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get prevSibling () {\n    const n = this._item ? this._item.prev : null;\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item)\n    ;(/** @type {Map<string, any>} */ (this._prelimAttrs)).forEach((value, key) => {\n      this.setAttribute(key, value);\n    });\n    this._prelimAttrs = null;\n  }\n\n  /**\n   * Creates an Item with the same effect as this Item (without position effect)\n   *\n   * @return {YXmlElement}\n   */\n  _copy () {\n    return new YXmlElement(this.nodeName)\n  }\n\n  /**\n   * @return {YXmlElement}\n   */\n  clone () {\n    const el = new YXmlElement(this.nodeName);\n    const attrs = this.getAttributes();\n    for (const key in attrs) {\n      el.setAttribute(key, attrs[key]);\n    }\n    // @ts-ignore\n    el.insert(0, el.toArray().map(item => item instanceof AbstractType ? item.clone() : item));\n    return el\n  }\n\n  /**\n   * Returns the XML serialization of this YXmlElement.\n   * The attributes are ordered by attribute-name, so you can easily use this\n   * method to compare YXmlElements\n   *\n   * @return {string} The string representation of this type.\n   *\n   * @public\n   */\n  toString () {\n    const attrs = this.getAttributes();\n    const stringBuilder = [];\n    const keys = [];\n    for (const key in attrs) {\n      keys.push(key);\n    }\n    keys.sort();\n    const keysLen = keys.length;\n    for (let i = 0; i < keysLen; i++) {\n      const key = keys[i];\n      stringBuilder.push(key + '=\"' + attrs[key] + '\"');\n    }\n    const nodeName = this.nodeName.toLocaleLowerCase();\n    const attrsString = stringBuilder.length > 0 ? ' ' + stringBuilder.join(' ') : '';\n    return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`\n  }\n\n  /**\n   * Removes an attribute from this YXmlElement.\n   *\n   * @param {String} attributeName The attribute name that is to be removed.\n   *\n   * @public\n   */\n  removeAttribute (attributeName) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapDelete(transaction, this, attributeName);\n      });\n    } else {\n      /** @type {Map<string,any>} */ (this._prelimAttrs).delete(attributeName);\n    }\n  }\n\n  /**\n   * Sets or updates an attribute.\n   *\n   * @param {String} attributeName The attribute name that is to be set.\n   * @param {String} attributeValue The attribute value that is to be set.\n   *\n   * @public\n   */\n  setAttribute (attributeName, attributeValue) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapSet(transaction, this, attributeName, attributeValue);\n      });\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimAttrs).set(attributeName, attributeValue);\n    }\n  }\n\n  /**\n   * Returns an attribute value that belongs to the attribute name.\n   *\n   * @param {String} attributeName The attribute name that identifies the\n   *                               queried value.\n   * @return {String} The queried attribute value.\n   *\n   * @public\n   */\n  getAttribute (attributeName) {\n    return /** @type {any} */ (typeMapGet(this, attributeName))\n  }\n\n  /**\n   * Returns all attribute name/value pairs in a JSON Object.\n   *\n   * @param {Snapshot} [snapshot]\n   * @return {Object<string, any>} A JSON Object that describes the attributes.\n   *\n   * @public\n   */\n  getAttributes (snapshot) {\n    return typeMapGetAll(this)\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks = {}, binding) {\n    const dom = _document.createElement(this.nodeName);\n    const attrs = this.getAttributes();\n    for (const key in attrs) {\n      dom.setAttribute(key, attrs[key]);\n    }\n    typeListForEach(this, yxml => {\n      dom.appendChild(yxml.toDOM(_document, hooks, binding));\n    });\n    if (binding !== undefined) {\n      binding._createAssociation(dom, this);\n    }\n    return dom\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlElementRefID);\n    encoder.writeKey(this.nodeName);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlElement}\n *\n * @function\n */\nconst readYXmlElement = decoder => new YXmlElement(decoder.readKey());\n\n/**\n * An Event that describes changes on a YXml Element or Yxml Fragment\n */\nclass YXmlEvent extends YEvent {\n  /**\n   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.\n   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the\n   *                   child list changed.\n   * @param {Transaction} transaction The transaction instance with wich the\n   *                                  change was created.\n   */\n  constructor (target, subs, transaction) {\n    super(target, transaction);\n    /**\n     * Whether the children changed.\n     * @type {Boolean}\n     * @private\n     */\n    this.childListChanged = false;\n    /**\n     * Set of all changed attributes.\n     * @type {Set<string>}\n     */\n    this.attributesChanged = new Set();\n    subs.forEach((sub) => {\n      if (sub === null) {\n        this.childListChanged = true;\n      } else {\n        this.attributesChanged.add(sub);\n      }\n    });\n  }\n}\n\n/**\n * You can manage binding to a custom type with YXmlHook.\n *\n * @extends {YMap<any>}\n */\nclass YXmlHook extends YMap {\n  /**\n   * @param {string} hookName nodeName of the Dom Node.\n   */\n  constructor (hookName) {\n    super();\n    /**\n     * @type {string}\n     */\n    this.hookName = hookName;\n  }\n\n  /**\n   * Creates an Item with the same effect as this Item (without position effect)\n   */\n  _copy () {\n    return new YXmlHook(this.hookName)\n  }\n\n  /**\n   * @return {YXmlHook}\n   */\n  clone () {\n    const el = new YXmlHook(this.hookName);\n    this.forEach((value, key) => {\n      el.set(key, value);\n    });\n    return el\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type\n   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks = {}, binding) {\n    const hook = hooks[this.hookName];\n    let dom;\n    if (hook !== undefined) {\n      dom = hook.createDom(this);\n    } else {\n      dom = document.createElement(this.hookName);\n    }\n    dom.setAttribute('data-yjs-hook', this.hookName);\n    if (binding !== undefined) {\n      binding._createAssociation(dom, this);\n    }\n    return dom\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlHookRefID);\n    encoder.writeKey(this.hookName);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlHook}\n *\n * @private\n * @function\n */\nconst readYXmlHook = decoder =>\n  new YXmlHook(decoder.readKey());\n\n/**\n * Represents text in a Dom Element. In the future this type will also handle\n * simple formatting information like bold and italic.\n */\nclass YXmlText extends YText {\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get nextSibling () {\n    const n = this._item ? this._item.next : null;\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get prevSibling () {\n    const n = this._item ? this._item.prev : null;\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  _copy () {\n    return new YXmlText()\n  }\n\n  /**\n   * @return {YXmlText}\n   */\n  clone () {\n    const text = new YXmlText();\n    text.applyDelta(this.toDelta());\n    return text\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlText.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks, binding) {\n    const dom = _document.createTextNode(this.toString());\n    if (binding !== undefined) {\n      binding._createAssociation(dom, this);\n    }\n    return dom\n  }\n\n  toString () {\n    // @ts-ignore\n    return this.toDelta().map(delta => {\n      const nestedNodes = [];\n      for (const nodeName in delta.attributes) {\n        const attrs = [];\n        for (const key in delta.attributes[nodeName]) {\n          attrs.push({ key, value: delta.attributes[nodeName][key] });\n        }\n        // sort attributes to get a unique order\n        attrs.sort((a, b) => a.key < b.key ? -1 : 1);\n        nestedNodes.push({ nodeName, attrs });\n      }\n      // sort node order to get a unique order\n      nestedNodes.sort((a, b) => a.nodeName < b.nodeName ? -1 : 1);\n      // now convert to dom string\n      let str = '';\n      for (let i = 0; i < nestedNodes.length; i++) {\n        const node = nestedNodes[i];\n        str += `<${node.nodeName}`;\n        for (let j = 0; j < node.attrs.length; j++) {\n          const attr = node.attrs[j];\n          str += ` ${attr.key}=\"${attr.value}\"`;\n        }\n        str += '>';\n      }\n      str += delta.insert;\n      for (let i = nestedNodes.length - 1; i >= 0; i--) {\n        str += `</${nestedNodes[i].nodeName}>`;\n      }\n      return str\n    }).join('')\n  }\n\n  /**\n   * @return {string}\n   */\n  toJSON () {\n    return this.toString()\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlTextRefID);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlText}\n *\n * @private\n * @function\n */\nconst readYXmlText = decoder => new YXmlText();\n\nclass AbstractStruct {\n  /**\n   * @param {ID} id\n   * @param {number} length\n   */\n  constructor (id, length) {\n    this.id = id;\n    this.length = length;\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get deleted () {\n    throw error__namespace.methodUnimplemented()\n  }\n\n  /**\n   * Merge this struct with the item to the right.\n   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.\n   * Also this method does *not* remove right from StructStore!\n   * @param {AbstractStruct} right\n   * @return {boolean} wether this merged with right\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   * @param {number} offset\n   * @param {number} encodingRef\n   */\n  write (encoder, offset, encodingRef) {\n    throw error__namespace.methodUnimplemented()\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    throw error__namespace.methodUnimplemented()\n  }\n}\n\nconst structGCRefNumber = 0;\n\n/**\n * @private\n */\nclass GC extends AbstractStruct {\n  get deleted () {\n    return true\n  }\n\n  delete () {}\n\n  /**\n   * @param {GC} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    if (this.constructor !== right.constructor) {\n      return false\n    }\n    this.length += right.length;\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    if (offset > 0) {\n      this.id.clock += offset;\n      this.length -= offset;\n    }\n    addStruct(transaction.doc.store, this);\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeInfo(structGCRefNumber);\n    encoder.writeLen(this.length - offset);\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */\n  getMissing (transaction, store) {\n    return null\n  }\n}\n\nclass ContentBinary {\n  /**\n   * @param {Uint8Array} content\n   */\n  constructor (content) {\n    this.content = content;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.content]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentBinary}\n   */\n  copy () {\n    return new ContentBinary(this.content)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentBinary}\n   */\n  splice (offset) {\n    throw error__namespace.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentBinary} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeBuf(this.content);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 3\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder\n * @return {ContentBinary}\n */\nconst readContentBinary = decoder => new ContentBinary(decoder.readBuf());\n\nclass ContentDeleted {\n  /**\n   * @param {number} len\n   */\n  constructor (len) {\n    this.len = len;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.len\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return []\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return false\n  }\n\n  /**\n   * @return {ContentDeleted}\n   */\n  copy () {\n    return new ContentDeleted(this.len)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentDeleted}\n   */\n  splice (offset) {\n    const right = new ContentDeleted(this.len - offset);\n    this.len = offset;\n    return right\n  }\n\n  /**\n   * @param {ContentDeleted} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.len += right.len;\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);\n    item.markDeleted();\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeLen(this.len - offset);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 1\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder\n * @return {ContentDeleted}\n */\nconst readContentDeleted = decoder => new ContentDeleted(decoder.readLen());\n\n/**\n * @private\n */\nclass ContentDoc {\n  /**\n   * @param {Doc} doc\n   */\n  constructor (doc) {\n    if (doc._item) {\n      console.error('This document was already integrated as a sub-document. You should create a second instance instead with the same guid.');\n    }\n    /**\n     * @type {Doc}\n     */\n    this.doc = doc;\n    /**\n     * @type {any}\n     */\n    const opts = {};\n    this.opts = opts;\n    if (!doc.gc) {\n      opts.gc = false;\n    }\n    if (doc.autoLoad) {\n      opts.autoLoad = true;\n    }\n    if (doc.meta !== null) {\n      opts.meta = doc.meta;\n    }\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.doc]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentDoc}\n   */\n  copy () {\n    return new ContentDoc(this.doc)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentDoc}\n   */\n  splice (offset) {\n    throw error__namespace.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentDoc} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    // this needs to be reflected in doc.destroy as well\n    this.doc._item = item;\n    transaction.subdocsAdded.add(this.doc);\n    if (this.doc.shouldLoad) {\n      transaction.subdocsLoaded.add(this.doc);\n    }\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {\n    if (transaction.subdocsAdded.has(this.doc)) {\n      transaction.subdocsAdded.delete(this.doc);\n    } else {\n      transaction.subdocsRemoved.add(this.doc);\n    }\n  }\n\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) { }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeString(this.doc.guid);\n    encoder.writeAny(this.opts);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 9\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentDoc}\n */\nconst readContentDoc = decoder => new ContentDoc(new Doc({ guid: decoder.readString(), ...decoder.readAny() }));\n\n/**\n * @private\n */\nclass ContentEmbed {\n  /**\n   * @param {Object} embed\n   */\n  constructor (embed) {\n    this.embed = embed;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.embed]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentEmbed}\n   */\n  copy () {\n    return new ContentEmbed(this.embed)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentEmbed}\n   */\n  splice (offset) {\n    throw error__namespace.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentEmbed} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeJSON(this.embed);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 5\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentEmbed}\n */\nconst readContentEmbed = decoder => new ContentEmbed(decoder.readJSON());\n\n/**\n * @private\n */\nclass ContentFormat {\n  /**\n   * @param {string} key\n   * @param {Object} value\n   */\n  constructor (key, value) {\n    this.key = key;\n    this.value = value;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return []\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return false\n  }\n\n  /**\n   * @return {ContentFormat}\n   */\n  copy () {\n    return new ContentFormat(this.key, this.value)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentFormat}\n   */\n  splice (offset) {\n    throw error__namespace.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentFormat} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    // @todo searchmarker are currently unsupported for rich text documents\n    /** @type {AbstractType<any>} */ (item.parent)._searchMarker = null;\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeKey(this.key);\n    encoder.writeJSON(this.value);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 6\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentFormat}\n */\nconst readContentFormat = decoder => new ContentFormat(decoder.readString(), decoder.readJSON());\n\n/**\n * @private\n */\nclass ContentJSON {\n  /**\n   * @param {Array<any>} arr\n   */\n  constructor (arr) {\n    /**\n     * @type {Array<any>}\n     */\n    this.arr = arr;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.arr.length\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return this.arr\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentJSON}\n   */\n  copy () {\n    return new ContentJSON(this.arr)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentJSON}\n   */\n  splice (offset) {\n    const right = new ContentJSON(this.arr.slice(offset));\n    this.arr = this.arr.slice(0, offset);\n    return right\n  }\n\n  /**\n   * @param {ContentJSON} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.arr = this.arr.concat(right.arr);\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    const len = this.arr.length;\n    encoder.writeLen(len - offset);\n    for (let i = offset; i < len; i++) {\n      const c = this.arr[i];\n      encoder.writeString(c === undefined ? 'undefined' : JSON.stringify(c));\n    }\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 2\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentJSON}\n */\nconst readContentJSON = decoder => {\n  const len = decoder.readLen();\n  const cs = [];\n  for (let i = 0; i < len; i++) {\n    const c = decoder.readString();\n    if (c === 'undefined') {\n      cs.push(undefined);\n    } else {\n      cs.push(JSON.parse(c));\n    }\n  }\n  return new ContentJSON(cs)\n};\n\nclass ContentAny {\n  /**\n   * @param {Array<any>} arr\n   */\n  constructor (arr) {\n    /**\n     * @type {Array<any>}\n     */\n    this.arr = arr;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.arr.length\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return this.arr\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentAny}\n   */\n  copy () {\n    return new ContentAny(this.arr)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentAny}\n   */\n  splice (offset) {\n    const right = new ContentAny(this.arr.slice(offset));\n    this.arr = this.arr.slice(0, offset);\n    return right\n  }\n\n  /**\n   * @param {ContentAny} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.arr = this.arr.concat(right.arr);\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    const len = this.arr.length;\n    encoder.writeLen(len - offset);\n    for (let i = offset; i < len; i++) {\n      const c = this.arr[i];\n      encoder.writeAny(c);\n    }\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 8\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentAny}\n */\nconst readContentAny = decoder => {\n  const len = decoder.readLen();\n  const cs = [];\n  for (let i = 0; i < len; i++) {\n    cs.push(decoder.readAny());\n  }\n  return new ContentAny(cs)\n};\n\n/**\n * @private\n */\nclass ContentString {\n  /**\n   * @param {string} str\n   */\n  constructor (str) {\n    /**\n     * @type {string}\n     */\n    this.str = str;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.str.length\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return this.str.split('')\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentString}\n   */\n  copy () {\n    return new ContentString(this.str)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentString}\n   */\n  splice (offset) {\n    const right = new ContentString(this.str.slice(offset));\n    this.str = this.str.slice(0, offset);\n\n    // Prevent encoding invalid documents because of splitting of surrogate pairs: https://github.com/yjs/yjs/issues/248\n    const firstCharCode = this.str.charCodeAt(offset - 1);\n    if (firstCharCode >= 0xD800 && firstCharCode <= 0xDBFF) {\n      // Last character of the left split is the start of a surrogate utf16/ucs2 pair.\n      // We don't support splitting of surrogate pairs because this may lead to invalid documents.\n      // Replace the invalid character with a unicode replacement character ( / U+FFFD)\n      this.str = this.str.slice(0, offset - 1) + '';\n      // replace right as well\n      right.str = '' + right.str.slice(1);\n    }\n    return right\n  }\n\n  /**\n   * @param {ContentString} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.str += right.str;\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 4\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentString}\n */\nconst readContentString = decoder => new ContentString(decoder.readString());\n\n/**\n * @type {Array<function(UpdateDecoderV1 | UpdateDecoderV2):AbstractType<any>>}\n * @private\n */\nconst typeRefs = [\n  readYArray,\n  readYMap,\n  readYText,\n  readYXmlElement,\n  readYXmlFragment,\n  readYXmlHook,\n  readYXmlText\n];\n\nconst YArrayRefID = 0;\nconst YMapRefID = 1;\nconst YTextRefID = 2;\nconst YXmlElementRefID = 3;\nconst YXmlFragmentRefID = 4;\nconst YXmlHookRefID = 5;\nconst YXmlTextRefID = 6;\n\n/**\n * @private\n */\nclass ContentType {\n  /**\n   * @param {AbstractType<YEvent>} type\n   */\n  constructor (type) {\n    /**\n     * @type {AbstractType<any>}\n     */\n    this.type = type;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.type]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentType}\n   */\n  copy () {\n    return new ContentType(this.type._copy())\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentType}\n   */\n  splice (offset) {\n    throw error__namespace.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentType} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    this.type._integrate(transaction.doc, item);\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {\n    let item = this.type._start;\n    while (item !== null) {\n      if (!item.deleted) {\n        item.delete(transaction);\n      } else {\n        // Whis will be gc'd later and we want to merge it if possible\n        // We try to merge all deleted items after each transaction,\n        // but we have no knowledge about that this needs to be merged\n        // since it is not in transaction.ds. Hence we add it to transaction._mergeStructs\n        transaction._mergeStructs.push(item);\n      }\n      item = item.right;\n    }\n    this.type._map.forEach(item => {\n      if (!item.deleted) {\n        item.delete(transaction);\n      } else {\n        // same as above\n        transaction._mergeStructs.push(item);\n      }\n    });\n    transaction.changed.delete(this.type);\n  }\n\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {\n    let item = this.type._start;\n    while (item !== null) {\n      item.gc(store, true);\n      item = item.right;\n    }\n    this.type._start = null;\n    this.type._map.forEach(/** @param {Item | null} item */ (item) => {\n      while (item !== null) {\n        item.gc(store, true);\n        item = item.left;\n      }\n    });\n    this.type._map = new Map();\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    this.type._write(encoder);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 7\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentType}\n */\nconst readContentType = decoder => new ContentType(typeRefs[decoder.readTypeRef()](decoder));\n\n/**\n * @todo This should return several items\n *\n * @param {StructStore} store\n * @param {ID} id\n * @return {{item:Item, diff:number}}\n */\nconst followRedone = (store, id) => {\n  /**\n   * @type {ID|null}\n   */\n  let nextID = id;\n  let diff = 0;\n  let item;\n  do {\n    if (diff > 0) {\n      nextID = createID(nextID.client, nextID.clock + diff);\n    }\n    item = getItem(store, nextID);\n    diff = nextID.clock - item.id.clock;\n    nextID = item.redone;\n  } while (nextID !== null && item instanceof Item)\n  return {\n    item, diff\n  }\n};\n\n/**\n * Make sure that neither item nor any of its parents is ever deleted.\n *\n * This property does not persist when storing it into a database or when\n * sending it to other peers\n *\n * @param {Item|null} item\n * @param {boolean} keep\n */\nconst keepItem = (item, keep) => {\n  while (item !== null && item.keep !== keep) {\n    item.keep = keep;\n    item = /** @type {AbstractType<any>} */ (item.parent)._item;\n  }\n};\n\n/**\n * Split leftItem into two items\n * @param {Transaction} transaction\n * @param {Item} leftItem\n * @param {number} diff\n * @return {Item}\n *\n * @function\n * @private\n */\nconst splitItem = (transaction, leftItem, diff) => {\n  // create rightItem\n  const { client, clock } = leftItem.id;\n  const rightItem = new Item(\n    createID(client, clock + diff),\n    leftItem,\n    createID(client, clock + diff - 1),\n    leftItem.right,\n    leftItem.rightOrigin,\n    leftItem.parent,\n    leftItem.parentSub,\n    leftItem.content.splice(diff)\n  );\n  if (leftItem.deleted) {\n    rightItem.markDeleted();\n  }\n  if (leftItem.keep) {\n    rightItem.keep = true;\n  }\n  if (leftItem.redone !== null) {\n    rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);\n  }\n  // update left (do not set leftItem.rightOrigin as it will lead to problems when syncing)\n  leftItem.right = rightItem;\n  // update right\n  if (rightItem.right !== null) {\n    rightItem.right.left = rightItem;\n  }\n  // right is more specific.\n  transaction._mergeStructs.push(rightItem);\n  // update parent._map\n  if (rightItem.parentSub !== null && rightItem.right === null) {\n    /** @type {AbstractType<any>} */ (rightItem.parent)._map.set(rightItem.parentSub, rightItem);\n  }\n  leftItem.length = diff;\n  return rightItem\n};\n\n/**\n * Redoes the effect of this operation.\n *\n * @param {Transaction} transaction The Yjs instance.\n * @param {Item} item\n * @param {Set<Item>} redoitems\n *\n * @return {Item|null}\n *\n * @private\n */\nconst redoItem = (transaction, item, redoitems) => {\n  const doc = transaction.doc;\n  const store = doc.store;\n  const ownClientID = doc.clientID;\n  const redone = item.redone;\n  if (redone !== null) {\n    return getItemCleanStart(transaction, redone)\n  }\n  let parentItem = /** @type {AbstractType<any>} */ (item.parent)._item;\n  /**\n   * @type {Item|null}\n   */\n  let left;\n  /**\n   * @type {Item|null}\n   */\n  let right;\n  if (item.parentSub === null) {\n    // Is an array item. Insert at the old position\n    left = item.left;\n    right = item;\n  } else {\n    // Is a map item. Insert as current value\n    left = item;\n    while (left.right !== null) {\n      left = left.right;\n      if (left.id.client !== ownClientID) {\n        // It is not possible to redo this item because it conflicts with a\n        // change from another client\n        return null\n      }\n    }\n    if (left.right !== null) {\n      left = /** @type {Item} */ (/** @type {AbstractType<any>} */ (item.parent)._map.get(item.parentSub));\n    }\n    right = null;\n  }\n  // make sure that parent is redone\n  if (parentItem !== null && parentItem.deleted === true && parentItem.redone === null) {\n    // try to undo parent if it will be undone anyway\n    if (!redoitems.has(parentItem) || redoItem(transaction, parentItem, redoitems) === null) {\n      return null\n    }\n  }\n  if (parentItem !== null && parentItem.redone !== null) {\n    while (parentItem.redone !== null) {\n      parentItem = getItemCleanStart(transaction, parentItem.redone);\n    }\n    // find next cloned_redo items\n    while (left !== null) {\n      /**\n       * @type {Item|null}\n       */\n      let leftTrace = left;\n      // trace redone until parent matches\n      while (leftTrace !== null && /** @type {AbstractType<any>} */ (leftTrace.parent)._item !== parentItem) {\n        leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction, leftTrace.redone);\n      }\n      if (leftTrace !== null && /** @type {AbstractType<any>} */ (leftTrace.parent)._item === parentItem) {\n        left = leftTrace;\n        break\n      }\n      left = left.left;\n    }\n    while (right !== null) {\n      /**\n       * @type {Item|null}\n       */\n      let rightTrace = right;\n      // trace redone until parent matches\n      while (rightTrace !== null && /** @type {AbstractType<any>} */ (rightTrace.parent)._item !== parentItem) {\n        rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction, rightTrace.redone);\n      }\n      if (rightTrace !== null && /** @type {AbstractType<any>} */ (rightTrace.parent)._item === parentItem) {\n        right = rightTrace;\n        break\n      }\n      right = right.right;\n    }\n  }\n  const nextClock = getState(store, ownClientID);\n  const nextId = createID(ownClientID, nextClock);\n  const redoneItem = new Item(\n    nextId,\n    left, left && left.lastId,\n    right, right && right.id,\n    parentItem === null ? item.parent : /** @type {ContentType} */ (parentItem.content).type,\n    item.parentSub,\n    item.content.copy()\n  );\n  item.redone = nextId;\n  keepItem(redoneItem, true);\n  redoneItem.integrate(transaction, 0);\n  return redoneItem\n};\n\n/**\n * Abstract class that represents any content.\n */\nclass Item extends AbstractStruct {\n  /**\n   * @param {ID} id\n   * @param {Item | null} left\n   * @param {ID | null} origin\n   * @param {Item | null} right\n   * @param {ID | null} rightOrigin\n   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.\n   * @param {string | null} parentSub\n   * @param {AbstractContent} content\n   */\n  constructor (id, left, origin, right, rightOrigin, parent, parentSub, content) {\n    super(id, content.getLength());\n    /**\n     * The item that was originally to the left of this item.\n     * @type {ID | null}\n     */\n    this.origin = origin;\n    /**\n     * The item that is currently to the left of this item.\n     * @type {Item | null}\n     */\n    this.left = left;\n    /**\n     * The item that is currently to the right of this item.\n     * @type {Item | null}\n     */\n    this.right = right;\n    /**\n     * The item that was originally to the right of this item.\n     * @type {ID | null}\n     */\n    this.rightOrigin = rightOrigin;\n    /**\n     * @type {AbstractType<any>|ID|null}\n     */\n    this.parent = parent;\n    /**\n     * If the parent refers to this item with some kind of key (e.g. YMap, the\n     * key is specified here. The key is then used to refer to the list in which\n     * to insert this item. If `parentSub = null` type._start is the list in\n     * which to insert to. Otherwise it is `parent._map`.\n     * @type {String | null}\n     */\n    this.parentSub = parentSub;\n    /**\n     * If this type's effect is reundone this type refers to the type that undid\n     * this operation.\n     * @type {ID | null}\n     */\n    this.redone = null;\n    /**\n     * @type {AbstractContent}\n     */\n    this.content = content;\n    /**\n     * bit1: keep\n     * bit2: countable\n     * bit3: deleted\n     * bit4: mark - mark node as fast-search-marker\n     * @type {number} byte\n     */\n    this.info = this.content.isCountable() ? binary__namespace.BIT2 : 0;\n  }\n\n  /**\n   * This is used to mark the item as an indexed fast-search marker\n   *\n   * @type {boolean}\n   */\n  set marker (isMarked) {\n    if (((this.info & binary__namespace.BIT4) > 0) !== isMarked) {\n      this.info ^= binary__namespace.BIT4;\n    }\n  }\n\n  get marker () {\n    return (this.info & binary__namespace.BIT4) > 0\n  }\n\n  /**\n   * If true, do not garbage collect this Item.\n   */\n  get keep () {\n    return (this.info & binary__namespace.BIT1) > 0\n  }\n\n  set keep (doKeep) {\n    if (this.keep !== doKeep) {\n      this.info ^= binary__namespace.BIT1;\n    }\n  }\n\n  get countable () {\n    return (this.info & binary__namespace.BIT2) > 0\n  }\n\n  /**\n   * Whether this item was deleted or not.\n   * @type {Boolean}\n   */\n  get deleted () {\n    return (this.info & binary__namespace.BIT3) > 0\n  }\n\n  set deleted (doDelete) {\n    if (this.deleted !== doDelete) {\n      this.info ^= binary__namespace.BIT3;\n    }\n  }\n\n  markDeleted () {\n    this.info |= binary__namespace.BIT3;\n  }\n\n  /**\n   * Return the creator clientID of the missing op or define missing items and return null.\n   *\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */\n  getMissing (transaction, store) {\n    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) {\n      return this.origin.client\n    }\n    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) {\n      return this.rightOrigin.client\n    }\n    if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) {\n      return this.parent.client\n    }\n\n    // We have all missing ids, now find the items\n\n    if (this.origin) {\n      this.left = getItemCleanEnd(transaction, store, this.origin);\n      this.origin = this.left.lastId;\n    }\n    if (this.rightOrigin) {\n      this.right = getItemCleanStart(transaction, this.rightOrigin);\n      this.rightOrigin = this.right.id;\n    }\n    if ((this.left && this.left.constructor === GC) || (this.right && this.right.constructor === GC)) {\n      this.parent = null;\n    }\n    // only set parent if this shouldn't be garbage collected\n    if (!this.parent) {\n      if (this.left && this.left.constructor === Item) {\n        this.parent = this.left.parent;\n        this.parentSub = this.left.parentSub;\n      }\n      if (this.right && this.right.constructor === Item) {\n        this.parent = this.right.parent;\n        this.parentSub = this.right.parentSub;\n      }\n    } else if (this.parent.constructor === ID) {\n      const parentItem = getItem(store, this.parent);\n      if (parentItem.constructor === GC) {\n        this.parent = null;\n      } else {\n        this.parent = /** @type {ContentType} */ (parentItem.content).type;\n      }\n    }\n    return null\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    if (offset > 0) {\n      this.id.clock += offset;\n      this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));\n      this.origin = this.left.lastId;\n      this.content = this.content.splice(offset);\n      this.length -= offset;\n    }\n\n    if (this.parent) {\n      if ((!this.left && (!this.right || this.right.left !== null)) || (this.left && this.left.right !== this.right)) {\n        /**\n         * @type {Item|null}\n         */\n        let left = this.left;\n\n        /**\n         * @type {Item|null}\n         */\n        let o;\n        // set o to the first conflicting item\n        if (left !== null) {\n          o = left.right;\n        } else if (this.parentSub !== null) {\n          o = /** @type {AbstractType<any>} */ (this.parent)._map.get(this.parentSub) || null;\n          while (o !== null && o.left !== null) {\n            o = o.left;\n          }\n        } else {\n          o = /** @type {AbstractType<any>} */ (this.parent)._start;\n        }\n        // TODO: use something like DeleteSet here (a tree implementation would be best)\n        // @todo use global set definitions\n        /**\n         * @type {Set<Item>}\n         */\n        const conflictingItems = new Set();\n        /**\n         * @type {Set<Item>}\n         */\n        const itemsBeforeOrigin = new Set();\n        // Let c in conflictingItems, b in itemsBeforeOrigin\n        // ***{origin}bbbb{this}{c,b}{c,b}{o}***\n        // Note that conflictingItems is a subset of itemsBeforeOrigin\n        while (o !== null && o !== this.right) {\n          itemsBeforeOrigin.add(o);\n          conflictingItems.add(o);\n          if (compareIDs(this.origin, o.origin)) {\n            // case 1\n            if (o.id.client < this.id.client) {\n              left = o;\n              conflictingItems.clear();\n            } else if (compareIDs(this.rightOrigin, o.rightOrigin)) {\n              // this and o are conflicting and point to the same integration points. The id decides which item comes first.\n              // Since this is to the left of o, we can break here\n              break\n            } // else, o might be integrated before an item that this conflicts with. If so, we will find it in the next iterations\n          } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) { // use getItem instead of getItemCleanEnd because we don't want / need to split items.\n            // case 2\n            if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {\n              left = o;\n              conflictingItems.clear();\n            }\n          } else {\n            break\n          }\n          o = o.right;\n        }\n        this.left = left;\n      }\n      // reconnect left/right + update parent map/start if necessary\n      if (this.left !== null) {\n        const right = this.left.right;\n        this.right = right;\n        this.left.right = this;\n      } else {\n        let r;\n        if (this.parentSub !== null) {\n          r = /** @type {AbstractType<any>} */ (this.parent)._map.get(this.parentSub) || null;\n          while (r !== null && r.left !== null) {\n            r = r.left;\n          }\n        } else {\n          r = /** @type {AbstractType<any>} */ (this.parent)._start\n          ;/** @type {AbstractType<any>} */ (this.parent)._start = this;\n        }\n        this.right = r;\n      }\n      if (this.right !== null) {\n        this.right.left = this;\n      } else if (this.parentSub !== null) {\n        // set as current parent value if right === null and this is parentSub\n        /** @type {AbstractType<any>} */ (this.parent)._map.set(this.parentSub, this);\n        if (this.left !== null) {\n          // this is the current attribute value of parent. delete right\n          this.left.delete(transaction);\n        }\n      }\n      // adjust length of parent\n      if (this.parentSub === null && this.countable && !this.deleted) {\n        /** @type {AbstractType<any>} */ (this.parent)._length += this.length;\n      }\n      addStruct(transaction.doc.store, this);\n      this.content.integrate(transaction, this);\n      // add parent to transaction.changed\n      addChangedTypeToTransaction(transaction, /** @type {AbstractType<any>} */ (this.parent), this.parentSub);\n      if ((/** @type {AbstractType<any>} */ (this.parent)._item !== null && /** @type {AbstractType<any>} */ (this.parent)._item.deleted) || (this.parentSub !== null && this.right !== null)) {\n        // delete if parent is deleted or if this is not the current attribute value of parent\n        this.delete(transaction);\n      }\n    } else {\n      // parent is not defined. Integrate GC struct instead\n      new GC(this.id, this.length).integrate(transaction, 0);\n    }\n  }\n\n  /**\n   * Returns the next non-deleted item\n   */\n  get next () {\n    let n = this.right;\n    while (n !== null && n.deleted) {\n      n = n.right;\n    }\n    return n\n  }\n\n  /**\n   * Returns the previous non-deleted item\n   */\n  get prev () {\n    let n = this.left;\n    while (n !== null && n.deleted) {\n      n = n.left;\n    }\n    return n\n  }\n\n  /**\n   * Computes the last content address of this Item.\n   */\n  get lastId () {\n    // allocating ids is pretty costly because of the amount of ids created, so we try to reuse whenever possible\n    return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1)\n  }\n\n  /**\n   * Try to merge two items\n   *\n   * @param {Item} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    if (\n      this.constructor === right.constructor &&\n      compareIDs(right.origin, this.lastId) &&\n      this.right === right &&\n      compareIDs(this.rightOrigin, right.rightOrigin) &&\n      this.id.client === right.id.client &&\n      this.id.clock + this.length === right.id.clock &&\n      this.deleted === right.deleted &&\n      this.redone === null &&\n      right.redone === null &&\n      this.content.constructor === right.content.constructor &&\n      this.content.mergeWith(right.content)\n    ) {\n      const searchMarker = /** @type {AbstractType<any>} */ (this.parent)._searchMarker;\n      if (searchMarker) {\n        searchMarker.forEach(marker => {\n          if (marker.p === right) {\n            // right is going to be \"forgotten\" so we need to update the marker\n            marker.p = this;\n            // adjust marker index\n            if (!this.deleted && this.countable) {\n              marker.index -= this.length;\n            }\n          }\n        });\n      }\n      if (right.keep) {\n        this.keep = true;\n      }\n      this.right = right.right;\n      if (this.right !== null) {\n        this.right.left = this;\n      }\n      this.length += right.length;\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Mark this Item as deleted.\n   *\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {\n    if (!this.deleted) {\n      const parent = /** @type {AbstractType<any>} */ (this.parent);\n      // adjust the length of parent\n      if (this.countable && this.parentSub === null) {\n        parent._length -= this.length;\n      }\n      this.markDeleted();\n      addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);\n      addChangedTypeToTransaction(transaction, parent, this.parentSub);\n      this.content.delete(transaction);\n    }\n  }\n\n  /**\n   * @param {StructStore} store\n   * @param {boolean} parentGCd\n   */\n  gc (store, parentGCd) {\n    if (!this.deleted) {\n      throw error__namespace.unexpectedCase()\n    }\n    this.content.gc(store);\n    if (parentGCd) {\n      replaceStruct(store, this, new GC(this.id, this.length));\n    } else {\n      this.content = new ContentDeleted(this.length);\n    }\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;\n    const rightOrigin = this.rightOrigin;\n    const parentSub = this.parentSub;\n    const info = (this.content.getRef() & binary__namespace.BITS5) |\n      (origin === null ? 0 : binary__namespace.BIT8) | // origin is defined\n      (rightOrigin === null ? 0 : binary__namespace.BIT7) | // right origin is defined\n      (parentSub === null ? 0 : binary__namespace.BIT6); // parentSub is non-null\n    encoder.writeInfo(info);\n    if (origin !== null) {\n      encoder.writeLeftID(origin);\n    }\n    if (rightOrigin !== null) {\n      encoder.writeRightID(rightOrigin);\n    }\n    if (origin === null && rightOrigin === null) {\n      const parent = /** @type {AbstractType<any>} */ (this.parent);\n      if (parent._item !== undefined) {\n        const parentItem = parent._item;\n        if (parentItem === null) {\n          // parent type on y._map\n          // find the correct key\n          const ykey = findRootTypeKey(parent);\n          encoder.writeParentInfo(true); // write parentYKey\n          encoder.writeString(ykey);\n        } else {\n          encoder.writeParentInfo(false); // write parent id\n          encoder.writeLeftID(parentItem.id);\n        }\n      } else if (parent.constructor === String) { // this edge case was added by differential updates\n        encoder.writeParentInfo(true); // write parentYKey\n        encoder.writeString(parent);\n      } else if (parent.constructor === ID) {\n        encoder.writeParentInfo(false); // write parent id\n        encoder.writeLeftID(parent);\n      } else {\n        error__namespace.unexpectedCase();\n      }\n      if (parentSub !== null) {\n        encoder.writeString(parentSub);\n      }\n    }\n    this.content.write(encoder, offset);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @param {number} info\n */\nconst readItemContent = (decoder, info) => contentRefs[info & binary__namespace.BITS5](decoder);\n\n/**\n * A lookup map for reading Item content.\n *\n * @type {Array<function(UpdateDecoderV1 | UpdateDecoderV2):AbstractContent>}\n */\nconst contentRefs = [\n  () => { error__namespace.unexpectedCase(); }, // GC is not ItemContent\n  readContentDeleted, // 1\n  readContentJSON, // 2\n  readContentBinary, // 3\n  readContentString, // 4\n  readContentEmbed, // 5\n  readContentFormat, // 6\n  readContentType, // 7\n  readContentAny, // 8\n  readContentDoc, // 9\n  () => { error__namespace.unexpectedCase(); } // 10 - Skip is not ItemContent\n];\n\nconst structSkipRefNumber = 10;\n\n/**\n * @private\n */\nclass Skip extends AbstractStruct {\n  get deleted () {\n    return true\n  }\n\n  delete () {}\n\n  /**\n   * @param {Skip} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    if (this.constructor !== right.constructor) {\n      return false\n    }\n    this.length += right.length;\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    // skip structs cannot be integrated\n    error__namespace.unexpectedCase();\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeInfo(structSkipRefNumber);\n    // write as VarUint because Skips can't make use of predictable length-encoding\n    encoding__namespace.writeVarUint(encoder.restEncoder, this.length - offset);\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */\n  getMissing (transaction, store) {\n    return null\n  }\n}\n\nexports.AbstractConnector = AbstractConnector;\nexports.AbstractStruct = AbstractStruct;\nexports.AbstractType = AbstractType;\nexports.Array = YArray;\nexports.ContentAny = ContentAny;\nexports.ContentBinary = ContentBinary;\nexports.ContentDeleted = ContentDeleted;\nexports.ContentEmbed = ContentEmbed;\nexports.ContentFormat = ContentFormat;\nexports.ContentJSON = ContentJSON;\nexports.ContentString = ContentString;\nexports.ContentType = ContentType;\nexports.Doc = Doc;\nexports.GC = GC;\nexports.ID = ID;\nexports.Item = Item;\nexports.Map = YMap;\nexports.PermanentUserData = PermanentUserData;\nexports.RelativePosition = RelativePosition;\nexports.Snapshot = Snapshot;\nexports.Text = YText;\nexports.Transaction = Transaction;\nexports.UndoManager = UndoManager;\nexports.XmlElement = YXmlElement;\nexports.XmlFragment = YXmlFragment;\nexports.XmlHook = YXmlHook;\nexports.XmlText = YXmlText;\nexports.YArrayEvent = YArrayEvent;\nexports.YEvent = YEvent;\nexports.YMapEvent = YMapEvent;\nexports.YTextEvent = YTextEvent;\nexports.YXmlEvent = YXmlEvent;\nexports.applyUpdate = applyUpdate;\nexports.applyUpdateV2 = applyUpdateV2;\nexports.compareIDs = compareIDs;\nexports.compareRelativePositions = compareRelativePositions;\nexports.createAbsolutePositionFromRelativePosition = createAbsolutePositionFromRelativePosition;\nexports.createDeleteSet = createDeleteSet;\nexports.createDeleteSetFromStructStore = createDeleteSetFromStructStore;\nexports.createDocFromSnapshot = createDocFromSnapshot;\nexports.createID = createID;\nexports.createRelativePositionFromJSON = createRelativePositionFromJSON;\nexports.createRelativePositionFromTypeIndex = createRelativePositionFromTypeIndex;\nexports.createSnapshot = createSnapshot;\nexports.decodeRelativePosition = decodeRelativePosition;\nexports.decodeSnapshot = decodeSnapshot;\nexports.decodeSnapshotV2 = decodeSnapshotV2;\nexports.decodeStateVector = decodeStateVector;\nexports.diffUpdate = diffUpdate;\nexports.diffUpdateV2 = diffUpdateV2;\nexports.emptySnapshot = emptySnapshot;\nexports.encodeRelativePosition = encodeRelativePosition;\nexports.encodeSnapshot = encodeSnapshot;\nexports.encodeSnapshotV2 = encodeSnapshotV2;\nexports.encodeStateAsUpdate = encodeStateAsUpdate;\nexports.encodeStateAsUpdateV2 = encodeStateAsUpdateV2;\nexports.encodeStateVector = encodeStateVector;\nexports.encodeStateVectorFromUpdate = encodeStateVectorFromUpdate;\nexports.encodeStateVectorFromUpdateV2 = encodeStateVectorFromUpdateV2;\nexports.equalSnapshots = equalSnapshots;\nexports.findRootTypeKey = findRootTypeKey;\nexports.getItem = getItem;\nexports.getState = getState;\nexports.getTypeChildren = getTypeChildren;\nexports.isDeleted = isDeleted;\nexports.isParentOf = isParentOf;\nexports.iterateDeletedStructs = iterateDeletedStructs;\nexports.logType = logType;\nexports.logUpdate = logUpdate;\nexports.logUpdateV2 = logUpdateV2;\nexports.mergeUpdates = mergeUpdates;\nexports.mergeUpdatesV2 = mergeUpdatesV2;\nexports.parseUpdateMeta = parseUpdateMeta;\nexports.parseUpdateMetaV2 = parseUpdateMetaV2;\nexports.readUpdate = readUpdate;\nexports.readUpdateV2 = readUpdateV2;\nexports.relativePositionToJSON = relativePositionToJSON;\nexports.snapshot = snapshot;\nexports.transact = transact;\nexports.tryGc = tryGc;\nexports.typeListToArraySnapshot = typeListToArraySnapshot;\nexports.typeMapGetSnapshot = typeMapGetSnapshot;\n//# sourceMappingURL=yjs.cjs.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar map = require('./map-28a001c9.cjs');\nvar set = require('./set-7ae96d21.cjs');\nvar array = require('./array-b2d24238.cjs');\n\n/**\n * Observable class prototype.\n *\n * @module observable\n */\n\n/**\n * Handles named events.\n *\n * @template N\n */\nclass Observable {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<N, any>}\n     */\n    this._observers = map.create();\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  on (name, f) {\n    map.setIfUndefined(this._observers, name, set.create).add(f);\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, _f);\n      f(...args);\n    };\n    this.on(name, _f);\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name);\n    if (observers !== undefined) {\n      observers.delete(f);\n      if (observers.size === 0) {\n        this._observers.delete(name);\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @param {N} name The event name.\n   * @param {Array<any>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return array.from((this._observers.get(name) || map.create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = map.create();\n  }\n}\n\nexports.Observable = Observable;\n//# sourceMappingURL=observable.cjs.map\n","'use strict';\n\n/**\n * Utility module to work with key-value stores.\n *\n * @module map\n */\n\n/**\n * Creates a new Map instance.\n *\n * @function\n * @return {Map<any, any>}\n *\n * @function\n */\nconst create = () => new Map();\n\n/**\n * Copy a Map object into a fresh Map object.\n *\n * @function\n * @template X,Y\n * @param {Map<X,Y>} m\n * @return {Map<X,Y>}\n */\nconst copy = m => {\n  const r = create();\n  m.forEach((v, k) => { r.set(k, v); });\n  return r\n};\n\n/**\n * Get map property. Create T if property is undefined and set T on map.\n *\n * ```js\n * const listeners = map.setIfUndefined(events, 'eventName', set.create)\n * listeners.add(listener)\n * ```\n *\n * @function\n * @template T,K\n * @param {Map<K, T>} map\n * @param {K} key\n * @param {function():T} createT\n * @return {T}\n */\nconst setIfUndefined = (map, key, createT) => {\n  let set = map.get(key);\n  if (set === undefined) {\n    map.set(key, set = createT());\n  }\n  return set\n};\n\n/**\n * Creates an Array and populates it with the content of all key-value pairs using the `f(value, key)` function.\n *\n * @function\n * @template K\n * @template V\n * @template R\n * @param {Map<K,V>} m\n * @param {function(V,K):R} f\n * @return {Array<R>}\n */\nconst map = (m, f) => {\n  const res = [];\n  for (const [key, value] of m) {\n    res.push(f(value, key));\n  }\n  return res\n};\n\n/**\n * Tests whether any key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @todo should rename to some - similarly to Array.some\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nconst any = (m, f) => {\n  for (const [key, value] of m) {\n    if (f(value, key)) {\n      return true\n    }\n  }\n  return false\n};\n\n/**\n * Tests whether all key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nconst all = (m, f) => {\n  for (const [key, value] of m) {\n    if (!f(value, key)) {\n      return false\n    }\n  }\n  return true\n};\n\nvar map$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  create: create,\n  copy: copy,\n  setIfUndefined: setIfUndefined,\n  map: map,\n  any: any,\n  all: all\n});\n\nexports.all = all;\nexports.any = any;\nexports.copy = copy;\nexports.create = create;\nexports.map = map;\nexports.map$1 = map$1;\nexports.setIfUndefined = setIfUndefined;\n//# sourceMappingURL=map-28a001c9.cjs.map\n","'use strict';\n\n/**\n * Utility module to work with sets.\n *\n * @module set\n */\n\nconst create = () => new Set();\n\n/**\n * @template T\n * @param {Set<T>} set\n * @return {Array<T>}\n */\nconst toArray = set => Array.from(set);\n\nvar set = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tcreate: create,\n\ttoArray: toArray\n});\n\nexports.create = create;\nexports.set = set;\nexports.toArray = toArray;\n//# sourceMappingURL=set-7ae96d21.cjs.map\n","'use strict';\n\n/**\n * Utility module to work with Arrays.\n *\n * @module array\n */\n\n/**\n * Return the last element of an array. The element must exist\n *\n * @template L\n * @param {Array<L>} arr\n * @return {L}\n */\nconst last = arr => arr[arr.length - 1];\n\n/**\n * @template C\n * @return {Array<C>}\n */\nconst create = () => /** @type {Array<C>} */ ([]);\n\n/**\n * @template D\n * @param {Array<D>} a\n * @return {Array<D>}\n */\nconst copy = a => /** @type {Array<D>} */ (a.slice());\n\n/**\n * Append elements from src to dest\n *\n * @template M\n * @param {Array<M>} dest\n * @param {Array<M>} src\n */\nconst appendTo = (dest, src) => {\n  for (let i = 0; i < src.length; i++) {\n    dest.push(src[i]);\n  }\n};\n\n/**\n * Transforms something array-like to an actual Array.\n *\n * @function\n * @template T\n * @param {ArrayLike<T>|Iterable<T>} arraylike\n * @return {T}\n */\nconst from = Array.from;\n\n/**\n * True iff condition holds on every element in the Array.\n *\n * @function\n * @template ITEM\n *\n * @param {Array<ITEM>} arr\n * @param {function(ITEM, number, Array<ITEM>):boolean} f\n * @return {boolean}\n */\nconst every = (arr, f) => arr.every(f);\n\n/**\n * True iff condition holds on some element in the Array.\n *\n * @function\n * @template S\n * @param {Array<S>} arr\n * @param {function(S, number, Array<S>):boolean} f\n * @return {boolean}\n */\nconst some = (arr, f) => arr.some(f);\n\n/**\n * @template ELEM\n *\n * @param {Array<ELEM>} a\n * @param {Array<ELEM>} b\n * @return {boolean}\n */\nconst equalFlat = (a, b) => a.length === b.length && every(a, (item, index) => item === b[index]);\n\n/**\n * @template ELEM\n * @param {Array<Array<ELEM>>} arr\n * @return {Array<ELEM>}\n */\nconst flatten = arr => arr.reduce((acc, val) => acc.concat(val), []);\n\nvar array = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  last: last,\n  create: create,\n  copy: copy,\n  appendTo: appendTo,\n  from: from,\n  every: every,\n  some: some,\n  equalFlat: equalFlat,\n  flatten: flatten\n});\n\nexports.appendTo = appendTo;\nexports.array = array;\nexports.copy = copy;\nexports.create = create;\nexports.equalFlat = equalFlat;\nexports.every = every;\nexports.flatten = flatten;\nexports.from = from;\nexports.last = last;\nexports.some = some;\n//# sourceMappingURL=array-b2d24238.cjs.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar array = require('./array-b2d24238.cjs');\n\n\n\nexports.appendTo = array.appendTo;\nexports.copy = array.copy;\nexports.create = array.create;\nexports.equalFlat = array.equalFlat;\nexports.every = array.every;\nexports.flatten = array.flatten;\nexports.from = array.from;\nexports.last = array.last;\nexports.some = array.some;\n//# sourceMappingURL=array.cjs.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar math = require('./math-08e068f9.cjs');\n\n\n\nexports.abs = math.abs;\nexports.add = math.add;\nexports.ceil = math.ceil;\nexports.exp10 = math.exp10;\nexports.floor = math.floor;\nexports.imul = math.imul;\nexports.isNaN = math.isNaN;\nexports.isNegativeZero = math.isNegativeZero;\nexports.log = math.log;\nexports.log10 = math.log10;\nexports.log2 = math.log2;\nexports.max = math.max;\nexports.min = math.min;\nexports.pow = math.pow;\nexports.round = math.round;\nexports.sign = math.sign;\nexports.sqrt = math.sqrt;\n//# sourceMappingURL=math.cjs.map\n","'use strict';\n\n/**\n * Common Math expressions.\n *\n * @module math\n */\n\nconst floor = Math.floor;\nconst ceil = Math.ceil;\nconst abs = Math.abs;\nconst imul = Math.imul;\nconst round = Math.round;\nconst log10 = Math.log10;\nconst log2 = Math.log2;\nconst log = Math.log;\nconst sqrt = Math.sqrt;\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The sum of a and b\n */\nconst add = (a, b) => a + b;\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The smaller element of a and b\n */\nconst min = (a, b) => a < b ? a : b;\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The bigger element of a and b\n */\nconst max = (a, b) => a > b ? a : b;\n\nconst isNaN = Number.isNaN;\n\nconst pow = Math.pow;\n/**\n * Base 10 exponential function. Returns the value of 10 raised to the power of pow.\n *\n * @param {number} exp\n * @return {number}\n */\nconst exp10 = exp => Math.pow(10, exp);\n\nconst sign = Math.sign;\n\n/**\n * @param {number} n\n * @return {boolean} Wether n is negative. This function also differentiates between -0 and +0\n */\nconst isNegativeZero = n => n !== 0 ? n < 0 : 1 / n < 0;\n\nvar math = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tfloor: floor,\n\tceil: ceil,\n\tabs: abs,\n\timul: imul,\n\tround: round,\n\tlog10: log10,\n\tlog2: log2,\n\tlog: log,\n\tsqrt: sqrt,\n\tadd: add,\n\tmin: min,\n\tmax: max,\n\tisNaN: isNaN,\n\tpow: pow,\n\texp10: exp10,\n\tsign: sign,\n\tisNegativeZero: isNegativeZero\n});\n\nexports.abs = abs;\nexports.add = add;\nexports.ceil = ceil;\nexports.exp10 = exp10;\nexports.floor = floor;\nexports.imul = imul;\nexports.isNaN = isNaN;\nexports.isNegativeZero = isNegativeZero;\nexports.log = log;\nexports.log10 = log10;\nexports.log2 = log2;\nexports.math = math;\nexports.max = max;\nexports.min = min;\nexports.pow = pow;\nexports.round = round;\nexports.sign = sign;\nexports.sqrt = sqrt;\n//# sourceMappingURL=math-08e068f9.cjs.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar map = require('./map-28a001c9.cjs');\n\n\n\nexports.all = map.all;\nexports.any = map.any;\nexports.copy = map.copy;\nexports.create = map.create;\nexports.map = map.map;\nexports.setIfUndefined = map.setIfUndefined;\n//# sourceMappingURL=map.cjs.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar encoding = require('./buffer-ac2cdedf.cjs');\nrequire('./math-08e068f9.cjs');\nrequire('./number-24f1eabe.cjs');\nrequire('./binary-ac8e39e2.cjs');\nrequire('./string-f3c3d805.cjs');\nrequire('./environment-7e2ffaea.cjs');\nrequire('./map-28a001c9.cjs');\nrequire('./conditions-fb475c70.cjs');\nrequire('./storage.cjs');\n\n\n\nexports.Encoder = encoding.Encoder;\nexports.IncUintOptRleEncoder = encoding.IncUintOptRleEncoder;\nexports.IntDiffEncoder = encoding.IntDiffEncoder;\nexports.IntDiffOptRleEncoder = encoding.IntDiffOptRleEncoder;\nexports.RleEncoder = encoding.RleEncoder;\nexports.RleIntDiffEncoder = encoding.RleIntDiffEncoder;\nexports.StringEncoder = encoding.StringEncoder;\nexports.UintOptRleEncoder = encoding.UintOptRleEncoder;\nexports.createEncoder = encoding.createEncoder;\nexports.length = encoding.length;\nexports.set = encoding.set;\nexports.setUint16 = encoding.setUint16;\nexports.setUint32 = encoding.setUint32;\nexports.setUint8 = encoding.setUint8;\nexports.toUint8Array = encoding.toUint8Array;\nexports.write = encoding.write;\nexports.writeAny = encoding.writeAny;\nexports.writeBigInt64 = encoding.writeBigInt64;\nexports.writeBigUint64 = encoding.writeBigUint64;\nexports.writeBinaryEncoder = encoding.writeBinaryEncoder;\nexports.writeFloat32 = encoding.writeFloat32;\nexports.writeFloat64 = encoding.writeFloat64;\nexports.writeOnDataView = encoding.writeOnDataView;\nexports.writeUint16 = encoding.writeUint16;\nexports.writeUint32 = encoding.writeUint32;\nexports.writeUint32BigEndian = encoding.writeUint32BigEndian;\nexports.writeUint8 = encoding.writeUint8;\nexports.writeUint8Array = encoding.writeUint8Array;\nexports.writeVarInt = encoding.writeVarInt;\nexports.writeVarString = encoding.writeVarString;\nexports.writeVarUint = encoding.writeVarUint;\nexports.writeVarUint8Array = encoding.writeVarUint8Array;\n//# sourceMappingURL=encoding.cjs.map\n","'use strict';\n\nvar string = require('./string-f3c3d805.cjs');\nvar environment = require('./environment-7e2ffaea.cjs');\nvar binary = require('./binary-ac8e39e2.cjs');\nvar math = require('./math-08e068f9.cjs');\nvar number = require('./number-24f1eabe.cjs');\n\n/**\n * Efficient schema-less binary encoding with support for variable length encoding.\n *\n * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = new encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = new decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module encoding\n */\n\n/**\n * A BinaryEncoder handles the encoding to an Uint8Array.\n */\nclass Encoder {\n  constructor () {\n    this.cpos = 0;\n    this.cbuf = new Uint8Array(100);\n    /**\n     * @type {Array<Uint8Array>}\n     */\n    this.bufs = [];\n  }\n}\n\n/**\n * @function\n * @return {Encoder}\n */\nconst createEncoder = () => new Encoder();\n\n/**\n * The current length of the encoded data.\n *\n * @function\n * @param {Encoder} encoder\n * @return {number}\n */\nconst length = encoder => {\n  let len = encoder.cpos;\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    len += encoder.bufs[i].length;\n  }\n  return len\n};\n\n/**\n * Transform to Uint8Array.\n *\n * @function\n * @param {Encoder} encoder\n * @return {Uint8Array} The created ArrayBuffer.\n */\nconst toUint8Array = encoder => {\n  const uint8arr = new Uint8Array(length(encoder));\n  let curPos = 0;\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    const d = encoder.bufs[i];\n    uint8arr.set(d, curPos);\n    curPos += d.length;\n  }\n  uint8arr.set(createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos), curPos);\n  return uint8arr\n};\n\n/**\n * Verify that it is possible to write `len` bytes wtihout checking. If\n * necessary, a new Buffer with the required length is attached.\n *\n * @param {Encoder} encoder\n * @param {number} len\n */\nconst verifyLen = (encoder, len) => {\n  const bufferLen = encoder.cbuf.length;\n  if (bufferLen - encoder.cpos < len) {\n    encoder.bufs.push(createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos));\n    encoder.cbuf = new Uint8Array(math.max(bufferLen, len) * 2);\n    encoder.cpos = 0;\n  }\n};\n\n/**\n * Write one byte to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The byte that is to be encoded.\n */\nconst write = (encoder, num) => {\n  const bufferLen = encoder.cbuf.length;\n  if (encoder.cpos === bufferLen) {\n    encoder.bufs.push(encoder.cbuf);\n    encoder.cbuf = new Uint8Array(bufferLen * 2);\n    encoder.cpos = 0;\n  }\n  encoder.cbuf[encoder.cpos++] = num;\n};\n\n/**\n * Write one byte at a specific position.\n * Position must already be written (i.e. encoder.length > pos)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos Position to which to write data\n * @param {number} num Unsigned 8-bit integer\n */\nconst set = (encoder, pos, num) => {\n  let buffer = null;\n  // iterate all buffers and adjust position\n  for (let i = 0; i < encoder.bufs.length && buffer === null; i++) {\n    const b = encoder.bufs[i];\n    if (pos < b.length) {\n      buffer = b; // found buffer\n    } else {\n      pos -= b.length;\n    }\n  }\n  if (buffer === null) {\n    // use current buffer\n    buffer = encoder.cbuf;\n  }\n  buffer[pos] = num;\n};\n\n/**\n * Write one byte as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeUint8 = write;\n\n/**\n * Write one byte as an unsigned Integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nconst setUint8 = set;\n\n/**\n * Write two bytes as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeUint16 = (encoder, num) => {\n  write(encoder, num & binary.BITS8);\n  write(encoder, (num >>> 8) & binary.BITS8);\n};\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nconst setUint16 = (encoder, pos, num) => {\n  set(encoder, pos, num & binary.BITS8);\n  set(encoder, pos + 1, (num >>> 8) & binary.BITS8);\n};\n\n/**\n * Write two bytes as an unsigned integer\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeUint32 = (encoder, num) => {\n  for (let i = 0; i < 4; i++) {\n    write(encoder, num & binary.BITS8);\n    num >>>= 8;\n  }\n};\n\n/**\n * Write two bytes as an unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeUint32BigEndian = (encoder, num) => {\n  for (let i = 3; i >= 0; i--) {\n    write(encoder, (num >>> (8 * i)) & binary.BITS8);\n  }\n};\n\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nconst setUint32 = (encoder, pos, num) => {\n  for (let i = 0; i < 4; i++) {\n    set(encoder, pos + i, num & binary.BITS8);\n    num >>>= 8;\n  }\n};\n\n/**\n * Write a variable length unsigned integer.\n *\n * Encodes integers in the range from [0, 4294967295] / [0, 0xffffffff]. (max 32 bit unsigned integer)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeVarUint = (encoder, num) => {\n  while (num > binary.BITS7) {\n    write(encoder, binary.BIT8 | (binary.BITS7 & num));\n    num >>>= 7;\n  }\n  write(encoder, binary.BITS7 & num);\n};\n\n/**\n * Write a variable length integer.\n *\n * Encodes integers in the range from [-2147483648, -2147483647].\n *\n * We don't use zig-zag encoding because we want to keep the option open\n * to use the same function for BigInt and 53bit integers (doubles).\n *\n * We use the 7th bit instead for signaling that this is a negative number.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeVarInt = (encoder, num) => {\n  const isNegative = math.isNegativeZero(num);\n  if (isNegative) {\n    num = -num;\n  }\n  //             |- whether to continue reading         |- whether is negative     |- number\n  write(encoder, (num > binary.BITS6 ? binary.BIT8 : 0) | (isNegative ? binary.BIT7 : 0) | (binary.BITS6 & num));\n  num >>>= 6;\n  // We don't need to consider the case of num === 0 so we can use a different\n  // pattern here than above.\n  while (num > 0) {\n    write(encoder, (num > binary.BITS7 ? binary.BIT8 : 0) | (binary.BITS7 & num));\n    num >>>= 7;\n  }\n};\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nconst writeVarString = (encoder, str) => {\n  const encodedString = unescape(encodeURIComponent(str));\n  const len = encodedString.length;\n  writeVarUint(encoder, len);\n  for (let i = 0; i < len; i++) {\n    write(encoder, /** @type {number} */ (encodedString.codePointAt(i)));\n  }\n};\n\n/**\n * Write the content of another Encoder.\n *\n * @TODO: can be improved!\n *        - Note: Should consider that when appending a lot of small Encoders, we should rather clone than referencing the old structure.\n *                Encoders start with a rather big initial buffer.\n *\n * @function\n * @param {Encoder} encoder The enUint8Arr\n * @param {Encoder} append The BinaryEncoder to be written.\n */\nconst writeBinaryEncoder = (encoder, append) => writeUint8Array(encoder, toUint8Array(append));\n\n/**\n * Append fixed-length Uint8Array to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nconst writeUint8Array = (encoder, uint8Array) => {\n  const bufferLen = encoder.cbuf.length;\n  const cpos = encoder.cpos;\n  const leftCopyLen = math.min(bufferLen - cpos, uint8Array.length);\n  const rightCopyLen = uint8Array.length - leftCopyLen;\n  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);\n  encoder.cpos += leftCopyLen;\n  if (rightCopyLen > 0) {\n    // Still something to write, write right half..\n    // Append new buffer\n    encoder.bufs.push(encoder.cbuf);\n    // must have at least size of remaining buffer\n    encoder.cbuf = new Uint8Array(math.max(bufferLen * 2, rightCopyLen));\n    // copy array\n    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));\n    encoder.cpos = rightCopyLen;\n  }\n};\n\n/**\n * Append an Uint8Array to Encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nconst writeVarUint8Array = (encoder, uint8Array) => {\n  writeVarUint(encoder, uint8Array.byteLength);\n  writeUint8Array(encoder, uint8Array);\n};\n\n/**\n * Create an DataView of the next `len` bytes. Use it to write data after\n * calling this function.\n *\n * ```js\n * // write float32 using DataView\n * const dv = writeOnDataView(encoder, 4)\n * dv.setFloat32(0, 1.1)\n * // read float32 using DataView\n * const dv = readFromDataView(encoder, 4)\n * dv.getFloat32(0) // => 1.100000023841858 (leaving it to the reader to find out why this is the correct result)\n * ```\n *\n * @param {Encoder} encoder\n * @param {number} len\n * @return {DataView}\n */\nconst writeOnDataView = (encoder, len) => {\n  verifyLen(encoder, len);\n  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len);\n  encoder.cpos += len;\n  return dview\n};\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nconst writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false);\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nconst writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false);\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nconst writeBigInt64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigInt64(0, num, false);\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nconst writeBigUint64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigUint64(0, num, false);\n\nconst floatTestBed = new DataView(new ArrayBuffer(4));\n/**\n * Check if a number can be encoded as a 32 bit float.\n *\n * @param {number} num\n * @return {boolean}\n */\nconst isFloat32 = num => {\n  floatTestBed.setFloat32(0, num);\n  return floatTestBed.getFloat32(0) === num\n};\n\n/**\n * Encode data with efficient binary format.\n *\n * Differences to JSON:\n *  Transforms data to a binary format (not to a string)\n *  Encodes undefined, NaN, and ArrayBuffer (these can't be represented in JSON)\n *  Numbers are efficiently encoded either as a variable length integer, as a\n *   32 bit float, as a 64 bit float, or as a 64 bit bigint.\n *\n * Encoding table:\n *\n * | Data Type           | Prefix   | Encoding Method    | Comment |\n * | ------------------- | -------- | ------------------ | ------- |\n * | undefined           | 127      |                    | Functions, symbol, and everything that cannot be identified is encoded as undefined |\n * | null                | 126      |                    | |\n * | integer             | 125      | writeVarInt        | Only encodes 32 bit signed integers |\n * | float32             | 124      | writeFloat32       | |\n * | float64             | 123      | writeFloat64       | |\n * | bigint              | 122      | writeBigInt64      | |\n * | boolean (false)     | 121      |                    | True and false are different data types so we save the following byte |\n * | boolean (true)      | 120      |                    | - 0b01111000 so the last bit determines whether true or false |\n * | string              | 119      | writeVarString     | |\n * | object<string,any>  | 118      | custom             | Writes {length} then {length} key-value pairs |\n * | array<any>          | 117      | custom             | Writes {length} then {length} json values |\n * | Uint8Array          | 116      | writeVarUint8Array | We use Uint8Array for any kind of binary data |\n *\n * Reasons for the decreasing prefix:\n * We need the first bit for extendability (later we may want to encode the\n * prefix with writeVarUint). The remaining 7 bits are divided as follows:\n * [0-30]   the beginning of the data range is used for custom purposes\n *          (defined by the function that uses this library)\n * [31-127] the end of the data range is used for data encoding by\n *          lib0/encoding.js\n *\n * @param {Encoder} encoder\n * @param {undefined|null|number|bigint|boolean|string|Object<string,any>|Array<any>|Uint8Array} data\n */\nconst writeAny = (encoder, data) => {\n  switch (typeof data) {\n    case 'string':\n      // TYPE 119: STRING\n      write(encoder, 119);\n      writeVarString(encoder, data);\n      break\n    case 'number':\n      if (number.isInteger(data) && data <= binary.BITS31) {\n        // TYPE 125: INTEGER\n        write(encoder, 125);\n        writeVarInt(encoder, data);\n      } else if (isFloat32(data)) {\n        // TYPE 124: FLOAT32\n        write(encoder, 124);\n        writeFloat32(encoder, data);\n      } else {\n        // TYPE 123: FLOAT64\n        write(encoder, 123);\n        writeFloat64(encoder, data);\n      }\n      break\n    case 'bigint':\n      // TYPE 122: BigInt\n      write(encoder, 122);\n      writeBigInt64(encoder, data);\n      break\n    case 'object':\n      if (data === null) {\n        // TYPE 126: null\n        write(encoder, 126);\n      } else if (data instanceof Array) {\n        // TYPE 117: Array\n        write(encoder, 117);\n        writeVarUint(encoder, data.length);\n        for (let i = 0; i < data.length; i++) {\n          writeAny(encoder, data[i]);\n        }\n      } else if (data instanceof Uint8Array) {\n        // TYPE 116: ArrayBuffer\n        write(encoder, 116);\n        writeVarUint8Array(encoder, data);\n      } else {\n        // TYPE 118: Object\n        write(encoder, 118);\n        const keys = Object.keys(data);\n        writeVarUint(encoder, keys.length);\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          writeVarString(encoder, key);\n          writeAny(encoder, data[key]);\n        }\n      }\n      break\n    case 'boolean':\n      // TYPE 120/121: boolean (true/false)\n      write(encoder, data ? 120 : 121);\n      break\n    default:\n      // TYPE 127: undefined\n      write(encoder, 127);\n  }\n};\n\n/**\n * Now come a few stateful encoder that have their own classes.\n */\n\n/**\n * Basic Run Length Encoder - a basic compression implementation.\n *\n * Encodes [1,1,1,7] to [1,3,7,1] (3 times 1, 1 time 7). This encoder might do more harm than good if there are a lot of values that are not repeated.\n *\n * It was originally used for image compression. Cool .. article http://csbruce.com/cbm/transactor/pdfs/trans_v7_i06.pdf\n *\n * @note T must not be null!\n *\n * @template T\n */\nclass RleEncoder extends Encoder {\n  /**\n   * @param {function(Encoder, T):void} writer\n   */\n  constructor (writer) {\n    super();\n    /**\n     * The writer\n     */\n    this.w = writer;\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null;\n    this.count = 0;\n  }\n\n  /**\n   * @param {T} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++;\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1); // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1;\n      // write first value\n      this.w(this, v);\n      this.s = v;\n    }\n  }\n}\n\n/**\n * Basic diff decoder using variable length encoding.\n *\n * Encodes the values [3, 1100, 1101, 1050, 0] to [3, 1097, 1, -51, -1050] using writeVarInt.\n */\nclass IntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super();\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start;\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    writeVarInt(this, v - this.s);\n    this.s = v;\n  }\n}\n\n/**\n * A combination of IntDiffEncoder and RleEncoder.\n *\n * Basically first writes the IntDiffEncoder and then counts duplicate diffs using RleEncoding.\n *\n * Encodes the values [1,1,1,2,3,4,5,6] as [1,1,0,2,1,5] (RLE([1,0,0,1,1,1,1,1])  RleIntDiff[1,1,0,2,1,5])\n */\nclass RleIntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super();\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start;\n    this.count = 0;\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v && this.count > 0) {\n      this.count++;\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1); // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1;\n      // write first value\n      writeVarInt(this, v - this.s);\n      this.s = v;\n    }\n  }\n}\n\n/**\n * @param {UintOptRleEncoder} encoder\n */\nconst flushUintOptRleEncoder = encoder => {\n  /* istanbul ignore else */\n  if (encoder.count > 0) {\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set sign to positive\n    // case 2: write several values. set sign to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s);\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2); // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n};\n\n/**\n * Optimized Rle encoder that does not suffer from the mentioned problem of the basic Rle encoder.\n *\n * Internally uses VarInt encoder to write unsigned integers. If the input occurs multiple times, we write\n * write it as a negative number. The UintOptRleDecoder then understands that it needs to read a count.\n *\n * Encodes [1,2,3,3,3] as [1,2,-3,3] (once 1, once 2, three times 3)\n */\nclass UintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder();\n    /**\n     * @type {number}\n     */\n    this.s = 0;\n    this.count = 0;\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++;\n    } else {\n      flushUintOptRleEncoder(this);\n      this.count = 1;\n      this.s = v;\n    }\n  }\n\n  toUint8Array () {\n    flushUintOptRleEncoder(this);\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Increasing Uint Optimized RLE Encoder\n *\n * The RLE encoder counts the number of same occurences of the same value.\n * The IncUintOptRle encoder counts if the value increases.\n * I.e. 7, 8, 9, 10 will be encoded as [-7, 4]. 1, 3, 5 will be encoded\n * as [1, 3, 5].\n */\nclass IncUintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder();\n    /**\n     * @type {number}\n     */\n    this.s = 0;\n    this.count = 0;\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s + this.count === v) {\n      this.count++;\n    } else {\n      flushUintOptRleEncoder(this);\n      this.count = 1;\n      this.s = v;\n    }\n  }\n\n  toUint8Array () {\n    flushUintOptRleEncoder(this);\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * @param {IntDiffOptRleEncoder} encoder\n */\nconst flushIntDiffOptRleEncoder = encoder => {\n  if (encoder.count > 0) {\n    //          31 bit making up the diff | wether to write the counter\n    const encodedDiff = encoder.diff << 1 | (encoder.count === 1 ? 0 : 1);\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set first bit to positive\n    // case 2: write several values. set first bit to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encodedDiff);\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2); // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n};\n\n/**\n * A combination of the IntDiffEncoder and the UintOptRleEncoder.\n *\n * The count approach is similar to the UintDiffOptRleEncoder, but instead of using the negative bitflag, it encodes\n * in the LSB whether a count is to be read. Therefore this Encoder only supports 31 bit integers!\n *\n * Encodes [1, 2, 3, 2] as [3, 1, 6, -1] (more specifically [(1 << 1) | 1, (3 << 0) | 0, -1])\n *\n * Internally uses variable length encoding. Contrary to normal UintVar encoding, the first byte contains:\n * * 1 bit that denotes whether the next value is a count (LSB)\n * * 1 bit that denotes whether this value is negative (MSB - 1)\n * * 1 bit that denotes whether to continue reading the variable length integer (MSB)\n *\n * Therefore, only five bits remain to encode diff ranges.\n *\n * Use this Encoder only when appropriate. In most cases, this is probably a bad idea.\n */\nclass IntDiffOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder();\n    /**\n     * @type {number}\n     */\n    this.s = 0;\n    this.count = 0;\n    this.diff = 0;\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.diff === v - this.s) {\n      this.s = v;\n      this.count++;\n    } else {\n      flushIntDiffOptRleEncoder(this);\n      this.count = 1;\n      this.diff = v - this.s;\n      this.s = v;\n    }\n  }\n\n  toUint8Array () {\n    flushIntDiffOptRleEncoder(this);\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Optimized String Encoder.\n *\n * Encoding many small strings in a simple Encoder is not very efficient. The function call to decode a string takes some time and creates references that must be eventually deleted.\n * In practice, when decoding several million small strings, the GC will kick in more and more often to collect orphaned string objects (or maybe there is another reason?).\n *\n * This string encoder solves the above problem. All strings are concatenated and written as a single string using a single encoding call.\n *\n * The lengths are encoded using a UintOptRleEncoder.\n */\nclass StringEncoder {\n  constructor () {\n    /**\n     * @type {Array<string>}\n     */\n    this.sarr = [];\n    this.s = '';\n    this.lensE = new UintOptRleEncoder();\n  }\n\n  /**\n   * @param {string} string\n   */\n  write (string) {\n    this.s += string;\n    if (this.s.length > 19) {\n      this.sarr.push(this.s);\n      this.s = '';\n    }\n    this.lensE.write(string.length);\n  }\n\n  toUint8Array () {\n    const encoder = new Encoder();\n    this.sarr.push(this.s);\n    this.s = '';\n    writeVarString(encoder, this.sarr.join(''));\n    writeUint8Array(encoder, this.lensE.toUint8Array());\n    return toUint8Array(encoder)\n  }\n}\n\nvar encoding = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  Encoder: Encoder,\n  createEncoder: createEncoder,\n  length: length,\n  toUint8Array: toUint8Array,\n  write: write,\n  set: set,\n  writeUint8: writeUint8,\n  setUint8: setUint8,\n  writeUint16: writeUint16,\n  setUint16: setUint16,\n  writeUint32: writeUint32,\n  writeUint32BigEndian: writeUint32BigEndian,\n  setUint32: setUint32,\n  writeVarUint: writeVarUint,\n  writeVarInt: writeVarInt,\n  writeVarString: writeVarString,\n  writeBinaryEncoder: writeBinaryEncoder,\n  writeUint8Array: writeUint8Array,\n  writeVarUint8Array: writeVarUint8Array,\n  writeOnDataView: writeOnDataView,\n  writeFloat32: writeFloat32,\n  writeFloat64: writeFloat64,\n  writeBigInt64: writeBigInt64,\n  writeBigUint64: writeBigUint64,\n  writeAny: writeAny,\n  RleEncoder: RleEncoder,\n  IntDiffEncoder: IntDiffEncoder,\n  RleIntDiffEncoder: RleIntDiffEncoder,\n  UintOptRleEncoder: UintOptRleEncoder,\n  IncUintOptRleEncoder: IncUintOptRleEncoder,\n  IntDiffOptRleEncoder: IntDiffOptRleEncoder,\n  StringEncoder: StringEncoder\n});\n\n/**\n * Efficient schema-less binary decoding with support for variable length encoding.\n *\n * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = new encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = new decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module decoding\n */\n\n/**\n * A Decoder handles the decoding of an Uint8Array.\n */\nclass Decoder {\n  /**\n   * @param {Uint8Array} uint8Array Binary data to decode\n   */\n  constructor (uint8Array) {\n    /**\n     * Decoding target.\n     *\n     * @type {Uint8Array}\n     */\n    this.arr = uint8Array;\n    /**\n     * Current decoding position.\n     *\n     * @type {number}\n     */\n    this.pos = 0;\n  }\n}\n\n/**\n * @function\n * @param {Uint8Array} uint8Array\n * @return {Decoder}\n */\nconst createDecoder = uint8Array => new Decoder(uint8Array);\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {boolean}\n */\nconst hasContent = decoder => decoder.pos !== decoder.arr.length;\n\n/**\n * Clone a decoder instance.\n * Optionally set a new position parameter.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} [newPos] Defaults to current position\n * @return {Decoder} A clone of `decoder`\n */\nconst clone = (decoder, newPos = decoder.pos) => {\n  const _decoder = createDecoder(decoder.arr);\n  _decoder.pos = newPos;\n  return _decoder\n};\n\n/**\n * Create an Uint8Array view of the next `len` bytes and advance the position by `len`.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} len The length of bytes to read\n * @return {Uint8Array}\n */\nconst readUint8Array = (decoder, len) => {\n  const view = createUint8ArrayViewFromArrayBuffer(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);\n  decoder.pos += len;\n  return view\n};\n\n/**\n * Read variable length Uint8Array.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nconst readVarUint8Array = decoder => readUint8Array(decoder, readVarUint(decoder));\n\n/**\n * Read the rest of the content as an ArrayBuffer\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nconst readTailAsUint8Array = decoder => readUint8Array(decoder, decoder.arr.length - decoder.pos);\n\n/**\n * Skip one byte, jump to the next position.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} The next position\n */\nconst skip8 = decoder => decoder.pos++;\n\n/**\n * Read one byte as unsigned integer.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} Unsigned 8-bit integer\n */\nconst readUint8 = decoder => decoder.arr[decoder.pos++];\n\n/**\n * Read 2 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst readUint16 = decoder => {\n  const uint =\n    decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8);\n  decoder.pos += 2;\n  return uint\n};\n\n/**\n * Read 4 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst readUint32 = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8) +\n    (decoder.arr[decoder.pos + 2] << 16) +\n    (decoder.arr[decoder.pos + 3] << 24)) >>> 0;\n  decoder.pos += 4;\n  return uint\n};\n\n/**\n * Read 4 bytes as unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst readUint32BigEndian = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos + 3] +\n    (decoder.arr[decoder.pos + 2] << 8) +\n    (decoder.arr[decoder.pos + 1] << 16) +\n    (decoder.arr[decoder.pos] << 24)) >>> 0;\n  decoder.pos += 4;\n  return uint\n};\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst peekUint8 = decoder => decoder.arr[decoder.pos];\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst peekUint16 = decoder =>\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8);\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst peekUint32 = decoder => (\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8) +\n  (decoder.arr[decoder.pos + 2] << 16) +\n  (decoder.arr[decoder.pos + 3] << 24)\n) >>> 0;\n\n/**\n * Read unsigned integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nconst readVarUint = decoder => {\n  let num = 0;\n  let len = 0;\n  while (true) {\n    const r = decoder.arr[decoder.pos++];\n    num = num | ((r & binary.BITS7) << len);\n    len += 7;\n    if (r < binary.BIT8) {\n      return num >>> 0 // return unsigned number!\n    }\n    /* istanbul ignore if */\n    if (len > 35) {\n      throw new Error('Integer out of range!')\n    }\n  }\n};\n\n/**\n * Read signed integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n * @todo This should probably create the inverse ~num if number is negative - but this would be a breaking change.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nconst readVarInt = decoder => {\n  let r = decoder.arr[decoder.pos++];\n  let num = r & binary.BITS6;\n  let len = 6;\n  const sign = (r & binary.BIT7) > 0 ? -1 : 1;\n  if ((r & binary.BIT8) === 0) {\n    // don't continue reading\n    return sign * num\n  }\n  while (true) {\n    r = decoder.arr[decoder.pos++];\n    num = num | ((r & binary.BITS7) << len);\n    len += 7;\n    if (r < binary.BIT8) {\n      return sign * (num >>> 0)\n    }\n    /* istanbul ignore if */\n    if (len > 41) {\n      throw new Error('Integer out of range!')\n    }\n  }\n};\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nconst peekVarUint = decoder => {\n  const pos = decoder.pos;\n  const s = readVarUint(decoder);\n  decoder.pos = pos;\n  return s\n};\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nconst peekVarInt = decoder => {\n  const pos = decoder.pos;\n  const s = readVarInt(decoder);\n  decoder.pos = pos;\n  return s\n};\n\n/**\n * Read string of variable length\n * * varUint is used to store the length of the string\n *\n * Transforming utf8 to a string is pretty expensive. The code performs 10x better\n * when String.fromCodePoint is fed with all characters as arguments.\n * But most environments have a maximum number of arguments per functions.\n * For effiency reasons we apply a maximum of 10000 characters at once.\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String.\n */\nconst readVarString = decoder => {\n  let remainingLen = readVarUint(decoder);\n  if (remainingLen === 0) {\n    return ''\n  } else {\n    let encodedString = String.fromCodePoint(readUint8(decoder)); // remember to decrease remainingLen\n    if (--remainingLen < 100) { // do not create a Uint8Array for small strings\n      while (remainingLen--) {\n        encodedString += String.fromCodePoint(readUint8(decoder));\n      }\n    } else {\n      while (remainingLen > 0) {\n        const nextLen = remainingLen < 10000 ? remainingLen : 10000;\n        // this is dangerous, we create a fresh array view from the existing buffer\n        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);\n        decoder.pos += nextLen;\n        // Starting with ES5.1 we can supply a generic array-like object as arguments\n        encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes));\n        remainingLen -= nextLen;\n      }\n    }\n    return decodeURIComponent(escape(encodedString))\n  }\n};\n\n/**\n * Look ahead and read varString without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {string}\n */\nconst peekVarString = decoder => {\n  const pos = decoder.pos;\n  const s = readVarString(decoder);\n  decoder.pos = pos;\n  return s\n};\n\n/**\n * @param {Decoder} decoder\n * @param {number} len\n * @return {DataView}\n */\nconst readFromDataView = (decoder, len) => {\n  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len);\n  decoder.pos += len;\n  return dv\n};\n\n/**\n * @param {Decoder} decoder\n */\nconst readFloat32 = decoder => readFromDataView(decoder, 4).getFloat32(0, false);\n\n/**\n * @param {Decoder} decoder\n */\nconst readFloat64 = decoder => readFromDataView(decoder, 8).getFloat64(0, false);\n\n/**\n * @param {Decoder} decoder\n */\nconst readBigInt64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigInt64(0, false);\n\n/**\n * @param {Decoder} decoder\n */\nconst readBigUint64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigUint64(0, false);\n\n/**\n * @type {Array<function(Decoder):any>}\n */\nconst readAnyLookupTable = [\n  decoder => undefined, // CASE 127: undefined\n  decoder => null, // CASE 126: null\n  readVarInt, // CASE 125: integer\n  readFloat32, // CASE 124: float32\n  readFloat64, // CASE 123: float64\n  readBigInt64, // CASE 122: bigint\n  decoder => false, // CASE 121: boolean (false)\n  decoder => true, // CASE 120: boolean (true)\n  readVarString, // CASE 119: string\n  decoder => { // CASE 118: object<string,any>\n    const len = readVarUint(decoder);\n    /**\n     * @type {Object<string,any>}\n     */\n    const obj = {};\n    for (let i = 0; i < len; i++) {\n      const key = readVarString(decoder);\n      obj[key] = readAny(decoder);\n    }\n    return obj\n  },\n  decoder => { // CASE 117: array<any>\n    const len = readVarUint(decoder);\n    const arr = [];\n    for (let i = 0; i < len; i++) {\n      arr.push(readAny(decoder));\n    }\n    return arr\n  },\n  readVarUint8Array // CASE 116: Uint8Array\n];\n\n/**\n * @param {Decoder} decoder\n */\nconst readAny = decoder => readAnyLookupTable[127 - readUint8(decoder)](decoder);\n\n/**\n * T must not be null.\n *\n * @template T\n */\nclass RleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {function(Decoder):T} reader\n   */\n  constructor (uint8Array, reader) {\n    super(uint8Array);\n    /**\n     * The reader\n     */\n    this.reader = reader;\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null;\n    this.count = 0;\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = this.reader(this);\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1; // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1; // read the current value forever\n      }\n    }\n    this.count--;\n    return /** @type {T} */ (this.s)\n  }\n}\n\nclass IntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array);\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start;\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    this.s += readVarInt(this);\n    return this.s\n  }\n}\n\nclass RleIntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array);\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start;\n    this.count = 0;\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      this.s += readVarInt(this);\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1; // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1; // read the current value forever\n      }\n    }\n    this.count--;\n    return /** @type {number} */ (this.s)\n  }\n}\n\nclass UintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array);\n    /**\n     * @type {number}\n     */\n    this.s = 0;\n    this.count = 0;\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this);\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = math.isNegativeZero(this.s);\n      this.count = 1;\n      if (isNegative) {\n        this.s = -this.s;\n        this.count = readVarUint(this) + 2;\n      }\n    }\n    this.count--;\n    return /** @type {number} */ (this.s)\n  }\n}\n\nclass IncUintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array);\n    /**\n     * @type {number}\n     */\n    this.s = 0;\n    this.count = 0;\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this);\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = math.isNegativeZero(this.s);\n      this.count = 1;\n      if (isNegative) {\n        this.s = -this.s;\n        this.count = readVarUint(this) + 2;\n      }\n    }\n    this.count--;\n    return /** @type {number} */ (this.s++)\n  }\n}\n\nclass IntDiffOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array);\n    /**\n     * @type {number}\n     */\n    this.s = 0;\n    this.count = 0;\n    this.diff = 0;\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      const diff = readVarInt(this);\n      // if the first bit is set, we read more data\n      const hasCount = diff & 1;\n      this.diff = diff >> 1;\n      this.count = 1;\n      if (hasCount) {\n        this.count = readVarUint(this) + 2;\n      }\n    }\n    this.s += this.diff;\n    this.count--;\n    return this.s\n  }\n}\n\nclass StringDecoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    this.decoder = new UintOptRleDecoder(uint8Array);\n    this.str = readVarString(this.decoder);\n    /**\n     * @type {number}\n     */\n    this.spos = 0;\n  }\n\n  /**\n   * @return {string}\n   */\n  read () {\n    const end = this.spos + this.decoder.read();\n    const res = this.str.slice(this.spos, end);\n    this.spos = end;\n    return res\n  }\n}\n\nvar decoding = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  Decoder: Decoder,\n  createDecoder: createDecoder,\n  hasContent: hasContent,\n  clone: clone,\n  readUint8Array: readUint8Array,\n  readVarUint8Array: readVarUint8Array,\n  readTailAsUint8Array: readTailAsUint8Array,\n  skip8: skip8,\n  readUint8: readUint8,\n  readUint16: readUint16,\n  readUint32: readUint32,\n  readUint32BigEndian: readUint32BigEndian,\n  peekUint8: peekUint8,\n  peekUint16: peekUint16,\n  peekUint32: peekUint32,\n  readVarUint: readVarUint,\n  readVarInt: readVarInt,\n  peekVarUint: peekVarUint,\n  peekVarInt: peekVarInt,\n  readVarString: readVarString,\n  peekVarString: peekVarString,\n  readFromDataView: readFromDataView,\n  readFloat32: readFloat32,\n  readFloat64: readFloat64,\n  readBigInt64: readBigInt64,\n  readBigUint64: readBigUint64,\n  readAny: readAny,\n  RleDecoder: RleDecoder,\n  IntDiffDecoder: IntDiffDecoder,\n  RleIntDiffDecoder: RleIntDiffDecoder,\n  UintOptRleDecoder: UintOptRleDecoder,\n  IncUintOptRleDecoder: IncUintOptRleDecoder,\n  IntDiffOptRleDecoder: IntDiffOptRleDecoder,\n  StringDecoder: StringDecoder\n});\n\n/**\n * Utility functions to work with buffers (Uint8Array).\n *\n * @module buffer\n */\n\n/**\n * @param {number} len\n */\nconst createUint8ArrayFromLen = len => new Uint8Array(len);\n\n/**\n * Create Uint8Array with initial content from buffer\n *\n * @param {ArrayBuffer} buffer\n * @param {number} byteOffset\n * @param {number} length\n */\nconst createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length) => new Uint8Array(buffer, byteOffset, length);\n\n/**\n * Create Uint8Array with initial content from buffer\n *\n * @param {ArrayBuffer} buffer\n */\nconst createUint8ArrayFromArrayBuffer = buffer => new Uint8Array(buffer);\n\n/* istanbul ignore next */\n/**\n * @param {Uint8Array} bytes\n * @return {string}\n */\nconst toBase64Browser = bytes => {\n  let s = '';\n  for (let i = 0; i < bytes.byteLength; i++) {\n    s += string.fromCharCode(bytes[i]);\n  }\n  // eslint-disable-next-line no-undef\n  return btoa(s)\n};\n\n/**\n * @param {Uint8Array} bytes\n * @return {string}\n */\nconst toBase64Node = bytes => Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString('base64');\n\n/* istanbul ignore next */\n/**\n * @param {string} s\n * @return {Uint8Array}\n */\nconst fromBase64Browser = s => {\n  // eslint-disable-next-line no-undef\n  const a = atob(s);\n  const bytes = createUint8ArrayFromLen(a.length);\n  for (let i = 0; i < a.length; i++) {\n    bytes[i] = a.charCodeAt(i);\n  }\n  return bytes\n};\n\n/**\n * @param {string} s\n */\nconst fromBase64Node = s => {\n  const buf = Buffer.from(s, 'base64');\n  return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength)\n};\n\n/* istanbul ignore next */\nconst toBase64 = environment.isBrowser ? toBase64Browser : toBase64Node;\n\n/* istanbul ignore next */\nconst fromBase64 = environment.isBrowser ? fromBase64Browser : fromBase64Node;\n\n/**\n * Copy the content of an Uint8Array view to a new ArrayBuffer.\n *\n * @param {Uint8Array} uint8Array\n * @return {Uint8Array}\n */\nconst copyUint8Array = uint8Array => {\n  const newBuf = createUint8ArrayFromLen(uint8Array.byteLength);\n  newBuf.set(uint8Array);\n  return newBuf\n};\n\n/**\n * Encode anything as a UInt8Array. It's a pun on typescripts's `any` type.\n * See encoding.writeAny for more information.\n *\n * @param {any} data\n * @return {Uint8Array}\n */\nconst encodeAny = data => {\n  const encoder = createEncoder();\n  writeAny(encoder, data);\n  return toUint8Array(encoder)\n};\n\n/**\n * Decode an any-encoded value.\n *\n * @param {Uint8Array} buf\n * @return {any}\n */\nconst decodeAny = buf => readAny(createDecoder(buf));\n\nvar buffer = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  createUint8ArrayFromLen: createUint8ArrayFromLen,\n  createUint8ArrayViewFromArrayBuffer: createUint8ArrayViewFromArrayBuffer,\n  createUint8ArrayFromArrayBuffer: createUint8ArrayFromArrayBuffer,\n  toBase64: toBase64,\n  fromBase64: fromBase64,\n  copyUint8Array: copyUint8Array,\n  encodeAny: encodeAny,\n  decodeAny: decodeAny\n});\n\nexports.Decoder = Decoder;\nexports.Encoder = Encoder;\nexports.IncUintOptRleDecoder = IncUintOptRleDecoder;\nexports.IncUintOptRleEncoder = IncUintOptRleEncoder;\nexports.IntDiffDecoder = IntDiffDecoder;\nexports.IntDiffEncoder = IntDiffEncoder;\nexports.IntDiffOptRleDecoder = IntDiffOptRleDecoder;\nexports.IntDiffOptRleEncoder = IntDiffOptRleEncoder;\nexports.RleDecoder = RleDecoder;\nexports.RleEncoder = RleEncoder;\nexports.RleIntDiffDecoder = RleIntDiffDecoder;\nexports.RleIntDiffEncoder = RleIntDiffEncoder;\nexports.StringDecoder = StringDecoder;\nexports.StringEncoder = StringEncoder;\nexports.UintOptRleDecoder = UintOptRleDecoder;\nexports.UintOptRleEncoder = UintOptRleEncoder;\nexports.buffer = buffer;\nexports.clone = clone;\nexports.copyUint8Array = copyUint8Array;\nexports.createDecoder = createDecoder;\nexports.createEncoder = createEncoder;\nexports.createUint8ArrayFromArrayBuffer = createUint8ArrayFromArrayBuffer;\nexports.createUint8ArrayFromLen = createUint8ArrayFromLen;\nexports.createUint8ArrayViewFromArrayBuffer = createUint8ArrayViewFromArrayBuffer;\nexports.decodeAny = decodeAny;\nexports.decoding = decoding;\nexports.encodeAny = encodeAny;\nexports.encoding = encoding;\nexports.fromBase64 = fromBase64;\nexports.hasContent = hasContent;\nexports.length = length;\nexports.peekUint16 = peekUint16;\nexports.peekUint32 = peekUint32;\nexports.peekUint8 = peekUint8;\nexports.peekVarInt = peekVarInt;\nexports.peekVarString = peekVarString;\nexports.peekVarUint = peekVarUint;\nexports.readAny = readAny;\nexports.readBigInt64 = readBigInt64;\nexports.readBigUint64 = readBigUint64;\nexports.readFloat32 = readFloat32;\nexports.readFloat64 = readFloat64;\nexports.readFromDataView = readFromDataView;\nexports.readTailAsUint8Array = readTailAsUint8Array;\nexports.readUint16 = readUint16;\nexports.readUint32 = readUint32;\nexports.readUint32BigEndian = readUint32BigEndian;\nexports.readUint8 = readUint8;\nexports.readUint8Array = readUint8Array;\nexports.readVarInt = readVarInt;\nexports.readVarString = readVarString;\nexports.readVarUint = readVarUint;\nexports.readVarUint8Array = readVarUint8Array;\nexports.set = set;\nexports.setUint16 = setUint16;\nexports.setUint32 = setUint32;\nexports.setUint8 = setUint8;\nexports.skip8 = skip8;\nexports.toBase64 = toBase64;\nexports.toUint8Array = toUint8Array;\nexports.write = write;\nexports.writeAny = writeAny;\nexports.writeBigInt64 = writeBigInt64;\nexports.writeBigUint64 = writeBigUint64;\nexports.writeBinaryEncoder = writeBinaryEncoder;\nexports.writeFloat32 = writeFloat32;\nexports.writeFloat64 = writeFloat64;\nexports.writeOnDataView = writeOnDataView;\nexports.writeUint16 = writeUint16;\nexports.writeUint32 = writeUint32;\nexports.writeUint32BigEndian = writeUint32BigEndian;\nexports.writeUint8 = writeUint8;\nexports.writeUint8Array = writeUint8Array;\nexports.writeVarInt = writeVarInt;\nexports.writeVarString = writeVarString;\nexports.writeVarUint = writeVarUint;\nexports.writeVarUint8Array = writeVarUint8Array;\n//# sourceMappingURL=buffer-ac2cdedf.cjs.map\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    var proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    var copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        Buffer.from(buf).copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (var i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nvar hexSliceLookupTable = (function () {\n  var alphabet = '0123456789abcdef'\n  var table = new Array(256)\n  for (var i = 0; i < 16; ++i) {\n    var i16 = i * 16\n    for (var j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","'use strict';\n\n/**\n * Utility module to work with strings.\n *\n * @module string\n */\n\nconst fromCharCode = String.fromCharCode;\nconst fromCodePoint = String.fromCodePoint;\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst toLowerCase = s => s.toLowerCase();\n\nconst trimLeftRegex = /^\\s*/g;\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst trimLeft = s => s.replace(trimLeftRegex, '');\n\nconst fromCamelCaseRegex = /([A-Z])/g;\n\n/**\n * @param {string} s\n * @param {string} separator\n * @return {string}\n */\nconst fromCamelCase = (s, separator) => trimLeft(s.replace(fromCamelCaseRegex, match => `${separator}${toLowerCase(match)}`));\n\n/**\n * Compute the utf8ByteLength\n * @param {string} str\n * @return {number}\n */\nconst utf8ByteLength = str => unescape(encodeURIComponent(str)).length;\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nconst _encodeUtf8Polyfill = str => {\n  const encodedString = unescape(encodeURIComponent(str));\n  const len = encodedString.length;\n  const buf = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    buf[i] = /** @type {number} */ (encodedString.codePointAt(i));\n  }\n  return buf\n};\n\n/* istanbul ignore next */\nconst utf8TextEncoder = /** @type {TextEncoder} */ (typeof TextEncoder !== 'undefined' ? new TextEncoder() : null);\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nconst _encodeUtf8Native = str => utf8TextEncoder.encode(str);\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\n/* istanbul ignore next */\nconst encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\nconst _decodeUtf8Polyfill = buf => {\n  let remainingLen = buf.length;\n  let encodedString = '';\n  let bufPos = 0;\n  while (remainingLen > 0) {\n    const nextLen = remainingLen < 10000 ? remainingLen : 10000;\n    const bytes = buf.subarray(bufPos, bufPos + nextLen);\n    bufPos += nextLen;\n    // Starting with ES5.1 we can supply a generic array-like object as arguments\n    encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes));\n    remainingLen -= nextLen;\n  }\n  return decodeURIComponent(escape(encodedString))\n};\n\n/* istanbul ignore next */\nexports.utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8', { fatal: true, ignoreBOM: true });\n\n/* istanbul ignore next */\nif (exports.utf8TextDecoder && exports.utf8TextDecoder.decode(new Uint8Array()).length === 1) {\n  // Safari doesn't handle BOM correctly.\n  // This fixes a bug in Safari 13.0.5 where it produces a BOM the first time it is called.\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the first call and\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the second call\n  // Another issue is that from then on no BOM chars are recognized anymore\n  /* istanbul ignore next */\n  exports.utf8TextDecoder = null;\n}\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\nconst _decodeUtf8Native = buf => /** @type {TextDecoder} */ (exports.utf8TextDecoder).decode(buf);\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\n/* istanbul ignore next */\nconst decodeUtf8 = exports.utf8TextDecoder ? _decodeUtf8Native : _decodeUtf8Polyfill;\n\nvar string = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  fromCharCode: fromCharCode,\n  fromCodePoint: fromCodePoint,\n  trimLeft: trimLeft,\n  fromCamelCase: fromCamelCase,\n  utf8ByteLength: utf8ByteLength,\n  _encodeUtf8Polyfill: _encodeUtf8Polyfill,\n  utf8TextEncoder: utf8TextEncoder,\n  _encodeUtf8Native: _encodeUtf8Native,\n  encodeUtf8: encodeUtf8,\n  _decodeUtf8Polyfill: _decodeUtf8Polyfill,\n  get utf8TextDecoder () { return exports.utf8TextDecoder; },\n  _decodeUtf8Native: _decodeUtf8Native,\n  decodeUtf8: decodeUtf8\n});\n\nexports._decodeUtf8Native = _decodeUtf8Native;\nexports._decodeUtf8Polyfill = _decodeUtf8Polyfill;\nexports._encodeUtf8Native = _encodeUtf8Native;\nexports._encodeUtf8Polyfill = _encodeUtf8Polyfill;\nexports.decodeUtf8 = decodeUtf8;\nexports.encodeUtf8 = encodeUtf8;\nexports.fromCamelCase = fromCamelCase;\nexports.fromCharCode = fromCharCode;\nexports.fromCodePoint = fromCodePoint;\nexports.string = string;\nexports.trimLeft = trimLeft;\nexports.utf8ByteLength = utf8ByteLength;\nexports.utf8TextEncoder = utf8TextEncoder;\n//# sourceMappingURL=string-f3c3d805.cjs.map\n","'use strict';\n\nvar map = require('./map-28a001c9.cjs');\nvar string = require('./string-f3c3d805.cjs');\nvar conditions = require('./conditions-fb475c70.cjs');\nvar storage = require('./storage.cjs');\n\n/**\n * Isomorphic module to work access the environment (query params, env variables).\n *\n * @module map\n */\n\n/* istanbul ignore next */\n// @ts-ignore\nconst isNode = typeof process !== 'undefined' && process.release && /node|io\\.js/.test(process.release.name);\n/* istanbul ignore next */\nconst isBrowser = typeof window !== 'undefined' && !isNode;\n/* istanbul ignore next */\nconst isMac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;\n\n/**\n * @type {Map<string,string>}\n */\nlet params;\n\n/* istanbul ignore next */\nconst computeParams = () => {\n  if (params === undefined) {\n    if (isNode) {\n      params = map.create();\n      const pargs = process.argv;\n      let currParamName = null;\n      /* istanbul ignore next */\n      for (let i = 0; i < pargs.length; i++) {\n        const parg = pargs[i];\n        if (parg[0] === '-') {\n          if (currParamName !== null) {\n            params.set(currParamName, '');\n          }\n          currParamName = parg;\n        } else {\n          if (currParamName !== null) {\n            params.set(currParamName, parg);\n            currParamName = null;\n          }\n        }\n      }\n      if (currParamName !== null) {\n        params.set(currParamName, '');\n      }\n    // in ReactNative for example this would not be true (unless connected to the Remote Debugger)\n    } else if (typeof location === 'object') {\n      params = map.create()\n      // eslint-disable-next-line no-undef\n      ;(location.search || '?').slice(1).split('&').forEach(kv => {\n        if (kv.length !== 0) {\n          const [key, value] = kv.split('=');\n          params.set(`--${string.fromCamelCase(key, '-')}`, value);\n          params.set(`-${string.fromCamelCase(key, '-')}`, value);\n        }\n      });\n    } else {\n      params = map.create();\n    }\n  }\n  return params\n};\n\n/**\n * @param {string} name\n * @return {boolean}\n */\n/* istanbul ignore next */\nconst hasParam = name => computeParams().has(name);\n\n/**\n * @param {string} name\n * @param {string} defaultVal\n * @return {string}\n */\n/* istanbul ignore next */\nconst getParam = (name, defaultVal) => computeParams().get(name) || defaultVal;\n// export const getArgs = name => computeParams() && args\n\n/**\n * @param {string} name\n * @return {string|null}\n */\n/* istanbul ignore next */\nconst getVariable = name => isNode ? conditions.undefinedToNull(process.env[name.toUpperCase()]) : conditions.undefinedToNull(storage.varStorage.getItem(name));\n\n/**\n * @param {string} name\n * @return {string|null}\n */\nconst getConf = name => computeParams().get('--' + name) || getVariable(name);\n\n/**\n * @param {string} name\n * @return {boolean}\n */\n/* istanbul ignore next */\nconst hasConf = name => hasParam('--' + name) || getVariable(name) !== null;\n\n/* istanbul ignore next */\nconst production = hasConf('production');\n\nvar environment = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  isNode: isNode,\n  isBrowser: isBrowser,\n  isMac: isMac,\n  hasParam: hasParam,\n  getParam: getParam,\n  getVariable: getVariable,\n  getConf: getConf,\n  hasConf: hasConf,\n  production: production\n});\n\nexports.environment = environment;\nexports.getConf = getConf;\nexports.getParam = getParam;\nexports.getVariable = getVariable;\nexports.hasConf = hasConf;\nexports.hasParam = hasParam;\nexports.isBrowser = isBrowser;\nexports.isMac = isMac;\nexports.isNode = isNode;\nexports.production = production;\n//# sourceMappingURL=environment-7e2ffaea.cjs.map\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","'use strict';\n\n/**\n * Often used conditions.\n *\n * @module conditions\n */\n\n/**\n * @template T\n * @param {T|null|undefined} v\n * @return {T|null}\n */\n/* istanbul ignore next */\nconst undefinedToNull = v => v === undefined ? null : v;\n\nvar conditions = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tundefinedToNull: undefinedToNull\n});\n\nexports.conditions = conditions;\nexports.undefinedToNull = undefinedToNull;\n//# sourceMappingURL=conditions-fb475c70.cjs.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/* global localStorage, addEventListener */\n\n/**\n * Isomorphic variable storage.\n *\n * Uses LocalStorage in the browser and falls back to in-memory storage.\n *\n * @module storage\n */\n\n/* istanbul ignore next */\nclass VarStoragePolyfill {\n  constructor () {\n    this.map = new Map();\n  }\n\n  /**\n   * @param {string} key\n   * @param {any} newValue\n   */\n  setItem (key, newValue) {\n    this.map.set(key, newValue);\n  }\n\n  /**\n   * @param {string} key\n   */\n  getItem (key) {\n    return this.map.get(key)\n  }\n}\n\n/* istanbul ignore next */\n/**\n * @type {any}\n */\nlet _localStorage = new VarStoragePolyfill();\nlet usePolyfill = true;\n\ntry {\n  // if the same-origin rule is violated, accessing localStorage might thrown an error\n  /* istanbul ignore next */\n  if (typeof localStorage !== 'undefined') {\n    _localStorage = localStorage;\n    usePolyfill = false;\n  }\n} catch (e) { }\n\n/* istanbul ignore next */\n/**\n * This is basically localStorage in browser, or a polyfill in nodejs\n */\nconst varStorage = _localStorage;\n\n/* istanbul ignore next */\n/**\n * A polyfill for `addEventListener('storage', event => {..})` that does nothing if the polyfill is being used.\n *\n * @param {function({ key: string, newValue: string, oldValue: string }): void} eventHandler\n * @function\n */\nconst onChange = eventHandler => usePolyfill || addEventListener('storage', /** @type {any} */ (eventHandler));\n\nexports.onChange = onChange;\nexports.varStorage = varStorage;\n//# sourceMappingURL=storage.cjs.map\n","'use strict';\n\n/* eslint-env browser */\n\n/**\n * Binary data constants.\n *\n * @module binary\n */\n\n/**\n * n-th bit activated.\n *\n * @type {number}\n */\nconst BIT1 = 1;\nconst BIT2 = 2;\nconst BIT3 = 4;\nconst BIT4 = 8;\nconst BIT5 = 16;\nconst BIT6 = 32;\nconst BIT7 = 64;\nconst BIT8 = 128;\nconst BIT9 = 256;\nconst BIT10 = 512;\nconst BIT11 = 1024;\nconst BIT12 = 2048;\nconst BIT13 = 4096;\nconst BIT14 = 8192;\nconst BIT15 = 16384;\nconst BIT16 = 32768;\nconst BIT17 = 65536;\nconst BIT18 = 1 << 17;\nconst BIT19 = 1 << 18;\nconst BIT20 = 1 << 19;\nconst BIT21 = 1 << 20;\nconst BIT22 = 1 << 21;\nconst BIT23 = 1 << 22;\nconst BIT24 = 1 << 23;\nconst BIT25 = 1 << 24;\nconst BIT26 = 1 << 25;\nconst BIT27 = 1 << 26;\nconst BIT28 = 1 << 27;\nconst BIT29 = 1 << 28;\nconst BIT30 = 1 << 29;\nconst BIT31 = 1 << 30;\nconst BIT32 = 1 << 31;\n\n/**\n * First n bits activated.\n *\n * @type {number}\n */\nconst BITS0 = 0;\nconst BITS1 = 1;\nconst BITS2 = 3;\nconst BITS3 = 7;\nconst BITS4 = 15;\nconst BITS5 = 31;\nconst BITS6 = 63;\nconst BITS7 = 127;\nconst BITS8 = 255;\nconst BITS9 = 511;\nconst BITS10 = 1023;\nconst BITS11 = 2047;\nconst BITS12 = 4095;\nconst BITS13 = 8191;\nconst BITS14 = 16383;\nconst BITS15 = 32767;\nconst BITS16 = 65535;\nconst BITS17 = BIT18 - 1;\nconst BITS18 = BIT19 - 1;\nconst BITS19 = BIT20 - 1;\nconst BITS20 = BIT21 - 1;\nconst BITS21 = BIT22 - 1;\nconst BITS22 = BIT23 - 1;\nconst BITS23 = BIT24 - 1;\nconst BITS24 = BIT25 - 1;\nconst BITS25 = BIT26 - 1;\nconst BITS26 = BIT27 - 1;\nconst BITS27 = BIT28 - 1;\nconst BITS28 = BIT29 - 1;\nconst BITS29 = BIT30 - 1;\nconst BITS30 = BIT31 - 1;\n/**\n * @type {number}\n */\nconst BITS31 = 0x7FFFFFFF;\n/**\n * @type {number}\n */\nconst BITS32 = 0xFFFFFFFF;\n\nvar binary = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tBIT1: BIT1,\n\tBIT2: BIT2,\n\tBIT3: BIT3,\n\tBIT4: BIT4,\n\tBIT5: BIT5,\n\tBIT6: BIT6,\n\tBIT7: BIT7,\n\tBIT8: BIT8,\n\tBIT9: BIT9,\n\tBIT10: BIT10,\n\tBIT11: BIT11,\n\tBIT12: BIT12,\n\tBIT13: BIT13,\n\tBIT14: BIT14,\n\tBIT15: BIT15,\n\tBIT16: BIT16,\n\tBIT17: BIT17,\n\tBIT18: BIT18,\n\tBIT19: BIT19,\n\tBIT20: BIT20,\n\tBIT21: BIT21,\n\tBIT22: BIT22,\n\tBIT23: BIT23,\n\tBIT24: BIT24,\n\tBIT25: BIT25,\n\tBIT26: BIT26,\n\tBIT27: BIT27,\n\tBIT28: BIT28,\n\tBIT29: BIT29,\n\tBIT30: BIT30,\n\tBIT31: BIT31,\n\tBIT32: BIT32,\n\tBITS0: BITS0,\n\tBITS1: BITS1,\n\tBITS2: BITS2,\n\tBITS3: BITS3,\n\tBITS4: BITS4,\n\tBITS5: BITS5,\n\tBITS6: BITS6,\n\tBITS7: BITS7,\n\tBITS8: BITS8,\n\tBITS9: BITS9,\n\tBITS10: BITS10,\n\tBITS11: BITS11,\n\tBITS12: BITS12,\n\tBITS13: BITS13,\n\tBITS14: BITS14,\n\tBITS15: BITS15,\n\tBITS16: BITS16,\n\tBITS17: BITS17,\n\tBITS18: BITS18,\n\tBITS19: BITS19,\n\tBITS20: BITS20,\n\tBITS21: BITS21,\n\tBITS22: BITS22,\n\tBITS23: BITS23,\n\tBITS24: BITS24,\n\tBITS25: BITS25,\n\tBITS26: BITS26,\n\tBITS27: BITS27,\n\tBITS28: BITS28,\n\tBITS29: BITS29,\n\tBITS30: BITS30,\n\tBITS31: BITS31,\n\tBITS32: BITS32\n});\n\nexports.BIT1 = BIT1;\nexports.BIT10 = BIT10;\nexports.BIT11 = BIT11;\nexports.BIT12 = BIT12;\nexports.BIT13 = BIT13;\nexports.BIT14 = BIT14;\nexports.BIT15 = BIT15;\nexports.BIT16 = BIT16;\nexports.BIT17 = BIT17;\nexports.BIT18 = BIT18;\nexports.BIT19 = BIT19;\nexports.BIT2 = BIT2;\nexports.BIT20 = BIT20;\nexports.BIT21 = BIT21;\nexports.BIT22 = BIT22;\nexports.BIT23 = BIT23;\nexports.BIT24 = BIT24;\nexports.BIT25 = BIT25;\nexports.BIT26 = BIT26;\nexports.BIT27 = BIT27;\nexports.BIT28 = BIT28;\nexports.BIT29 = BIT29;\nexports.BIT3 = BIT3;\nexports.BIT30 = BIT30;\nexports.BIT31 = BIT31;\nexports.BIT32 = BIT32;\nexports.BIT4 = BIT4;\nexports.BIT5 = BIT5;\nexports.BIT6 = BIT6;\nexports.BIT7 = BIT7;\nexports.BIT8 = BIT8;\nexports.BIT9 = BIT9;\nexports.BITS0 = BITS0;\nexports.BITS1 = BITS1;\nexports.BITS10 = BITS10;\nexports.BITS11 = BITS11;\nexports.BITS12 = BITS12;\nexports.BITS13 = BITS13;\nexports.BITS14 = BITS14;\nexports.BITS15 = BITS15;\nexports.BITS16 = BITS16;\nexports.BITS17 = BITS17;\nexports.BITS18 = BITS18;\nexports.BITS19 = BITS19;\nexports.BITS2 = BITS2;\nexports.BITS20 = BITS20;\nexports.BITS21 = BITS21;\nexports.BITS22 = BITS22;\nexports.BITS23 = BITS23;\nexports.BITS24 = BITS24;\nexports.BITS25 = BITS25;\nexports.BITS26 = BITS26;\nexports.BITS27 = BITS27;\nexports.BITS28 = BITS28;\nexports.BITS29 = BITS29;\nexports.BITS3 = BITS3;\nexports.BITS30 = BITS30;\nexports.BITS31 = BITS31;\nexports.BITS32 = BITS32;\nexports.BITS4 = BITS4;\nexports.BITS5 = BITS5;\nexports.BITS6 = BITS6;\nexports.BITS7 = BITS7;\nexports.BITS8 = BITS8;\nexports.BITS9 = BITS9;\nexports.binary = binary;\n//# sourceMappingURL=binary-ac8e39e2.cjs.map\n","'use strict';\n\nvar math = require('./math-08e068f9.cjs');\nvar binary = require('./binary-ac8e39e2.cjs');\n\n/**\n * Utility helpers for working with numbers.\n *\n * @module number\n */\n\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;\nconst MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;\n\nconst LOWEST_INT32 = 1 << 31;\n/**\n * @type {number}\n */\nconst HIGHEST_INT32 = binary.BITS31;\n\n/**\n * @module number\n */\n\n/* istanbul ignore next */\nconst isInteger = Number.isInteger || (num => typeof num === 'number' && isFinite(num) && math.floor(num) === num);\nconst isNaN = Number.isNaN;\n\nvar number = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tMAX_SAFE_INTEGER: MAX_SAFE_INTEGER,\n\tMIN_SAFE_INTEGER: MIN_SAFE_INTEGER,\n\tLOWEST_INT32: LOWEST_INT32,\n\tHIGHEST_INT32: HIGHEST_INT32,\n\tisInteger: isInteger,\n\tisNaN: isNaN\n});\n\nexports.HIGHEST_INT32 = HIGHEST_INT32;\nexports.LOWEST_INT32 = LOWEST_INT32;\nexports.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;\nexports.MIN_SAFE_INTEGER = MIN_SAFE_INTEGER;\nexports.isInteger = isInteger;\nexports.isNaN = isNaN;\nexports.number = number;\n//# sourceMappingURL=number-24f1eabe.cjs.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar encoding = require('./buffer-ac2cdedf.cjs');\nrequire('./binary-ac8e39e2.cjs');\nrequire('./math-08e068f9.cjs');\nrequire('./string-f3c3d805.cjs');\nrequire('./environment-7e2ffaea.cjs');\nrequire('./map-28a001c9.cjs');\nrequire('./conditions-fb475c70.cjs');\nrequire('./storage.cjs');\nrequire('./number-24f1eabe.cjs');\n\n\n\nexports.Decoder = encoding.Decoder;\nexports.IncUintOptRleDecoder = encoding.IncUintOptRleDecoder;\nexports.IntDiffDecoder = encoding.IntDiffDecoder;\nexports.IntDiffOptRleDecoder = encoding.IntDiffOptRleDecoder;\nexports.RleDecoder = encoding.RleDecoder;\nexports.RleIntDiffDecoder = encoding.RleIntDiffDecoder;\nexports.StringDecoder = encoding.StringDecoder;\nexports.UintOptRleDecoder = encoding.UintOptRleDecoder;\nexports.clone = encoding.clone;\nexports.createDecoder = encoding.createDecoder;\nexports.hasContent = encoding.hasContent;\nexports.peekUint16 = encoding.peekUint16;\nexports.peekUint32 = encoding.peekUint32;\nexports.peekUint8 = encoding.peekUint8;\nexports.peekVarInt = encoding.peekVarInt;\nexports.peekVarString = encoding.peekVarString;\nexports.peekVarUint = encoding.peekVarUint;\nexports.readAny = encoding.readAny;\nexports.readBigInt64 = encoding.readBigInt64;\nexports.readBigUint64 = encoding.readBigUint64;\nexports.readFloat32 = encoding.readFloat32;\nexports.readFloat64 = encoding.readFloat64;\nexports.readFromDataView = encoding.readFromDataView;\nexports.readTailAsUint8Array = encoding.readTailAsUint8Array;\nexports.readUint16 = encoding.readUint16;\nexports.readUint32 = encoding.readUint32;\nexports.readUint32BigEndian = encoding.readUint32BigEndian;\nexports.readUint8 = encoding.readUint8;\nexports.readUint8Array = encoding.readUint8Array;\nexports.readVarInt = encoding.readVarInt;\nexports.readVarString = encoding.readVarString;\nexports.readVarUint = encoding.readVarUint;\nexports.readVarUint8Array = encoding.readVarUint8Array;\nexports.skip8 = encoding.skip8;\n//# sourceMappingURL=decoding.cjs.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar math = require('./math-08e068f9.cjs');\nvar isomorphic_js = require('isomorphic.js');\n\nconst rand = Math.random;\n\n/* istanbul ignore next */\nconst uint32 = () => new Uint32Array(isomorphic_js.cryptoRandomBuffer(4))[0];\n\n/**\n * @template T\n * @param {Array<T>} arr\n * @return {T}\n */\nconst oneOf = arr => arr[math.floor(rand() * arr.length)];\n\n// @ts-ignore\nconst uuidv4Template = [1e7] + -1e3 + -4e3 + -8e3 + -1e11;\nconst uuidv4 = () => uuidv4Template.replace(/[018]/g, /** @param {number} c */ c =>\n  (c ^ uint32() & 15 >> c / 4).toString(16)\n);\n\nexports.oneOf = oneOf;\nexports.rand = rand;\nexports.uint32 = uint32;\nexports.uuidv4 = uuidv4;\n//# sourceMappingURL=random.cjs.map\n","/* eslint-env browser */\nexport const performance = typeof window === 'undefined' ? null : (typeof window.performance !== 'undefined' && window.performance) || null\n\nconst isoCrypto = typeof crypto === 'undefined' ? null : crypto\n\n/**\n * @type {function(number):ArrayBuffer}\n */\nexport const cryptoRandomBuffer = isoCrypto !== null\n  ? len => {\n    // browser\n    const buf = new ArrayBuffer(len)\n    const arr = new Uint8Array(buf)\n    isoCrypto.getRandomValues(arr)\n    return buf\n  }\n  : len => {\n    // polyfill\n    const buf = new ArrayBuffer(len)\n    const arr = new Uint8Array(buf)\n    for (let i = 0; i < len; i++) {\n      arr[i] = Math.ceil((Math.random() * 0xFFFFFFFF) >>> 0)\n    }\n    return buf\n  }\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nrequire('./string-f3c3d805.cjs');\nrequire('./environment-7e2ffaea.cjs');\nvar encoding = require('./buffer-ac2cdedf.cjs');\nrequire('./map-28a001c9.cjs');\nrequire('./conditions-fb475c70.cjs');\nrequire('./storage.cjs');\nrequire('./binary-ac8e39e2.cjs');\nrequire('./math-08e068f9.cjs');\nrequire('./number-24f1eabe.cjs');\n\n\n\nexports.copyUint8Array = encoding.copyUint8Array;\nexports.createUint8ArrayFromArrayBuffer = encoding.createUint8ArrayFromArrayBuffer;\nexports.createUint8ArrayFromLen = encoding.createUint8ArrayFromLen;\nexports.createUint8ArrayViewFromArrayBuffer = encoding.createUint8ArrayViewFromArrayBuffer;\nexports.decodeAny = encoding.decodeAny;\nexports.encodeAny = encoding.encodeAny;\nexports.fromBase64 = encoding.fromBase64;\nexports.toBase64 = encoding.toBase64;\n//# sourceMappingURL=buffer.cjs.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar error = require('./error-55a9a8c8.cjs');\n\n\n\nexports.create = error.create;\nexports.methodUnimplemented = error.methodUnimplemented;\nexports.unexpectedCase = error.unexpectedCase;\n//# sourceMappingURL=error.cjs.map\n","'use strict';\n\n/**\n * Error helpers.\n *\n * @module error\n */\n\n/**\n * @param {string} s\n * @return {Error}\n */\n/* istanbul ignore next */\nconst create = s => new Error(s);\n\n/**\n * @throws {Error}\n * @return {never}\n */\n/* istanbul ignore next */\nconst methodUnimplemented = () => {\n  throw create('Method unimplemented')\n};\n\n/**\n * @throws {Error}\n * @return {never}\n */\n/* istanbul ignore next */\nconst unexpectedCase = () => {\n  throw create('Unexpected case')\n};\n\nvar error = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  create: create,\n  methodUnimplemented: methodUnimplemented,\n  unexpectedCase: unexpectedCase\n});\n\nexports.create = create;\nexports.error = error;\nexports.methodUnimplemented = methodUnimplemented;\nexports.unexpectedCase = unexpectedCase;\n//# sourceMappingURL=error-55a9a8c8.cjs.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar binary = require('./binary-ac8e39e2.cjs');\n\n\n\nexports.BIT1 = binary.BIT1;\nexports.BIT10 = binary.BIT10;\nexports.BIT11 = binary.BIT11;\nexports.BIT12 = binary.BIT12;\nexports.BIT13 = binary.BIT13;\nexports.BIT14 = binary.BIT14;\nexports.BIT15 = binary.BIT15;\nexports.BIT16 = binary.BIT16;\nexports.BIT17 = binary.BIT17;\nexports.BIT18 = binary.BIT18;\nexports.BIT19 = binary.BIT19;\nexports.BIT2 = binary.BIT2;\nexports.BIT20 = binary.BIT20;\nexports.BIT21 = binary.BIT21;\nexports.BIT22 = binary.BIT22;\nexports.BIT23 = binary.BIT23;\nexports.BIT24 = binary.BIT24;\nexports.BIT25 = binary.BIT25;\nexports.BIT26 = binary.BIT26;\nexports.BIT27 = binary.BIT27;\nexports.BIT28 = binary.BIT28;\nexports.BIT29 = binary.BIT29;\nexports.BIT3 = binary.BIT3;\nexports.BIT30 = binary.BIT30;\nexports.BIT31 = binary.BIT31;\nexports.BIT32 = binary.BIT32;\nexports.BIT4 = binary.BIT4;\nexports.BIT5 = binary.BIT5;\nexports.BIT6 = binary.BIT6;\nexports.BIT7 = binary.BIT7;\nexports.BIT8 = binary.BIT8;\nexports.BIT9 = binary.BIT9;\nexports.BITS0 = binary.BITS0;\nexports.BITS1 = binary.BITS1;\nexports.BITS10 = binary.BITS10;\nexports.BITS11 = binary.BITS11;\nexports.BITS12 = binary.BITS12;\nexports.BITS13 = binary.BITS13;\nexports.BITS14 = binary.BITS14;\nexports.BITS15 = binary.BITS15;\nexports.BITS16 = binary.BITS16;\nexports.BITS17 = binary.BITS17;\nexports.BITS18 = binary.BITS18;\nexports.BITS19 = binary.BITS19;\nexports.BITS2 = binary.BITS2;\nexports.BITS20 = binary.BITS20;\nexports.BITS21 = binary.BITS21;\nexports.BITS22 = binary.BITS22;\nexports.BITS23 = binary.BITS23;\nexports.BITS24 = binary.BITS24;\nexports.BITS25 = binary.BITS25;\nexports.BITS26 = binary.BITS26;\nexports.BITS27 = binary.BITS27;\nexports.BITS28 = binary.BITS28;\nexports.BITS29 = binary.BITS29;\nexports.BITS3 = binary.BITS3;\nexports.BITS30 = binary.BITS30;\nexports.BITS31 = binary.BITS31;\nexports.BITS32 = binary.BITS32;\nexports.BITS4 = binary.BITS4;\nexports.BITS5 = binary.BITS5;\nexports.BITS6 = binary.BITS6;\nexports.BITS7 = binary.BITS7;\nexports.BITS8 = binary.BITS8;\nexports.BITS9 = binary.BITS9;\n//# sourceMappingURL=binary.cjs.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nrequire('./array-b2d24238.cjs');\nrequire('./object-dcdd6eed.cjs');\nvar _function = require('./function-f8acb5f5.cjs');\n\n\n\nexports.apply = _function.apply;\nexports.callAll = _function.callAll;\nexports.equalityDeep = _function.equalityDeep;\nexports.equalityFlat = _function.equalityFlat;\nexports.equalityStrict = _function.equalityStrict;\nexports.id = _function.id;\nexports.nop = _function.nop;\n//# sourceMappingURL=function.cjs.map\n","'use strict';\n\n/**\n * Utility functions for working with EcmaScript objects.\n *\n * @module object\n */\n\n/**\n * @return {Object<string,any>} obj\n */\nconst create = () => Object.create(null);\n\n/**\n * Object.assign\n */\nconst assign = Object.assign;\n\n/**\n * @param {Object<string,any>} obj\n */\nconst keys = Object.keys;\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):any} f\n */\nconst forEach = (obj, f) => {\n  for (const key in obj) {\n    f(obj[key], key);\n  }\n};\n\n/**\n * @template R\n * @param {Object<string,any>} obj\n * @param {function(any,string):R} f\n * @return {Array<R>}\n */\nconst map = (obj, f) => {\n  const results = [];\n  for (const key in obj) {\n    results.push(f(obj[key], key));\n  }\n  return results\n};\n\n/**\n * @param {Object<string,any>} obj\n * @return {number}\n */\nconst length = obj => keys(obj).length;\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):boolean} f\n * @return {boolean}\n */\nconst some = (obj, f) => {\n  for (const key in obj) {\n    if (f(obj[key], key)) {\n      return true\n    }\n  }\n  return false\n};\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):boolean} f\n * @return {boolean}\n */\nconst every = (obj, f) => {\n  for (const key in obj) {\n    if (!f(obj[key], key)) {\n      return false\n    }\n  }\n  return true\n};\n\n/**\n * Calls `Object.prototype.hasOwnProperty`.\n *\n * @param {any} obj\n * @param {string|symbol} key\n * @return {boolean}\n */\nconst hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);\n\n/**\n * @param {Object<string,any>} a\n * @param {Object<string,any>} b\n * @return {boolean}\n */\nconst equalFlat = (a, b) => a === b || (length(a) === length(b) && every(a, (val, key) => (val !== undefined || hasProperty(b, key)) && b[key] === val));\n\nvar object = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  create: create,\n  assign: assign,\n  keys: keys,\n  forEach: forEach,\n  map: map,\n  length: length,\n  some: some,\n  every: every,\n  hasProperty: hasProperty,\n  equalFlat: equalFlat\n});\n\nexports.assign = assign;\nexports.create = create;\nexports.equalFlat = equalFlat;\nexports.every = every;\nexports.forEach = forEach;\nexports.hasProperty = hasProperty;\nexports.keys = keys;\nexports.length = length;\nexports.map = map;\nexports.object = object;\nexports.some = some;\n//# sourceMappingURL=object-dcdd6eed.cjs.map\n","'use strict';\n\nvar array = require('./array-b2d24238.cjs');\nvar object = require('./object-dcdd6eed.cjs');\n\n/**\n * Common functions and function call helpers.\n *\n * @module function\n */\n\n/**\n * Calls all functions in `fs` with args. Only throws after all functions were called.\n *\n * @param {Array<function>} fs\n * @param {Array<any>} args\n */\nconst callAll = (fs, args, i = 0) => {\n  try {\n    for (; i < fs.length; i++) {\n      fs[i](...args);\n    }\n  } finally {\n    if (i < fs.length) {\n      callAll(fs, args, i + 1);\n    }\n  }\n};\n\nconst nop = () => {};\n\n/**\n * @template T\n * @param {function():T} f\n * @return {T}\n */\nconst apply = f => f();\n\n/**\n * @template A\n *\n * @param {A} a\n * @return {A}\n */\nconst id = a => a;\n\n/**\n * @template T\n *\n * @param {T} a\n * @param {T} b\n * @return {boolean}\n */\nconst equalityStrict = (a, b) => a === b;\n\n/**\n * @template T\n *\n * @param {Array<T>|object} a\n * @param {Array<T>|object} b\n * @return {boolean}\n */\nconst equalityFlat = (a, b) => a === b || (a != null && b != null && a.constructor === b.constructor && ((a instanceof Array && array.equalFlat(a, /** @type {Array<T>} */ (b))) || (typeof a === 'object' && object.equalFlat(a, b))));\n\n/**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */\nconst equalityDeep = (a, b) => {\n  if (a == null || b == null) {\n    return equalityStrict(a, b)\n  }\n  if (a.constructor !== b.constructor) {\n    return false\n  }\n  if (a === b) {\n    return true\n  }\n  switch (a.constructor) {\n    case ArrayBuffer:\n      a = new Uint8Array(a);\n      b = new Uint8Array(b);\n    // eslint-disable-next-line no-fallthrough\n    case Uint8Array: {\n      if (a.byteLength !== b.byteLength) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n          return false\n        }\n      }\n      break\n    }\n    case Set: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const value of a) {\n        if (!b.has(value)) {\n          return false\n        }\n      }\n      break\n    }\n    case Map: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const key of a.keys()) {\n        if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) {\n          return false\n        }\n      }\n      break\n    }\n    case Object:\n      if (object.length(a) !== object.length(b)) {\n        return false\n      }\n      for (const key in a) {\n        if (!object.hasProperty(a, key) || !equalityDeep(a[key], b[key])) {\n          return false\n        }\n      }\n      break\n    case Array:\n      if (a.length !== b.length) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (!equalityDeep(a[i], b[i])) {\n          return false\n        }\n      }\n      break\n    default:\n      return false\n  }\n  return true\n};\n\nvar _function = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  callAll: callAll,\n  nop: nop,\n  apply: apply,\n  id: id,\n  equalityStrict: equalityStrict,\n  equalityFlat: equalityFlat,\n  equalityDeep: equalityDeep\n});\n\nexports._function = _function;\nexports.apply = apply;\nexports.callAll = callAll;\nexports.equalityDeep = equalityDeep;\nexports.equalityFlat = equalityFlat;\nexports.equalityStrict = equalityStrict;\nexports.id = id;\nexports.nop = nop;\n//# sourceMappingURL=function-f8acb5f5.cjs.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar set = require('./set-7ae96d21.cjs');\n\n\n\nexports.create = set.create;\nexports.toArray = set.toArray;\n//# sourceMappingURL=set.cjs.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nrequire('./environment-7e2ffaea.cjs');\nrequire('./symbol-c5caa724.cjs');\nrequire('./pair-ab022bc3.cjs');\nrequire('./dom-58958c04.cjs');\nrequire('./json-092190a1.cjs');\nrequire('./map-28a001c9.cjs');\nrequire('./eventloop-c60b5658.cjs');\nrequire('./math-08e068f9.cjs');\nrequire('./time-e00067da.cjs');\nrequire('./function-f8acb5f5.cjs');\nvar logging = require('./logging-7cc36806.cjs');\nrequire('./string-f3c3d805.cjs');\nrequire('./conditions-fb475c70.cjs');\nrequire('./storage.cjs');\nrequire('./metric.cjs');\nrequire('./array-b2d24238.cjs');\nrequire('./object-dcdd6eed.cjs');\n\n\n\nexports.BLUE = logging.BLUE;\nexports.BOLD = logging.BOLD;\nexports.GREEN = logging.GREEN;\nexports.GREY = logging.GREY;\nexports.ORANGE = logging.ORANGE;\nexports.PURPLE = logging.PURPLE;\nexports.RED = logging.RED;\nexports.UNBOLD = logging.UNBOLD;\nexports.UNCOLOR = logging.UNCOLOR;\nexports.VConsole = logging.VConsole;\nexports.createModuleLogger = logging.createModuleLogger;\nexports.createVConsole = logging.createVConsole;\nexports.group = logging.group;\nexports.groupCollapsed = logging.groupCollapsed;\nexports.groupEnd = logging.groupEnd;\nexports.print = logging.print;\nexports.printCanvas = logging.printCanvas;\nexports.printDom = logging.printDom;\nexports.printError = logging.printError;\nexports.printImg = logging.printImg;\nexports.printImgBase64 = logging.printImgBase64;\nexports.vconsoles = logging.vconsoles;\nexports.warn = logging.warn;\n//# sourceMappingURL=logging.cjs.map\n","'use strict';\n\n/**\n * Utility module to work with EcmaScript Symbols.\n *\n * @module symbol\n */\n\n/**\n * Return fresh symbol.\n *\n * @return {Symbol}\n */\nconst create = Symbol;\n\n/**\n * @param {any} s\n * @return {boolean}\n */\nconst isSymbol = s => typeof s === 'symbol';\n\nvar symbol = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tcreate: create,\n\tisSymbol: isSymbol\n});\n\nexports.create = create;\nexports.isSymbol = isSymbol;\nexports.symbol = symbol;\n//# sourceMappingURL=symbol-c5caa724.cjs.map\n","'use strict';\n\n/**\n * Working with value pairs.\n *\n * @module pair\n */\n\n/**\n * @template L,R\n */\nclass Pair {\n  /**\n   * @param {L} left\n   * @param {R} right\n   */\n  constructor (left, right) {\n    this.left = left;\n    this.right = right;\n  }\n}\n\n/**\n * @template L,R\n * @param {L} left\n * @param {R} right\n * @return {Pair<L,R>}\n */\nconst create = (left, right) => new Pair(left, right);\n\n/**\n * @template L,R\n * @param {R} right\n * @param {L} left\n * @return {Pair<L,R>}\n */\nconst createReversed = (right, left) => new Pair(left, right);\n\n/**\n * @template L,R\n * @param {Array<Pair<L,R>>} arr\n * @param {function(L, R):any} f\n */\nconst forEach = (arr, f) => arr.forEach(p => f(p.left, p.right));\n\n/**\n * @template L,R,X\n * @param {Array<Pair<L,R>>} arr\n * @param {function(L, R):X} f\n * @return {Array<X>}\n */\nconst map = (arr, f) => arr.map(p => f(p.left, p.right));\n\nvar pair = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  Pair: Pair,\n  create: create,\n  createReversed: createReversed,\n  forEach: forEach,\n  map: map\n});\n\nexports.Pair = Pair;\nexports.create = create;\nexports.createReversed = createReversed;\nexports.forEach = forEach;\nexports.map = map;\nexports.pair = pair;\n//# sourceMappingURL=pair-ab022bc3.cjs.map\n","'use strict';\n\nvar pair = require('./pair-ab022bc3.cjs');\nvar map = require('./map-28a001c9.cjs');\n\n/* eslint-env browser */\n\n/* istanbul ignore next */\n/**\n * @type {Document}\n */\nconst doc = /** @type {Document} */ (typeof document !== 'undefined' ? document : {});\n\n/**\n * @param {string} name\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nconst createElement = name => doc.createElement(name);\n\n/**\n * @return {DocumentFragment}\n */\n/* istanbul ignore next */\nconst createDocumentFragment = () => doc.createDocumentFragment();\n\n/**\n * @param {string} text\n * @return {Text}\n */\n/* istanbul ignore next */\nconst createTextNode = text => doc.createTextNode(text);\n\n/* istanbul ignore next */\nconst domParser = /** @type {DOMParser} */ (typeof DOMParser !== 'undefined' ? new DOMParser() : null);\n\n/**\n * @param {HTMLElement} el\n * @param {string} name\n * @param {Object} opts\n */\n/* istanbul ignore next */\nconst emitCustomEvent = (el, name, opts) => el.dispatchEvent(new CustomEvent(name, opts));\n\n/**\n * @param {Element} el\n * @param {Array<pair.Pair<string,string|boolean>>} attrs Array of key-value pairs\n * @return {Element}\n */\n/* istanbul ignore next */\nconst setAttributes = (el, attrs) => {\n  pair.forEach(attrs, (key, value) => {\n    if (value === false) {\n      el.removeAttribute(key);\n    } else if (value === true) {\n      el.setAttribute(key, '');\n    } else {\n      // @ts-ignore\n      el.setAttribute(key, value);\n    }\n  });\n  return el\n};\n\n/**\n * @param {Element} el\n * @param {Map<string, string>} attrs Array of key-value pairs\n * @return {Element}\n */\n/* istanbul ignore next */\nconst setAttributesMap = (el, attrs) => {\n  attrs.forEach((value, key) => { el.setAttribute(key, value); });\n  return el\n};\n\n/**\n * @param {Array<Node>|HTMLCollection} children\n * @return {DocumentFragment}\n */\n/* istanbul ignore next */\nconst fragment = children => {\n  const fragment = createDocumentFragment();\n  for (let i = 0; i < children.length; i++) {\n    appendChild(fragment, children[i]);\n  }\n  return fragment\n};\n\n/**\n * @param {Element} parent\n * @param {Array<Node>} nodes\n * @return {Element}\n */\n/* istanbul ignore next */\nconst append = (parent, nodes) => {\n  appendChild(parent, fragment(nodes));\n  return parent\n};\n\n/**\n * @param {HTMLElement} el\n */\n/* istanbul ignore next */\nconst remove = el => el.remove();\n\n/**\n * @param {EventTarget} el\n * @param {string} name\n * @param {EventListener} f\n */\n/* istanbul ignore next */\nconst addEventListener = (el, name, f) => el.addEventListener(name, f);\n\n/**\n * @param {EventTarget} el\n * @param {string} name\n * @param {EventListener} f\n */\n/* istanbul ignore next */\nconst removeEventListener = (el, name, f) => el.removeEventListener(name, f);\n\n/**\n * @param {Node} node\n * @param {Array<pair.Pair<string,EventListener>>} listeners\n * @return {Node}\n */\n/* istanbul ignore next */\nconst addEventListeners = (node, listeners) => {\n  pair.forEach(listeners, (name, f) => addEventListener(node, name, f));\n  return node\n};\n\n/**\n * @param {Node} node\n * @param {Array<pair.Pair<string,EventListener>>} listeners\n * @return {Node}\n */\n/* istanbul ignore next */\nconst removeEventListeners = (node, listeners) => {\n  pair.forEach(listeners, (name, f) => removeEventListener(node, name, f));\n  return node\n};\n\n/**\n * @param {string} name\n * @param {Array<pair.Pair<string,string>|pair.Pair<string,boolean>>} attrs Array of key-value pairs\n * @param {Array<Node>} children\n * @return {Element}\n */\n/* istanbul ignore next */\nconst element = (name, attrs = [], children = []) =>\n  append(setAttributes(createElement(name), attrs), children);\n\n/**\n * @param {number} width\n * @param {number} height\n */\n/* istanbul ignore next */\nconst canvas = (width, height) => {\n  const c = /** @type {HTMLCanvasElement} */ (createElement('canvas'));\n  c.height = height;\n  c.width = width;\n  return c\n};\n\n/**\n * @param {string} t\n * @return {Text}\n */\n/* istanbul ignore next */\nconst text = createTextNode;\n\n/**\n * @param {pair.Pair<string,string>} pair\n */\n/* istanbul ignore next */\nconst pairToStyleString = pair => `${pair.left}:${pair.right};`;\n\n/**\n * @param {Array<pair.Pair<string,string>>} pairs\n * @return {string}\n */\n/* istanbul ignore next */\nconst pairsToStyleString = pairs => pairs.map(pairToStyleString).join('');\n\n/**\n * @param {Map<string,string>} m\n * @return {string}\n */\n/* istanbul ignore next */\nconst mapToStyleString = m => map.map(m, (value, key) => `${key}:${value};`).join('');\n\n/**\n * @todo should always query on a dom element\n *\n * @param {HTMLElement|ShadowRoot} el\n * @param {string} query\n * @return {HTMLElement | null}\n */\n/* istanbul ignore next */\nconst querySelector = (el, query) => el.querySelector(query);\n\n/**\n * @param {HTMLElement|ShadowRoot} el\n * @param {string} query\n * @return {NodeListOf<HTMLElement>}\n */\n/* istanbul ignore next */\nconst querySelectorAll = (el, query) => el.querySelectorAll(query);\n\n/**\n * @param {string} id\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nconst getElementById = id => /** @type {HTMLElement} */ (doc.getElementById(id));\n\n/**\n * @param {string} html\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nconst _parse = html => domParser.parseFromString(`<html><body>${html}</body></html>`, 'text/html').body;\n\n/**\n * @param {string} html\n * @return {DocumentFragment}\n */\n/* istanbul ignore next */\nconst parseFragment = html => fragment(/** @type {any} */ (_parse(html).childNodes));\n\n/**\n * @param {string} html\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nconst parseElement = html => /** @type HTMLElement */ (_parse(html).firstElementChild);\n\n/**\n * @param {HTMLElement} oldEl\n * @param {HTMLElement|DocumentFragment} newEl\n */\n/* istanbul ignore next */\nconst replaceWith = (oldEl, newEl) => oldEl.replaceWith(newEl);\n\n/**\n * @param {HTMLElement} parent\n * @param {HTMLElement} el\n * @param {Node|null} ref\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nconst insertBefore = (parent, el, ref) => parent.insertBefore(el, ref);\n\n/**\n * @param {Node} parent\n * @param {Node} child\n * @return {Node}\n */\n/* istanbul ignore next */\nconst appendChild = (parent, child) => parent.appendChild(child);\n\nconst ELEMENT_NODE = doc.ELEMENT_NODE;\nconst TEXT_NODE = doc.TEXT_NODE;\nconst CDATA_SECTION_NODE = doc.CDATA_SECTION_NODE;\nconst COMMENT_NODE = doc.COMMENT_NODE;\nconst DOCUMENT_NODE = doc.DOCUMENT_NODE;\nconst DOCUMENT_TYPE_NODE = doc.DOCUMENT_TYPE_NODE;\nconst DOCUMENT_FRAGMENT_NODE = doc.DOCUMENT_FRAGMENT_NODE;\n\n/**\n * @param {any} node\n * @param {number} type\n */\nconst checkNodeType = (node, type) => node.nodeType === type;\n\n/**\n * @param {Node} parent\n * @param {HTMLElement} child\n */\nconst isParentOf = (parent, child) => {\n  let p = child.parentNode;\n  while (p && p !== parent) {\n    p = p.parentNode;\n  }\n  return p === parent\n};\n\nvar dom = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  doc: doc,\n  createElement: createElement,\n  createDocumentFragment: createDocumentFragment,\n  createTextNode: createTextNode,\n  domParser: domParser,\n  emitCustomEvent: emitCustomEvent,\n  setAttributes: setAttributes,\n  setAttributesMap: setAttributesMap,\n  fragment: fragment,\n  append: append,\n  remove: remove,\n  addEventListener: addEventListener,\n  removeEventListener: removeEventListener,\n  addEventListeners: addEventListeners,\n  removeEventListeners: removeEventListeners,\n  element: element,\n  canvas: canvas,\n  text: text,\n  pairToStyleString: pairToStyleString,\n  pairsToStyleString: pairsToStyleString,\n  mapToStyleString: mapToStyleString,\n  querySelector: querySelector,\n  querySelectorAll: querySelectorAll,\n  getElementById: getElementById,\n  parseFragment: parseFragment,\n  parseElement: parseElement,\n  replaceWith: replaceWith,\n  insertBefore: insertBefore,\n  appendChild: appendChild,\n  ELEMENT_NODE: ELEMENT_NODE,\n  TEXT_NODE: TEXT_NODE,\n  CDATA_SECTION_NODE: CDATA_SECTION_NODE,\n  COMMENT_NODE: COMMENT_NODE,\n  DOCUMENT_NODE: DOCUMENT_NODE,\n  DOCUMENT_TYPE_NODE: DOCUMENT_TYPE_NODE,\n  DOCUMENT_FRAGMENT_NODE: DOCUMENT_FRAGMENT_NODE,\n  checkNodeType: checkNodeType,\n  isParentOf: isParentOf\n});\n\nexports.CDATA_SECTION_NODE = CDATA_SECTION_NODE;\nexports.COMMENT_NODE = COMMENT_NODE;\nexports.DOCUMENT_FRAGMENT_NODE = DOCUMENT_FRAGMENT_NODE;\nexports.DOCUMENT_NODE = DOCUMENT_NODE;\nexports.DOCUMENT_TYPE_NODE = DOCUMENT_TYPE_NODE;\nexports.ELEMENT_NODE = ELEMENT_NODE;\nexports.TEXT_NODE = TEXT_NODE;\nexports.addEventListener = addEventListener;\nexports.addEventListeners = addEventListeners;\nexports.append = append;\nexports.appendChild = appendChild;\nexports.canvas = canvas;\nexports.checkNodeType = checkNodeType;\nexports.createDocumentFragment = createDocumentFragment;\nexports.createElement = createElement;\nexports.createTextNode = createTextNode;\nexports.doc = doc;\nexports.dom = dom;\nexports.domParser = domParser;\nexports.element = element;\nexports.emitCustomEvent = emitCustomEvent;\nexports.fragment = fragment;\nexports.getElementById = getElementById;\nexports.insertBefore = insertBefore;\nexports.isParentOf = isParentOf;\nexports.mapToStyleString = mapToStyleString;\nexports.pairToStyleString = pairToStyleString;\nexports.pairsToStyleString = pairsToStyleString;\nexports.parseElement = parseElement;\nexports.parseFragment = parseFragment;\nexports.querySelector = querySelector;\nexports.querySelectorAll = querySelectorAll;\nexports.remove = remove;\nexports.removeEventListener = removeEventListener;\nexports.removeEventListeners = removeEventListeners;\nexports.replaceWith = replaceWith;\nexports.setAttributes = setAttributes;\nexports.setAttributesMap = setAttributesMap;\nexports.text = text;\n//# sourceMappingURL=dom-58958c04.cjs.map\n","'use strict';\n\n/**\n * JSON utility functions.\n *\n * @module json\n */\n\n/**\n * Transform JavaScript object to JSON.\n *\n * @param {any} object\n * @return {string}\n */\nconst stringify = JSON.stringify;\n\n/**\n * Parse JSON object.\n *\n * @param {string} json\n * @return {any}\n */\nconst parse = JSON.parse;\n\nvar json = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tstringify: stringify,\n\tparse: parse\n});\n\nexports.json = json;\nexports.parse = parse;\nexports.stringify = stringify;\n//# sourceMappingURL=json-092190a1.cjs.map\n","'use strict';\n\n/* global requestIdleCallback, requestAnimationFrame, cancelIdleCallback, cancelAnimationFrame */\n\n/**\n * Utility module to work with EcmaScript's event loop.\n *\n * @module eventloop\n */\n\n/**\n * @type {Array<function>}\n */\nlet queue = [];\n\nconst _runQueue = () => {\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]();\n  }\n  queue = [];\n};\n\n/**\n * @param {function():void} f\n */\nconst enqueue = f => {\n  queue.push(f);\n  if (queue.length === 1) {\n    setTimeout(_runQueue, 0);\n  }\n};\n\n/**\n * @typedef {Object} TimeoutObject\n * @property {function} TimeoutObject.destroy\n */\n\n/**\n * @param {function(number):void} clearFunction\n */\nconst createTimeoutClass = clearFunction => class TT {\n  /**\n   * @param {number} timeoutId\n   */\n  constructor (timeoutId) {\n    this._ = timeoutId;\n  }\n\n  destroy () {\n    clearFunction(this._);\n  }\n};\n\nconst Timeout = createTimeoutClass(clearTimeout);\n\n/**\n * @param {number} timeout\n * @param {function} callback\n * @return {TimeoutObject}\n */\nconst timeout = (timeout, callback) => new Timeout(setTimeout(callback, timeout));\n\nconst Interval = createTimeoutClass(clearInterval);\n\n/**\n * @param {number} timeout\n * @param {function} callback\n * @return {TimeoutObject}\n */\nconst interval = (timeout, callback) => new Interval(setInterval(callback, timeout));\n\n/* istanbul ignore next */\nconst Animation = createTimeoutClass(arg => typeof requestAnimationFrame !== 'undefined' && cancelAnimationFrame(arg));\n\n/* istanbul ignore next */\n/**\n * @param {function(number):void} cb\n * @return {TimeoutObject}\n */\nconst animationFrame = cb => typeof requestAnimationFrame === 'undefined' ? timeout(0, cb) : new Animation(requestAnimationFrame(cb));\n\n/* istanbul ignore next */\n// @ts-ignore\nconst Idle = createTimeoutClass(arg => typeof cancelIdleCallback !== 'undefined' && cancelIdleCallback(arg));\n\n/* istanbul ignore next */\n/**\n * Note: this is experimental and is probably only useful in browsers.\n *\n * @param {function} cb\n * @return {TimeoutObject}\n */\n// @ts-ignore\nconst idleCallback = cb => typeof requestIdleCallback !== 'undefined' ? new Idle(requestIdleCallback(cb)) : timeout(1000, cb);\n\n/**\n * @param {number} timeout Timeout of the debounce action\n * @return {function(function():void):void}\n */\nconst createDebouncer = timeout => {\n  let timer = -1;\n  return f => {\n    clearTimeout(timer);\n    if (f) {\n      timer = /** @type {any} */ (setTimeout(f, timeout));\n    }\n  }\n};\n\nvar eventloop = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  enqueue: enqueue,\n  timeout: timeout,\n  interval: interval,\n  Animation: Animation,\n  animationFrame: animationFrame,\n  idleCallback: idleCallback,\n  createDebouncer: createDebouncer\n});\n\nexports.Animation = Animation;\nexports.animationFrame = animationFrame;\nexports.createDebouncer = createDebouncer;\nexports.enqueue = enqueue;\nexports.eventloop = eventloop;\nexports.idleCallback = idleCallback;\nexports.interval = interval;\nexports.timeout = timeout;\n//# sourceMappingURL=eventloop-c60b5658.cjs.map\n","'use strict';\n\nvar metric = require('./metric.cjs');\nvar math = require('./math-08e068f9.cjs');\n\n/**\n * Utility module to work with time.\n *\n * @module time\n */\n\n/**\n * Return current time.\n *\n * @return {Date}\n */\nconst getDate = () => new Date();\n\n/**\n * Return current unix time.\n *\n * @return {number}\n */\nconst getUnixTime = Date.now;\n\n/**\n * Transform time (in ms) to a human readable format. E.g. 1100 => 1.1s. 60s => 1min. .001 => 10s.\n *\n * @param {number} d duration in milliseconds\n * @return {string} humanized approximation of time\n */\nconst humanizeDuration = d => {\n  if (d < 60000) {\n    const p = metric.prefix(d, -1);\n    return math.round(p.n * 100) / 100 + p.prefix + 's'\n  }\n  d = math.floor(d / 1000);\n  const seconds = d % 60;\n  const minutes = math.floor(d / 60) % 60;\n  const hours = math.floor(d / 3600) % 24;\n  const days = math.floor(d / 86400);\n  if (days > 0) {\n    return days + 'd' + ((hours > 0 || minutes > 30) ? ' ' + (minutes > 30 ? hours + 1 : hours) + 'h' : '')\n  }\n  if (hours > 0) {\n    /* istanbul ignore next */\n    return hours + 'h' + ((minutes > 0 || seconds > 30) ? ' ' + (seconds > 30 ? minutes + 1 : minutes) + 'min' : '')\n  }\n  return minutes + 'min' + (seconds > 0 ? ' ' + seconds + 's' : '')\n};\n\nvar time = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  getDate: getDate,\n  getUnixTime: getUnixTime,\n  humanizeDuration: humanizeDuration\n});\n\nexports.getDate = getDate;\nexports.getUnixTime = getUnixTime;\nexports.humanizeDuration = humanizeDuration;\nexports.time = time;\n//# sourceMappingURL=time-e00067da.cjs.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar math = require('./math-08e068f9.cjs');\n\n/**\n * Utility module to convert metric values.\n *\n * @module metric\n */\n\nconst yotta = 1e24;\nconst zetta = 1e21;\nconst exa = 1e18;\nconst peta = 1e15;\nconst tera = 1e12;\nconst giga = 1e9;\nconst mega = 1e6;\nconst kilo = 1e3;\nconst hecto = 1e2;\nconst deca = 10;\nconst deci = 0.1;\nconst centi = 0.01;\nconst milli = 1e-3;\nconst micro = 1e-6;\nconst nano = 1e-9;\nconst pico = 1e-12;\nconst femto = 1e-15;\nconst atto = 1e-18;\nconst zepto = 1e-21;\nconst yocto = 1e-24;\n\nconst prefixUp = ['', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'];\nconst prefixDown = ['', 'm', '', 'n', 'p', 'f', 'a', 'z', 'y'];\n\n/**\n * Calculate the metric prefix for a number. Assumes E.g. `prefix(1000) = { n: 1, prefix: 'k' }`\n *\n * @param {number} n\n * @param {number} [baseMultiplier] Multiplier of the base (10^(3*baseMultiplier)). E.g. `convert(time, -3)` if time is already in milli seconds\n * @return {{n:number,prefix:string}}\n */\nconst prefix = (n, baseMultiplier = 0) => {\n  const nPow = n === 0 ? 0 : math.log10(n);\n  let mult = 0;\n  while (nPow < mult * 3 && baseMultiplier > -8) {\n    baseMultiplier--;\n    mult--;\n  }\n  while (nPow >= 3 + mult * 3 && baseMultiplier < 8) {\n    baseMultiplier++;\n    mult++;\n  }\n  const prefix = baseMultiplier < 0 ? prefixDown[-baseMultiplier] : prefixUp[baseMultiplier];\n  return {\n    n: math.round((mult > 0 ? n / math.exp10(mult * 3) : n * math.exp10(mult * -3)) * 1e12) / 1e12,\n    prefix\n  }\n};\n\nexports.atto = atto;\nexports.centi = centi;\nexports.deca = deca;\nexports.deci = deci;\nexports.exa = exa;\nexports.femto = femto;\nexports.giga = giga;\nexports.hecto = hecto;\nexports.kilo = kilo;\nexports.mega = mega;\nexports.micro = micro;\nexports.milli = milli;\nexports.nano = nano;\nexports.peta = peta;\nexports.pico = pico;\nexports.prefix = prefix;\nexports.tera = tera;\nexports.yocto = yocto;\nexports.yotta = yotta;\nexports.zepto = zepto;\nexports.zetta = zetta;\n//# sourceMappingURL=metric.cjs.map\n","'use strict';\n\nvar environment = require('./environment-7e2ffaea.cjs');\nvar symbol = require('./symbol-c5caa724.cjs');\nvar pair = require('./pair-ab022bc3.cjs');\nvar dom = require('./dom-58958c04.cjs');\nvar json = require('./json-092190a1.cjs');\nvar map = require('./map-28a001c9.cjs');\nvar eventloop = require('./eventloop-c60b5658.cjs');\nvar math = require('./math-08e068f9.cjs');\nvar time = require('./time-e00067da.cjs');\nvar _function = require('./function-f8acb5f5.cjs');\n\n/**\n * Isomorphic logging module with support for colors!\n *\n * @module logging\n */\n\nconst BOLD = symbol.create();\nconst UNBOLD = symbol.create();\nconst BLUE = symbol.create();\nconst GREY = symbol.create();\nconst GREEN = symbol.create();\nconst RED = symbol.create();\nconst PURPLE = symbol.create();\nconst ORANGE = symbol.create();\nconst UNCOLOR = symbol.create();\n\n/**\n * @type {Object<Symbol,pair.Pair<string,string>>}\n */\nconst _browserStyleMap = {\n  [BOLD]: pair.create('font-weight', 'bold'),\n  [UNBOLD]: pair.create('font-weight', 'normal'),\n  [BLUE]: pair.create('color', 'blue'),\n  [GREEN]: pair.create('color', 'green'),\n  [GREY]: pair.create('color', 'grey'),\n  [RED]: pair.create('color', 'red'),\n  [PURPLE]: pair.create('color', 'purple'),\n  [ORANGE]: pair.create('color', 'orange'), // not well supported in chrome when debugging node with inspector - TODO: deprecate\n  [UNCOLOR]: pair.create('color', 'black')\n};\n\nconst _nodeStyleMap = {\n  [BOLD]: '\\u001b[1m',\n  [UNBOLD]: '\\u001b[2m',\n  [BLUE]: '\\x1b[34m',\n  [GREEN]: '\\x1b[32m',\n  [GREY]: '\\u001b[37m',\n  [RED]: '\\x1b[31m',\n  [PURPLE]: '\\x1b[35m',\n  [ORANGE]: '\\x1b[38;5;208m',\n  [UNCOLOR]: '\\x1b[0m'\n};\n\n/* istanbul ignore next */\n/**\n * @param {Array<string|Symbol|Object|number>} args\n * @return {Array<string|object|number>}\n */\nconst computeBrowserLoggingArgs = args => {\n  const strBuilder = [];\n  const styles = [];\n  const currentStyle = map.create();\n  /**\n   * @type {Array<string|Object|number>}\n   */\n  let logArgs = [];\n  // try with formatting until we find something unsupported\n  let i = 0;\n\n  for (; i < args.length; i++) {\n    const arg = args[i];\n    // @ts-ignore\n    const style = _browserStyleMap[arg];\n    if (style !== undefined) {\n      currentStyle.set(style.left, style.right);\n    } else {\n      if (arg.constructor === String || arg.constructor === Number) {\n        const style = dom.mapToStyleString(currentStyle);\n        if (i > 0 || style.length > 0) {\n          strBuilder.push('%c' + arg);\n          styles.push(style);\n        } else {\n          strBuilder.push(arg);\n        }\n      } else {\n        break\n      }\n    }\n  }\n\n  if (i > 0) {\n    // create logArgs with what we have so far\n    logArgs = styles;\n    logArgs.unshift(strBuilder.join(''));\n  }\n  // append the rest\n  for (; i < args.length; i++) {\n    const arg = args[i];\n    if (!(arg instanceof Symbol)) {\n      logArgs.push(arg);\n    }\n  }\n  return logArgs\n};\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n * @return {Array<string|object|number>}\n */\nconst computeNodeLoggingArgs = args => {\n  const strBuilder = [];\n  const logArgs = [];\n\n  // try with formatting until we find something unsupported\n  let i = 0;\n\n  for (; i < args.length; i++) {\n    const arg = args[i];\n    // @ts-ignore\n    const style = _nodeStyleMap[arg];\n    if (style !== undefined) {\n      strBuilder.push(style);\n    } else {\n      if (arg.constructor === String || arg.constructor === Number) {\n        strBuilder.push(arg);\n      } else {\n        break\n      }\n    }\n  }\n  if (i > 0) {\n    // create logArgs with what we have so far\n    strBuilder.push('\\x1b[0m');\n    logArgs.push(strBuilder.join(''));\n  }\n  // append the rest\n  for (; i < args.length; i++) {\n    const arg = args[i];\n    /* istanbul ignore else */\n    if (!(arg instanceof Symbol)) {\n      logArgs.push(arg);\n    }\n  }\n  return logArgs\n};\n\n/* istanbul ignore next */\nconst computeLoggingArgs = environment.isNode ? computeNodeLoggingArgs : computeBrowserLoggingArgs;\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nconst print = (...args) => {\n  console.log(...computeLoggingArgs(args));\n  /* istanbul ignore next */\n  vconsoles.forEach(vc => vc.print(args));\n};\n\n/* istanbul ignore next */\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nconst warn = (...args) => {\n  console.warn(...computeLoggingArgs(args));\n  args.unshift(ORANGE);\n  vconsoles.forEach(vc => vc.print(args));\n};\n\n/* istanbul ignore next */\n/**\n * @param {Error} err\n */\nconst printError = err => {\n  console.error(err);\n  vconsoles.forEach(vc => vc.printError(err));\n};\n\n/* istanbul ignore next */\n/**\n * @param {string} url image location\n * @param {number} height height of the image in pixel\n */\nconst printImg = (url, height) => {\n  if (environment.isBrowser) {\n    console.log('%c                      ', `font-size: ${height}px; background-size: contain; background-repeat: no-repeat; background-image: url(${url})`);\n    // console.log('%c                ', `font-size: ${height}x; background: url(${url}) no-repeat;`)\n  }\n  vconsoles.forEach(vc => vc.printImg(url, height));\n};\n\n/* istanbul ignore next */\n/**\n * @param {string} base64\n * @param {number} height\n */\nconst printImgBase64 = (base64, height) => printImg(`data:image/gif;base64,${base64}`, height);\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nconst group = (...args) => {\n  console.group(...computeLoggingArgs(args));\n  /* istanbul ignore next */\n  vconsoles.forEach(vc => vc.group(args));\n};\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nconst groupCollapsed = (...args) => {\n  console.groupCollapsed(...computeLoggingArgs(args));\n  /* istanbul ignore next */\n  vconsoles.forEach(vc => vc.groupCollapsed(args));\n};\n\nconst groupEnd = () => {\n  console.groupEnd();\n  /* istanbul ignore next */\n  vconsoles.forEach(vc => vc.groupEnd());\n};\n\n/* istanbul ignore next */\n/**\n * @param {function():Node} createNode\n */\nconst printDom = createNode =>\n  vconsoles.forEach(vc => vc.printDom(createNode()));\n\n/* istanbul ignore next */\n/**\n * @param {HTMLCanvasElement} canvas\n * @param {number} height\n */\nconst printCanvas = (canvas, height) => printImg(canvas.toDataURL(), height);\n\nconst vconsoles = new Set();\n\n/* istanbul ignore next */\n/**\n * @param {Array<string|Symbol|Object|number>} args\n * @return {Array<Element>}\n */\nconst _computeLineSpans = args => {\n  const spans = [];\n  const currentStyle = new Map();\n  // try with formatting until we find something unsupported\n  let i = 0;\n  for (; i < args.length; i++) {\n    const arg = args[i];\n    // @ts-ignore\n    const style = _browserStyleMap[arg];\n    if (style !== undefined) {\n      currentStyle.set(style.left, style.right);\n    } else {\n      if (arg.constructor === String || arg.constructor === Number) {\n        // @ts-ignore\n        const span = dom.element('span', [pair.create('style', dom.mapToStyleString(currentStyle))], [dom.text(arg)]);\n        if (span.innerHTML === '') {\n          span.innerHTML = '&nbsp;';\n        }\n        spans.push(span);\n      } else {\n        break\n      }\n    }\n  }\n  // append the rest\n  for (; i < args.length; i++) {\n    let content = args[i];\n    if (!(content instanceof Symbol)) {\n      if (content.constructor !== String && content.constructor !== Number) {\n        content = ' ' + json.stringify(content) + ' ';\n      }\n      spans.push(dom.element('span', [], [dom.text(/** @type {string} */ (content))]));\n    }\n  }\n  return spans\n};\n\nconst lineStyle = 'font-family:monospace;border-bottom:1px solid #e2e2e2;padding:2px;';\n\n/* istanbul ignore next */\nclass VConsole {\n  /**\n   * @param {Element} dom\n   */\n  constructor (dom) {\n    this.dom = dom;\n    /**\n     * @type {Element}\n     */\n    this.ccontainer = this.dom;\n    this.depth = 0;\n    vconsoles.add(this);\n  }\n\n  /**\n   * @param {Array<string|Symbol|Object|number>} args\n   * @param {boolean} collapsed\n   */\n  group (args, collapsed = false) {\n    eventloop.enqueue(() => {\n      const triangleDown = dom.element('span', [pair.create('hidden', collapsed), pair.create('style', 'color:grey;font-size:120%;')], [dom.text('')]);\n      const triangleRight = dom.element('span', [pair.create('hidden', !collapsed), pair.create('style', 'color:grey;font-size:125%;')], [dom.text('')]);\n      const content = dom.element('div', [pair.create('style', `${lineStyle};padding-left:${this.depth * 10}px`)], [triangleDown, triangleRight, dom.text(' ')].concat(_computeLineSpans(args)));\n      const nextContainer = dom.element('div', [pair.create('hidden', collapsed)]);\n      const nextLine = dom.element('div', [], [content, nextContainer]);\n      dom.append(this.ccontainer, [nextLine]);\n      this.ccontainer = nextContainer;\n      this.depth++;\n      // when header is clicked, collapse/uncollapse container\n      dom.addEventListener(content, 'click', event => {\n        nextContainer.toggleAttribute('hidden');\n        triangleDown.toggleAttribute('hidden');\n        triangleRight.toggleAttribute('hidden');\n      });\n    });\n  }\n\n  /**\n   * @param {Array<string|Symbol|Object|number>} args\n   */\n  groupCollapsed (args) {\n    this.group(args, true);\n  }\n\n  groupEnd () {\n    eventloop.enqueue(() => {\n      if (this.depth > 0) {\n        this.depth--;\n        // @ts-ignore\n        this.ccontainer = this.ccontainer.parentElement.parentElement;\n      }\n    });\n  }\n\n  /**\n   * @param {Array<string|Symbol|Object|number>} args\n   */\n  print (args) {\n    eventloop.enqueue(() => {\n      dom.append(this.ccontainer, [dom.element('div', [pair.create('style', `${lineStyle};padding-left:${this.depth * 10}px`)], _computeLineSpans(args))]);\n    });\n  }\n\n  /**\n   * @param {Error} err\n   */\n  printError (err) {\n    this.print([RED, BOLD, err.toString()]);\n  }\n\n  /**\n   * @param {string} url\n   * @param {number} height\n   */\n  printImg (url, height) {\n    eventloop.enqueue(() => {\n      dom.append(this.ccontainer, [dom.element('img', [pair.create('src', url), pair.create('height', `${math.round(height * 1.5)}px`)])]);\n    });\n  }\n\n  /**\n   * @param {Node} node\n   */\n  printDom (node) {\n    eventloop.enqueue(() => {\n      dom.append(this.ccontainer, [node]);\n    });\n  }\n\n  destroy () {\n    eventloop.enqueue(() => {\n      vconsoles.delete(this);\n    });\n  }\n}\n\n/* istanbul ignore next */\n/**\n * @param {Element} dom\n */\nconst createVConsole = dom => new VConsole(dom);\n\nconst loggingColors = [GREEN, PURPLE, ORANGE, BLUE];\nlet nextColor = 0;\nlet lastLoggingTime = time.getUnixTime();\n\n/**\n * @param {string} moduleName\n * @return {function(...any):void}\n */\nconst createModuleLogger = moduleName => {\n  const color = loggingColors[nextColor];\n  const debugRegexVar = environment.getVariable('log');\n  const doLogging = debugRegexVar !== null && (debugRegexVar === '*' || debugRegexVar === 'true' || new RegExp(debugRegexVar, 'gi').test(moduleName));\n  nextColor = (nextColor + 1) % loggingColors.length;\n  moduleName += ': ';\n\n  return !doLogging ? _function.nop : (...args) => {\n    const timeNow = time.getUnixTime();\n    const timeDiff = timeNow - lastLoggingTime;\n    lastLoggingTime = timeNow;\n    print(color, moduleName, UNCOLOR, ...args.map(arg => (typeof arg === 'string' || typeof arg === 'symbol') ? arg : JSON.stringify(arg)), color, ' +' + timeDiff + 'ms');\n  }\n};\n\nvar logging = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  BOLD: BOLD,\n  UNBOLD: UNBOLD,\n  BLUE: BLUE,\n  GREY: GREY,\n  GREEN: GREEN,\n  RED: RED,\n  PURPLE: PURPLE,\n  ORANGE: ORANGE,\n  UNCOLOR: UNCOLOR,\n  print: print,\n  warn: warn,\n  printError: printError,\n  printImg: printImg,\n  printImgBase64: printImgBase64,\n  group: group,\n  groupCollapsed: groupCollapsed,\n  groupEnd: groupEnd,\n  printDom: printDom,\n  printCanvas: printCanvas,\n  vconsoles: vconsoles,\n  VConsole: VConsole,\n  createVConsole: createVConsole,\n  createModuleLogger: createModuleLogger\n});\n\nexports.BLUE = BLUE;\nexports.BOLD = BOLD;\nexports.GREEN = GREEN;\nexports.GREY = GREY;\nexports.ORANGE = ORANGE;\nexports.PURPLE = PURPLE;\nexports.RED = RED;\nexports.UNBOLD = UNBOLD;\nexports.UNCOLOR = UNCOLOR;\nexports.VConsole = VConsole;\nexports.createModuleLogger = createModuleLogger;\nexports.createVConsole = createVConsole;\nexports.group = group;\nexports.groupCollapsed = groupCollapsed;\nexports.groupEnd = groupEnd;\nexports.logging = logging;\nexports.print = print;\nexports.printCanvas = printCanvas;\nexports.printDom = printDom;\nexports.printError = printError;\nexports.printImg = printImg;\nexports.printImgBase64 = printImgBase64;\nexports.vconsoles = vconsoles;\nexports.warn = warn;\n//# sourceMappingURL=logging-7cc36806.cjs.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nrequire('./metric.cjs');\nrequire('./math-08e068f9.cjs');\nvar time = require('./time-e00067da.cjs');\n\n\n\nexports.getDate = time.getDate;\nexports.getUnixTime = time.getUnixTime;\nexports.humanizeDuration = time.humanizeDuration;\n//# sourceMappingURL=time.cjs.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar iterator = require('./iterator-fe01d209.cjs');\n\n\n\nexports.createIterator = iterator.createIterator;\nexports.iteratorFilter = iterator.iteratorFilter;\nexports.iteratorMap = iterator.iteratorMap;\nexports.mapIterator = iterator.mapIterator;\n//# sourceMappingURL=iterator.cjs.map\n","'use strict';\n\n/**\n * Utility module to create and manipulate Iterators.\n *\n * @module iterator\n */\n\n/**\n * @template T,R\n * @param {Iterator<T>} iterator\n * @param {function(T):R} f\n * @return {IterableIterator<R>}\n */\nconst mapIterator = (iterator, f) => ({\n  /**\n   * @param {function(T):R} f\n   */\n  [Symbol.iterator] () {\n    return this\n  },\n  // @ts-ignore\n  next () {\n    const r = iterator.next();\n    return { value: r.done ? undefined : f(r.value), done: r.done }\n  }\n});\n\n/**\n * @template T\n * @param {function():IteratorResult<T>} next\n * @return {IterableIterator<T>}\n */\nconst createIterator = next => ({\n  /**\n   * @return {IterableIterator<T>}\n   */\n  [Symbol.iterator] () {\n    return this\n  },\n  // @ts-ignore\n  next\n});\n\n/**\n * @template T\n * @param {Iterator<T>} iterator\n * @param {function(T):boolean} filter\n */\nconst iteratorFilter = (iterator, filter) => createIterator(() => {\n  let res;\n  do {\n    res = iterator.next();\n  } while (!res.done && !filter(res.value))\n  return res\n});\n\n/**\n * @template T,M\n * @param {Iterator<T>} iterator\n * @param {function(T):M} fmap\n */\nconst iteratorMap = (iterator, fmap) => createIterator(() => {\n  const { done, value } = iterator.next();\n  return { done, value: done ? undefined : fmap(value) }\n});\n\nvar iterator = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  mapIterator: mapIterator,\n  createIterator: createIterator,\n  iteratorFilter: iteratorFilter,\n  iteratorMap: iteratorMap\n});\n\nexports.createIterator = createIterator;\nexports.iterator = iterator;\nexports.iteratorFilter = iteratorFilter;\nexports.iteratorMap = iteratorMap;\nexports.mapIterator = mapIterator;\n//# sourceMappingURL=iterator-fe01d209.cjs.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar object = require('./object-dcdd6eed.cjs');\n\n\n\nexports.assign = object.assign;\nexports.create = object.create;\nexports.equalFlat = object.equalFlat;\nexports.every = object.every;\nexports.forEach = object.forEach;\nexports.hasProperty = object.hasProperty;\nexports.keys = object.keys;\nexports.length = object.length;\nexports.map = object.map;\nexports.some = object.some;\n//# sourceMappingURL=object.cjs.map\n",null,null,null,null,null,null],"names":["HMR_HOST","HMR_PORT","HMR_SECURE","HMR_ENV_HASH","module","bundle","HMR_BUNDLE_ID","OVERLAY_ID","OldModule","Module","moduleName","call","hot","data","hotData","_acceptCallbacks","_disposeCallbacks","accept","fn","push","dispose","undefined","checkedAssets","acceptedAssets","assetsToAccept","location","protocol","indexOf","hostname","port","parent","isParcelRequire","WebSocket","getHostname","getPort","test","ws","onmessage","event","JSON","parse","type","removeErrorOverlay","assets","filter","asset","envHash","handled","forEach","didAccept","hmrAcceptCheck","root","id","depsByBundle","console","clear","hmrApply","i","length","hmrAcceptRun","window","reload","ansiDiagnostic","diagnostics","ansi","stack","codeframe","error","message","hints","join","overlay","createErrorOverlay","html","document","body","appendChild","onerror","e","onclose","warn","getElementById","remove","log","createElement","errorHTML","diagnostic","map","hint","innerHTML","modules","parents","k","d","dep","Array","isArray","concat","getParents","link","newLink","cloneNode","onload","parentNode","removeChild","setAttribute","getAttribute","split","Date","now","insertBefore","nextSibling","cssTimeout","setTimeout","links","querySelectorAll","href","servedFromHMRServer","RegExp","absolute","origin","updateLink","reloadCSS","deps","Function","output","cached","cache","some","v","cb","assetsToAlsoAccept","apply","AFRAME","registerComponent","schema","default","width","height","depth","enableInstantInitialization","enableExternalRendering","enablePreview","enableInteraction","enableText","enableWireframe","enableDynamicFrameSkips","minFrameSkips","maxFrameSkips","init","el","frames","frameSkips","has_iframe_loaded","connection_established","camPos","THREE","Vector3","camQuat","Quaternion","containerPos","connectionId","Math","random","CSDT","from","sceneEl","children","reduce","acc","c","hasAttribute","entity","containers","geometry1","BoxBufferGeometry","material1","MeshBasicMaterial","colorWrite","side","DoubleSide","containerMesh","Mesh","visible","geometry","computeBoundingSphere","object3D","add","geometry2","EdgesGeometry","material2","LineBasicMaterial","color","wireframe","LineSegments","text","x","y","z","initializeIframe","syncCanvasSize","utils","throttle","msg","createMessage","openConnection","conn","connections","ydoc","ymap","getMap","hash","messages","preview","onResponseFromChild","res","loader","ObjectLoader","String","detail","obj","position","getWorldPosition","previewObj","sendMessage","addEventListener","pixel","getText","pixels","Uint8Array","update","containerRadius","sqrt","canvas","get","transact","set","syncData","camera","getWorldQuaternion","distance","distanceTo","min","max","floor","sub","toArray","render","customMessages","entry","mainEntry","parcelRequireName","globalName","globalObject","globalThis","self","global","previousRequire","nodeRequire","require","bind","name","jumped","currentRequire","err","Error","code","localRequire","resolve","newRequire","exports","register","Object","defineProperty","mainExports","define","amd","_parcelHelpers","defineInteropFlag","_Connection","_ConnectionDefault","interopDefault","_ParentConnection","_ParentConnectionDefault","_Message","_MessageDefault","_constants","constructor","INTERNAL_MESSAGES","url","connection","closeConnection","iframe","expectsResponse","sentDataType","responseDataType","ConnectionManager","_yjs","_helpers","addIframe","toString","substring","Doc","connectionOpened","applyUpdate","on","sendMessageWithResponse","open","then","once","sendResponse","getResponseTextFromChild","CustomEvent","contentDocument","dispatchEvent","getTextFromParent","responseText","promise","Promise","convertResponse","Connection","value","observable","array","math","encoding","decoding","buffer","binary","f","logging","time","iterator","object","__esModule","n","create","keys","getOwnPropertyDescriptor","enumerable","freeze","array__namespace","_interopNamespace","math__namespace","map__namespace","encoding__namespace","decoding__namespace","random__namespace","buffer__namespace","error__namespace","binary__namespace","f__namespace","set__namespace","logging__namespace","time__namespace","iterator__namespace","object__namespace","Observable","awareness","doc","clock","len","clients","Map","iterateDeletedStructs","transaction","ds","deletes","clientid","structs","store","del","iterateStructs","findIndexDS","dis","left","right","midindex","mid","midclock","isDeleted","client","sortAndMergeDeleteSet","dels","sort","a","b","j","mergeDeleteSets","dss","merged","DeleteSet","dssI","delsLeft","has","slice","appendTo","addToDeleteSet","setIfUndefined","DeleteItem","createDeleteSet","createDeleteSetFromStructStore","ss","dsitems","struct","deleted","next","writeDeleteSet","encoder","writeVarUint","restEncoder","size","resetDsCurVal","item","writeDsClock","writeDsLen","readDeleteSet","decoder","numClients","readVarUint","restDecoder","numberOfDeletes","dsField","readDsClock","readDsLen","readAndApplyDeleteSet","unappliedDS","state","getState","clockEnd","index","findIndexSS","splice","splitItem","delete","UpdateEncoderV2","toUint8Array","generateNewClientId","uint32","guid","uuidv4","gc","gcFilter","meta","autoLoad","clientID","share","StructStore","_transaction","_transactionCleanups","subdocs","Set","_item","shouldLoad","load","subdocsLoaded","getSubdocs","getSubdocGuids","TypeConstructor","AbstractType","t","_integrate","Constr","_map","_start","_length","getArray","YArray","YText","YMap","getXmlFragment","YXmlFragment","toJSON","key","destroy","subdoc","content","opts","subdocsAdded","subdocsRemoved","emit","eventName","off","DSDecoderV1","readLeftID","createID","readRightID","readClient","readInfo","readUint8","readString","readVarString","readParentInfo","readTypeRef","readLen","readAny","readBuf","copyUint8Array","readVarUint8Array","readJSON","readKey","dsCurrVal","diff","DSDecoderV2","keyClockDecoder","IntDiffOptRleDecoder","clientDecoder","UintOptRleDecoder","leftClockDecoder","rightClockDecoder","infoDecoder","RleDecoder","stringDecoder","StringDecoder","parentInfoDecoder","typeRefDecoder","lenDecoder","ID","read","keyClock","createEncoder","DSEncoderV1","writeLeftID","writeRightID","writeClient","writeInfo","info","writeUint8","writeString","s","writeVarString","writeParentInfo","isYKey","writeTypeRef","writeLen","writeAny","any","writeBuf","buf","writeVarUint8Array","writeJSON","embed","stringify","writeKey","unexpectedCase","DSEncoderV2","keyMap","keyClockEncoder","IntDiffOptRleEncoder","clientEncoder","UintOptRleEncoder","leftClockEncoder","rightClockEncoder","infoEncoder","RleEncoder","stringEncoder","StringEncoder","parentInfoEncoder","typeRefEncoder","lenEncoder","writeUint8Array","write","writeStructs","startNewStructs","firstStruct","writeClientsStructs","_sm","sm","getStateVector","entries","readClientsStructRefs","clientRefs","numOfStateUpdates","numberOfStructs","refs","BITS5","GC","Skip","cantCopyParentInfo","BIT7","BIT8","Item","BIT6","readItemContent","integrateStructs","clientsStructRefs","clientsStructRefsIds","getNextStructTarget","nextStructsTarget","pop","curStructsTarget","restStructs","missingSV","updateMissingSv","mclock","stackHead","addStackToRestSS","unapplicableItems","localClock","offset","missing","getMissing","structRefs","integrate","writeStructsFromTransaction","beforeState","readUpdateV2","transactionOrigin","structDecoder","UpdateDecoderV2","local","retry","pending","pendingStructs","mergeUpdatesV2","dsRest","pendingDs","pendingDSUpdate","createDecoder","dsRest2","applyUpdateV2","readUpdate","UpdateDecoderV1","YDecoder","writeStateAsUpdate","targetStateVector","encodeStateAsUpdateV2","encodedTargetStateVector","decodeStateVector","updates","diffUpdateV2","encodeStateAsUpdate","UpdateEncoderV1","readStateVector","ssLength","decodedState","writeStateVector","sv","writeDocumentStateVector","encodeStateVectorV2","encodeStateVector","l","createEventHandler","EventHandler","addEventHandlerListener","eventHandler","removeEventHandlerListener","g","callEventHandlerListeners","arg0","arg1","callAll","compareIDs","writeID","readID","findRootTypeKey","isParentOf","child","logType","m","storeType","yusers","initUser","user","userDescription","ids","addClientId","observe","changes","added","getContent","encodedDs","keysChanged","setUserMapping","users","userOverwrite","_userDescription","yds","deleteSet","getUserByClientId","getUserByDeletedId","tname","assoc","relativePositionToJSON","rpos","json","createRelativePositionFromJSON","RelativePosition","createAbsolutePosition","AbsolutePosition","createRelativePosition","typeid","createRelativePositionFromTypeIndex","countable","lastId","writeRelativePosition","writeVarInt","encodeRelativePosition","readRelativePosition","itemID","hasContent","readVarInt","decodeRelativePosition","uint8Array","createAbsolutePositionFromRelativePosition","rightID","typeID","followRedone","ContentType","compareRelativePositions","equalSnapshots","snap1","snap2","ds1","ds2","sv1","sv2","dsitems1","dsitems2","dsitem1","dsitem2","encodeSnapshotV2","snapshot","encodeSnapshot","decodeSnapshotV2","Snapshot","decodeSnapshot","createSnapshot","emptySnapshot","isVisible","splitSnapshotAffectedStructs","getItemCleanStart","createDocFromSnapshot","originDoc","newDoc","lastStructIndex","lastStruct","addStruct","find","getItem","findIndexCleanStart","getItemCleanEnd","replaceStruct","newStruct","clockStart","afterState","changed","changedParentTypes","_mergeStructs","writeUpdateMessageFromTransaction","addChangedTypeToTransaction","parentSub","tryToMergeWithLeft","pos","mergeWith","tryGcDeleteSet","deleteItems","di","deleteItem","endDeleteItemClock","si","keep","tryMergeDeleteSet","mostRightIndexToCheck","tryGc","cleanupTransactions","transactionCleanups","mergeStructs","fs","subs","itemtype","_callObserver","events","target","currentTarget","event1","event2","path","_dEH","beforeClock","firstChangePos","replacedStructPos","print","ORANGE","BOLD","UNBOLD","RED","_observers","loaded","removed","initialCall","Transaction","deletions","insertions","popStackItem","undoManager","eventType","result","_tr","scope","stackItem","itemsToRedo","itemsToDelete","performedChange","redone","redoItem","deleteFilter","subProps","_searchMarker","typeScope","captureTimeout","trackedOrigins","undoStack","redoStack","undoing","redoing","lastChange","stopCapturing","endClock","startClock","getUnixTime","lastOp","StackItem","keepItem","clearItem","undo","redo","filterSkips","gen","lazyStructReaderGenerator","curr","done","logUpdate","logUpdateV2","updateDecoder","lazyDecoder","LazyStructReader","currClient","written","clientStructs","mergeUpdates","encodeStateVectorFromUpdateV2","YEncoder","currClock","stopCounting","enc","writeBinaryEncoder","encodeStateVectorFromUpdate","parseUpdateMetaV2","to","parseUpdateMeta","sliceStruct","leftItem","rightOrigin","updateDecoders","lazyStructDecoders","currWrite","updateEncoder","lazyStructEncoder","LazyStructWriter","dec","dec1","dec2","clockDiff","currDecoder","firstClient","writeStructToLazyStructWriter","finishLazyStructWriting","lazyStructWriter","reader","svClock","diffUpdate","flushLazyStructWriter","lazyWriter","partStructs","_changes","_keys","_delta","getPathTo","action","oldValue","adds","prev","last","delta","packOp","insert","retain","unshift","maxSearchMarker","globalSearchMarkerTimestamp","p","marker","timestamp","refreshMarkerTimestamp","overwriteMarker","markPosition","searchMarker","pm","ArraySearchMarker","findMarker","yarray","abs","pindex","updateMarkerChanges","getTypeChildren","arr","callTypeObservers","changedType","_eH","_copy","methodUnimplemented","clone","_write","_first","parentSubs","observeDeep","unobserve","unobserveDeep","typeListSlice","start","end","cs","typeListToArray","typeListToArraySnapshot","typeListForEach","typeListMap","typeListCreateIterator","currentContent","currentContentIndex","Symbol","typeListGet","typeListInsertGenericsAfter","referenceItem","ownClientId","jsonContent","packJsonContent","ContentAny","Number","Boolean","ArrayBuffer","ContentBinary","ContentDoc","typeListInsertGenerics","startIndex","typeListDelete","startLength","typeMapDelete","typeMapSet","typeMapGet","val","typeMapGetAll","typeMapHas","typeMapGetSnapshot","createMapIterator","iteratorFilter","YEvent","_prelimContent","items","YArrayEvent","YArrayRefID","readYArray","YMapEvent","iteratorMap","values","YMapRefID","readYMap","equalAttrs","equalFlat","currentAttributes","forward","ContentEmbed","ContentString","ContentFormat","updateCurrentAttributes","findNextPosition","count","findPosition","ItemTextListPosition","insertNegatedAttributes","currPos","negatedAttributes","nextFormat","format","minimizeAttributeChanges","attributes","insertAttributes","currentVal","insertText","getLength","formatText","attr","newlines","cleanupFormattingGap","startAttributes","endAttributes","cleanups","cleanupContextlessFormattingGap","attrs","cleanupYTextFormatting","copy","deleteText","startAttrs","ytext","childListChanged","oldAttributes","deleteLen","addOp","op","str","curVal","string","_pending","applyDelta","toDelta","YTextEvent","foundFormattingItem","afterClock","sanitize","ins","prevSnapshot","computeYChange","ops","addAttributes","cur","packStr","insertEmbed","removeAttribute","attributeName","attributeValue","getAttributes","YTextRefID","readYText","_filter","_root","_currentNode","_firstCall","YXmlElement","firstChild","first","createTreeWalker","YXmlTreeWalker","querySelector","query","toUpperCase","element","nodeName","YXmlEvent","xml","toDOM","_document","hooks","binding","fragment","createDocumentFragment","_createAssociation","xmlType","insertAfter","ref","refItem","pc","findIndex","YXmlFragmentRefID","readYXmlFragment","_prelimAttrs","prevSibling","stringBuilder","keysLen","toLocaleLowerCase","attrsString","dom","yxml","YXmlElementRefID","readYXmlElement","attributesChanged","hookName","YXmlHook","hook","createDom","YXmlHookRefID","readYXmlHook","YXmlText","createTextNode","nestedNodes","node","YXmlTextRefID","readYXmlText","encodingRef","structGCRefNumber","AbstractStruct","isCountable","getRef","readContentBinary","ContentDeleted","markDeleted","readContentDeleted","readContentDoc","readContentEmbed","readContentFormat","ContentJSON","readContentJSON","readContentAny","firstCharCode","charCodeAt","readContentString","typeRefs","readContentType","nextID","rightItem","redoitems","ownClientID","parentItem","leftTrace","rightTrace","nextClock","nextId","redoneItem","BIT2","isMarked","BIT4","BIT1","doKeep","BIT3","doDelete","o","conflictingItems","itemsBeforeOrigin","r","parentGCd","ykey","contentRefs","structSkipRefNumber","AbstractConnector","PermanentUserData","Text","UndoManager","XmlElement","XmlFragment","XmlHook","XmlText","_f","args","observers","createT","all","map$1","__proto__","dest","src","every","flatten","ceil","exp10","imul","isNaN","isNegativeZero","log10","log2","pow","round","sign","exp","Encoder","IncUintOptRleEncoder","IntDiffEncoder","RleIntDiffEncoder","setUint16","setUint32","setUint8","writeBigInt64","writeBigUint64","writeFloat32","writeFloat64","writeOnDataView","writeUint16","writeUint32","writeUint32BigEndian","Buffer","environment","number","cpos","cbuf","bufs","uint8arr","curPos","createUint8ArrayViewFromArrayBuffer","verifyLen","bufferLen","num","BITS8","BITS7","isNegative","BITS6","encodedString","unescape","encodeURIComponent","codePointAt","append","leftCopyLen","rightCopyLen","subarray","byteLength","dview","DataView","setFloat32","setFloat64","setBigInt64","setBigUint64","floatTestBed","isFloat32","getFloat32","isInteger","BITS31","writer","w","flushUintOptRleEncoder","flushIntDiffOptRleEncoder","encodedDiff","sarr","lensE","Decoder","newPos","_decoder","readUint8Array","view","byteOffset","readTailAsUint8Array","skip8","readUint16","uint","readUint32","readUint32BigEndian","peekUint8","peekUint16","peekUint32","peekVarUint","peekVarInt","remainingLen","fromCodePoint","nextLen","bytes","decodeURIComponent","escape","peekVarString","readFromDataView","dv","readFloat32","readFloat64","getFloat64","readBigInt64","getBigInt64","readBigUint64","getBigUint64","readAnyLookupTable","hasCount","spos","IntDiffDecoder","RleIntDiffDecoder","IncUintOptRleDecoder","createUint8ArrayFromLen","createUint8ArrayFromArrayBuffer","toBase64Browser","fromCharCode","btoa","toBase64Node","fromBase64Browser","atob","fromBase64Node","toBase64","isBrowser","fromBase64","newBuf","encodeAny","decodeAny","base64","ieee754","customInspectSymbol","SlowBuffer","INSPECT_MAX_BYTES","K_MAX_LENGTH","kMaxLength","TYPED_ARRAY_SUPPORT","typedArraySupport","proto","foo","setPrototypeOf","prototype","isBuffer","RangeError","arg","encodingOrOffset","TypeError","allocUnsafe","poolSize","fromString","isView","fromArrayView","isInstance","fromArrayBuffer","SharedArrayBuffer","valueOf","fromObject","toPrimitive","fill","assertSize","createBuffer","alloc","checked","allocUnsafeSlow","isEncoding","actual","arrayView","fromArrayLike","numberIsNaN","_isBuffer","compare","toLowerCase","list","mustMatch","arguments","loweredCase","utf8ToBytes","base64ToBytes","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap16","swap","swap32","swap64","slowToString","toLocaleString","equals","inspect","replace","trim","thisStart","thisEnd","thisCopy","targetCopy","dir","arrayIndexOf","lastIndexOf","indexSize","arrLength","valLength","readUInt16BE","foundIndex","found","includes","bidirectionalIndexOf","remaining","strLen","parsed","parseInt","substr","blitBuffer","asciiToBytes","utf16leToBytes","isFinite","hexWrite","utf8Write","asciiWrite","base64Write","ucs2Write","_arr","fromByteArray","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","decodeCodePointsArray","MAX_ARGUMENTS_LENGTH","codePoints","ret","out","hexSliceLookupTable","ext","readUintLE","readUIntLE","noAssert","checkOffset","mul","readUintBE","readUIntBE","readUInt8","readUint16LE","readUInt16LE","readUint16BE","readUint32LE","readUInt32LE","readUint32BE","readUInt32BE","readIntLE","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUintLE","writeUIntLE","maxBytes","checkInt","writeUintBE","writeUIntBE","writeUInt8","writeUint16LE","writeUInt16LE","writeUint16BE","writeUInt16BE","writeUint32LE","writeUInt32LE","writeUint32BE","writeUInt32BE","writeIntLE","limit","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","littleEndian","checkIEEE754","writeFloatLE","writeFloat","writeFloatBE","writeDoubleLE","writeDouble","writeDoubleBE","targetStart","copyWithin","INVALID_BASE64_RE","units","Infinity","leadSurrogate","byteArray","hi","lo","toByteArray","base64clean","dst","alphabet","table","i16","lookup","revLookup","Arr","b64","validLen","placeHoldersLen","lens","getLens","tmp","_byteLength","curByte","uint8","tripletToBase64","extraBytes","parts","maxChunkLength","len2","encodeChunk","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","NaN","rt","LN2","trimLeftRegex","trimLeft","fromCamelCaseRegex","fromCamelCase","separator","match","utf8ByteLength","_encodeUtf8Polyfill","utf8TextEncoder","TextEncoder","_encodeUtf8Native","encode","encodeUtf8","_decodeUtf8Polyfill","bufPos","utf8TextDecoder","TextDecoder","fatal","ignoreBOM","decode","_decodeUtf8Native","decodeUtf8","process","conditions","storage","isNode","release","isMac","navigator","platform","params","computeParams","pargs","argv","currParamName","parg","search","kv","hasParam","getParam","defaultVal","getVariable","undefinedToNull","env","varStorage","getConf","hasConf","production","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","clearTimeout","defaultClearTimeout","fun","queue","draining","currentQueue","queueIndex","drainQueue","timeout","runTimeout","cleanUpNextTick","run","runClearTimeout","nextTick","title","browser","version","versions","noop","addListener","removeListener","removeAllListeners","prependListener","prependOnceListener","listeners","cwd","chdir","umask","setItem","newValue","_localStorage","VarStoragePolyfill","usePolyfill","localStorage","onChange","BIT5","BIT9","BIT10","BIT11","BIT12","BIT13","BIT14","BIT15","BIT16","BIT17","BIT18","BIT19","BIT20","BIT21","BIT22","BIT23","BIT24","BIT25","BIT26","BIT27","BIT28","BIT29","BIT30","BIT31","BIT32","BITS0","BITS1","BITS2","BITS3","BITS4","BITS9","BITS10","BITS11","BITS12","BITS13","BITS14","BITS15","BITS16","BITS17","BITS18","BITS19","BITS20","BITS21","BITS22","BITS23","BITS24","BITS25","BITS26","BITS27","BITS28","BITS29","BITS30","BITS32","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","LOWEST_INT32","HIGHEST_INT32","isomorphic_js","rand","Uint32Array","cryptoRandomBuffer","oneOf","uuidv4Template","export","performance","isoCrypto","crypto","getRandomValues","exportAll","source","destName","_function","equalityDeep","equalityFlat","equalityStrict","nop","assign","results","hasProperty","hasOwnProperty","BLUE","GREEN","GREY","PURPLE","UNCOLOR","VConsole","createModuleLogger","createVConsole","group","groupCollapsed","groupEnd","printCanvas","printDom","printError","printImg","printImgBase64","vconsoles","isSymbol","symbol","Pair","createReversed","pair","domParser","DOMParser","emitCustomEvent","setAttributes","setAttributesMap","nodes","removeEventListener","addEventListeners","removeEventListeners","pairToStyleString","pairsToStyleString","pairs","mapToStyleString","_parse","parseFromString","parseFragment","childNodes","parseElement","firstElementChild","replaceWith","oldEl","newEl","ELEMENT_NODE","TEXT_NODE","CDATA_SECTION_NODE","COMMENT_NODE","DOCUMENT_NODE","DOCUMENT_TYPE_NODE","DOCUMENT_FRAGMENT_NODE","checkNodeType","nodeType","_runQueue","enqueue","createTimeoutClass","clearFunction","timeoutId","_","Timeout","callback","Interval","clearInterval","interval","setInterval","Animation","requestAnimationFrame","cancelAnimationFrame","animationFrame","Idle","cancelIdleCallback","idleCallback","requestIdleCallback","createDebouncer","timer","eventloop","metric","getDate","humanizeDuration","prefix","seconds","minutes","hours","days","yotta","zetta","exa","peta","tera","giga","mega","kilo","hecto","deca","deci","centi","milli","micro","nano","pico","femto","atto","zepto","yocto","prefixUp","prefixDown","baseMultiplier","nPow","mult","_browserStyleMap","_nodeStyleMap","computeBrowserLoggingArgs","strBuilder","styles","currentStyle","logArgs","style","computeNodeLoggingArgs","computeLoggingArgs","vc","createNode","toDataURL","_computeLineSpans","spans","span","lineStyle","ccontainer","collapsed","triangleDown","triangleRight","nextContainer","nextLine","toggleAttribute","parentElement","loggingColors","nextColor","lastLoggingTime","debugRegexVar","doLogging","timeNow","timeDiff","createIterator","mapIterator","fmap","convertType","display","border","getTextFromChild","getResponseText","getResponseTextFromParent","convertSent","onMessageFromParent","func","onMessageFromChild","onResponseFromParent","Message","ParentConnection","player","renderer","connection_opened","setAnimationLoop","canvasWidth","canvasHeight","renderTarget","WebGLRenderTarget","setRenderTarget","setSize","aspect","updateProjectionMatrix","fromArray","quat","quaternion","renderScene","readRenderTargetPixels","scene","getDelta","elapsedTime","isPlaying","tick","savedBackground","is","background"],"version":3,"file":"export.js.map","sourceRoot":"../"}